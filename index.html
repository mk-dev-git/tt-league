
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Table Tennis League Manager</title>

  <script src="https://cdn.tailwindcss.com"></script>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    /* ==========================================================
       THEME TOKENS (Dark default) — 모든 UI 색상은 여기 변수로 통합
       ========================================================== */
    :root {
      /* Layout / Base */
      --bg-body: #020617;
      --text-main: #e2e8f0;
      --text-muted: #94a3b8;

      --card-bg: rgba(15, 23, 42, 0.7);
      --card-border: rgba(255, 255, 255, 0.1);

      --table-header-bg: rgba(30, 41, 59, 0.9);
      --table-border: #334155;
      --table-cell-border: #1e293b;

      --input-bg: transparent;
      --input-focus: #1e293b;

      --highlight-bg: #1e293b;

      --diagonal-bg: #1e293b;
      --diagonal-line: #475569;

      --select-bg: rgba(2, 6, 23, 0.95);
      --select-text: #e2e8f0;

      /* Brand / Header */
      --brand-logo-grad-from: #0ea5e9;  /* sky-500 */
      --brand-logo-grad-to: #4f46e5;    /* indigo-600 */
      --brand-logo-text: #ffffff;

      --brand-title-grad-from: #38bdf8; /* sky-400 */
      --brand-title-grad-to: #818cf8;   /* indigo-400 */

      --divider: #334155;

      /* Tabs (상단 메뉴) */
      --tab-active-border: #38bdf8;
      --tab-active-text: #38bdf8;
      --tab-active-bg: rgba(56, 189, 248, 0.10);

      --tab-inactive-text: #94a3b8;
      --tab-inactive-hover-text: #e2e8f0;

      /* Accent + Buttons */
      --accent: #38bdf8;
      --accent-strong: #0ea5e9;
      --accent-2: #4f46e5;

      --btn-primary-bg: linear-gradient(90deg, #0ea5e9, #4f46e5);
      --btn-primary-shadow: rgba(14, 165, 233, 0.35);

      --btn-secondary-bg: rgba(51, 65, 85, 0.75);
      --btn-secondary-bg-hover: rgba(71, 85, 105, 0.85);
      --btn-secondary-border: rgba(71, 85, 105, 0.90);
      --btn-secondary-text: #e2e8f0;
      --btn-secondary-text-hover: #ffffff;

      --btn-danger-bg: rgba(127, 29, 29, 0.35);
      --btn-danger-bg-hover: rgba(153, 27, 27, 0.45);
      --btn-danger-border: rgba(185, 28, 28, 0.55);
      --btn-danger-text: #fecaca;

      --btn-ghost-bg-hover: rgba(30, 41, 59, 0.65);
      --btn-ghost-text: #94a3b8;
      --btn-ghost-text-hover: #e2e8f0;

      --tag-bg: rgba(51, 65, 85, 0.75);
      --tag-border: rgba(71, 85, 105, 0.90);
      --tag-text: #e2e8f0;

      --toggle-bg: rgba(51, 65, 85, 0.85);
      --toggle-bg-checked: rgba(56, 189, 248, 0.85);

      /* Group table (조별 결과) */
      --matrix-input-text: #38bdf8;
      --matrix-focus-ring: #38bdf8;
      --highlight-active-bg: rgba(56, 189, 248, 0.15);
      --highlight-mirror-bg: rgba(56, 189, 248, 0.05);
      --highlight-header-text: #38bdf8;
      --highlight-header-bg: rgba(56, 189, 248, 0.10);
      --resize-handle-accent: #38bdf8;

      /* Lists / Table row states */
      --table-row-hover-bg: rgba(51, 65, 85, 0.30);
      --table-row-editing-bg: rgba(49, 46, 129, 0.30); /* indigo-900/30 */
      --team-level-text: #818cf8; /* indigo-400 */
      --qualified-row-bg: rgba(49, 46, 129, 0.20);

      /* Rank button */
      --rank-btn-bg: rgba(49, 46, 129, 0.50);
      --rank-btn-bg-hover: rgba(55, 48, 163, 0.85);
      --rank-btn-border: rgba(55, 48, 163, 0.90);
      --rank-btn-text: #a5b4fc;

      /* Modal / Overlay */
      --modal-overlay-bg: rgba(0, 0, 0, 0.55);

      --warning-bg: rgba(120, 53, 15, 0.30);
      --warning-text: #fde68a;
      --warning-border: rgba(120, 53, 15, 0.50);

      --swap-item-hover-bg: rgba(49, 46, 129, 0.40);
      --swap-item-hover-border: #6366f1; /* indigo-500 */
      --swap-item-hover-shadow: rgba(49, 46, 129, 0.20);

      /* Tournament (토너먼트) */
      --tournament-line: #ccc;
      --tournament-line-active: #555;
      --tournament-winner: #fbbf24;
      --tournament-winner-shadow: rgba(251, 191, 36, 0.4);
      --tournament-winner-glow: rgba(251, 191, 36, 0.2);
      --tournament-winner-bg2: #451a03;
      --tournament-team-hover-bg: rgba(56, 189, 248, 0.10);
      --tournament-team-hover-text: #38bdf8;
      --tournament-card-hover-border: #38bdf8;

      --final-title-text: #fbbf24;
      --final-title-shadow: rgba(245, 158, 11, 0.50);

      --champion-grad-from: #fcd34d; /* amber-300 */
      --champion-grad-mid: #fbbf24;  /* yellow-400 */
      --champion-grad-to: #fcd34d;
      --champion-text: #451a03;      /* amber-950 */
      --champion-subtext: #78350f;
      --champion-ring: rgba(255, 255, 255, 0.50);
      --champion-shadow: rgba(251, 191, 36, 0.60);

      --trophy-placeholder-bg: #1f2937;
      --trophy-placeholder-border: #334155;
      --trophy-placeholder-icon: #475569;

      /* Tournament controls (우측 상단 줌 컨트롤) */
      --control-pill-bg: rgba(30, 41, 59, 0.80);
      --control-pill-border: rgba(51, 65, 85, 0.55);
      --control-icon: #94a3b8;
      --control-icon-hover: #38bdf8;
      --control-hover-bg: rgba(51, 65, 85, 0.55);
      --control-divider: #334155;
      --control-helper-text: #94a3b8;
      
      --dynamic-card-width: 110px;
    }

    /* ==========================================================
       Light theme overrides
       ========================================================== */
    body.light-mode {
      --bg-body: #f1f5f9;
      --text-main: #0f172a;
      --text-muted: #64748b;

      --card-bg: rgba(255, 255, 255, 0.82);
      --card-border: #cbd5e1;

      --table-header-bg: #e2e8f0;
      --table-border: #cbd5e1;
      --table-cell-border: #e2e8f0;

      --input-bg: transparent;
      --input-focus: #f8fafc;

      --highlight-bg: #f1f5f9;

      --diagonal-bg: #f1f5f9;
      --diagonal-line: #cbd5e1;

      --select-bg: #ffffff;
      --select-text: #0f172a;

      --divider: #cbd5e1;

      --tab-active-border: #0ea5e9;
      --tab-active-text: #0ea5e9;
      --tab-active-bg: rgba(14, 165, 233, 0.08);

      --tab-inactive-text: #64748b;
      --tab-inactive-hover-text: #0f172a;

      --btn-secondary-bg: rgba(226, 232, 240, 0.92);
      --btn-secondary-bg-hover: rgba(203, 213, 225, 1);
      --btn-secondary-border: rgba(148, 163, 184, 0.90);
      --btn-secondary-text: #0f172a;
      --btn-secondary-text-hover: #0f172a;

      --btn-danger-bg: rgba(254, 226, 226, 0.95);
      --btn-danger-bg-hover: rgba(252, 165, 165, 0.90);
      --btn-danger-border: rgba(248, 113, 113, 0.85);
      --btn-danger-text: #7f1d1d;

      --btn-ghost-bg-hover: rgba(226, 232, 240, 0.85);
      --btn-ghost-text: #475569;
      --btn-ghost-text-hover: #0f172a;

      --tag-bg: rgba(226, 232, 240, 0.92);
      --tag-border: rgba(148, 163, 184, 0.90);
      --tag-text: #0f172a;

      --toggle-bg: rgba(203, 213, 225, 1);
      --toggle-bg-checked: rgba(56, 189, 248, 0.85);

      --matrix-input-text: #0ea5e9;
      --matrix-focus-ring: #0ea5e9;
      --highlight-active-bg: rgba(56, 189, 248, 0.12);
      --highlight-mirror-bg: rgba(56, 189, 248, 0.04);
      --highlight-header-text: #0ea5e9;
      --highlight-header-bg: rgba(56, 189, 248, 0.08);
      --resize-handle-accent: #0ea5e9;

      --table-row-hover-bg: rgba(203, 213, 225, 0.55);
      --table-row-editing-bg: rgba(224, 231, 255, 0.70);
      --team-level-text: #4f46e5;
      --qualified-row-bg: rgba(224, 231, 255, 0.65);

      --rank-btn-bg: rgba(224, 231, 255, 0.85);
      --rank-btn-bg-hover: rgba(199, 210, 254, 0.95);
      --rank-btn-border: rgba(99, 102, 241, 0.65);
      --rank-btn-text: #3730a3;

      --modal-overlay-bg: rgba(2, 6, 23, 0.45);

      --warning-bg: rgba(254, 243, 199, 0.95);
      --warning-text: #7c2d12;
      --warning-border: rgba(251, 191, 36, 0.55);

      --swap-item-hover-bg: rgba(224, 231, 255, 0.70);
      --swap-item-hover-border: rgba(99, 102, 241, 0.75);
      --swap-item-hover-shadow: rgba(99, 102, 241, 0.12);

      --tournament-line: #64748b;
      --tournament-line-active: #910cf7;
      --tournament-winner: #910cf7;
      --tournament-winner-shadow: rgba(217, 119, 6, 0);
      --tournament-winner-glow: rgba(245, 158, 11, 0);
      --tournament-winner-bg2: #ffffff;
      --tournament-team-hover-bg: rgba(56, 189, 248, 0.10);
      --tournament-team-hover-text: #0ea5e9;
      --tournament-card-hover-border: #0ea5e9;

      --final-title-text: #910cf7;
      --final-title-shadow: rgba(217, 119, 6, 0.35);

      --champion-grad-from: #fde68a;
      --champion-grad-mid: #910cf7;
      --champion-grad-to: #fde68a;
      --champion-text: #7c2d12;
      --champion-subtext: #7c2d12;
      --champion-ring: rgba(255, 255, 255, 0.55);
      --champion-shadow: rgba(245, 158, 11, 0.35);

      --trophy-placeholder-bg: #e2e8f0;
      --trophy-placeholder-border: #cbd5e1;
      --trophy-placeholder-icon: #64748b;

      --control-pill-bg: rgba(255, 255, 255, 0.92);
      --control-pill-border: rgba(203, 213, 225, 0.95);
      --control-icon: #64748b;
      --control-icon-hover: #0ea5e9;
      --control-hover-bg: rgba(226, 232, 240, 0.85);
      --control-divider: #cbd5e1;
      --control-helper-text: #64748b;
    }

    body {
      font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, Roboto, sans-serif;
      background-color: var(--bg-body);
      color: var(--text-main);
      overflow: hidden;
      margin: 0;
      padding: 0;
      transition: background-color 0.3s, color 0.3s;
    }

    /* ==========================================================
       [수정] 예선 리그 테이블 승/패, 득/실 한 줄 표시 스타일
       ========================================================== */
    .stat-split-cell {
      display: flex;            /* 요소들을 가로로 배치 */
      align-items: center;      /* 수직 중앙 정렬 */
      justify-content: center;  /* 수평 중앙 정렬 */
      width: 100%;
      height: 100%;
      gap: 1px;
      white-space: nowrap;
    }

    .stat-split-input {
      width: auto !important;   /* [수정] 40% 고정 제거 -> 자동 너비 */
      flex: 1;                  /* [추가] 남은 공간 균등 분배 */
      min-width: 0;             /* Flexbox 내에서 크기 찌그러짐 방지 */
      text-align: center;       /* 텍스트 중앙 정렬 */
      padding: 0 !important;    /* 불필요한 패딩 제거 */
    }
    
    /* Custom Scrollbar */
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: var(--bg-body); }
    ::-webkit-scrollbar-thumb { background: var(--table-border); border-radius: 4px; }

    /* Common Components */
    .btn-base { border: 1px solid transparent; }
    .btn-primary { background: var(--btn-primary-bg); color: #ffffff; box-shadow: 0 10px 18px -12px var(--btn-primary-shadow); }
    .btn-primary:hover { filter: brightness(1.05); }

    .btn-secondary { background: var(--btn-secondary-bg); border-color: var(--btn-secondary-border); color: var(--btn-secondary-text); }
    .btn-secondary:hover { background: var(--btn-secondary-bg-hover); color: var(--btn-secondary-text-hover); }

    .btn-danger { background: var(--btn-danger-bg); border-color: var(--btn-danger-border); color: var(--btn-danger-text); }
    .btn-danger:hover { background: var(--btn-danger-bg-hover); }

    .btn-magic { background: linear-gradient(90deg, #7c3aed, #d946ef); color: #ffffff; box-shadow: 0 10px 18px -12px rgba(217, 70, 239, 0.35); }
    .btn-magic:hover { filter: brightness(1.05); }

    .btn-ghost { background: transparent; color: var(--btn-ghost-text); border-color: transparent; }
    .btn-ghost:hover { background: var(--btn-ghost-bg-hover); color: var(--btn-ghost-text-hover); }

    .mini-btn {
      font-size: 10px;
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid var(--btn-secondary-border);
      background: var(--btn-secondary-bg);
      color: var(--btn-secondary-text);
      transition: background-color 0.15s ease, color 0.15s ease, border-color 0.15s ease;
    }
    .mini-btn:hover { background: var(--btn-secondary-bg-hover); color: var(--btn-secondary-text-hover); }

    .tag {
      font-size: 10px;
      font-weight: 700;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--tag-border);
      background: var(--tag-bg);
      color: var(--tag-text);
    }

    /* Toggle visuals */
    .toggle-label { background-color: var(--toggle-bg) !important; }
    .toggle-checkbox:checked + .toggle-label { background-color: var(--toggle-bg-checked) !important; }
    .toggle-label::after { transition: transform 0.18s ease; }
    .toggle-checkbox:checked + .toggle-label::after { transform: translateX(20px); }

    /* Table */
    .modern-table { border-collapse: collapse; border-spacing: 0; width: 100%; table-layout: auto; }
    .modern-table.table-auto { table-layout: auto;}
    .modern-table th { background-color: var(--table-header-bg); color: var(--text-muted); font-weight: 700; padding: 12px 8px; border: 1px solid var(--table-border); font-size: 0.8rem; text-align: center; }
    .modern-table td { border: 1px solid var(--table-border); color: var(--text-main); font-size: 0.9rem; text-align: center; height: 48px; }
    .member-cell { text-align: left !important; padding: 4px 16px !important; }

    .diagonal-cell {
      background-color: var(--diagonal-bg);
      background-image: linear-gradient(to bottom left, transparent calc(50% - 1px), var(--diagonal-line) calc(50% - 1px), var(--diagonal-line) calc(50% + 1px), transparent calc(50% + 1px));
    }

    /* Inputs */
    .matrix-input { width: 100%; height: 100%; text-align: center; background: var(--input-bg); outline: none; color: var(--matrix-input-text); font-weight: 700; font-size: 1rem; border: none; }
    .matrix-input:focus { background-color: var(--input-focus); box-shadow: inset 0 0 0 2px var(--matrix-focus-ring); color: var(--text-main); }
    .manual-input { width: 100%; height: 100%; text-align: center; background: transparent; outline: none; color: var(--text-muted); font-weight: 600; }

    /* Select */
    select { background-color: var(--select-bg) !important; color: var(--select-text) !important; border-color: var(--table-border) !important; }
    select:focus { outline: none !important; box-shadow: inset 0 0 0 2px var(--matrix-focus-ring) !important; }
    select option { background-color: var(--select-bg) !important; color: var(--select-text) !important; }

    /* Card */
    .resizable-card {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 1rem;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      transition: height 0.2s ease, background-color 0.3s, border-color 0.3s;
    }
    .resize-handle { position: absolute; bottom: 0; right: 0; width: 20px; height: 20px; cursor: nwse-resize; z-index: 20; background: linear-gradient(135deg, transparent 50%, var(--resize-handle-accent) 50%); }

    /* Highlight */
    .highlight-active { background-color: var(--highlight-active-bg) !important; }
    .highlight-mirror { background-color: var(--highlight-mirror-bg) !important; }
    .highlight-header { color: var(--highlight-header-text) !important; font-weight: 900 !important; background-color: var(--highlight-header-bg); }

    /* App-specific utility */
    .brand-logo { background: linear-gradient(135deg, var(--brand-logo-grad-from), var(--brand-logo-grad-to)); color: var(--brand-logo-text); }
    .brand-title { background-image: linear-gradient(to right, var(--brand-title-grad-from), var(--brand-title-grad-to)); }
    .tab-btn { border-bottom-width: 2px; border-style: solid; }
    .tab-btn:hover { color: var(--tab-inactive-hover-text); }
    .divider { background-color: var(--divider); }

    .team-row:hover { background-color: var(--table-row-hover-bg); }
    .team-row.editing { background-color: var(--table-row-editing-bg); }
    
    .team-row.group-odd { background-color: var(--highlight-active-bg); }
    .team-row.group-odd:hover { background-color: var(--table-row-hover-bg); }
    
    .rank-btn { background: var(--rank-btn-bg); color: var(--rank-btn-text); border: 1px solid var(--rank-btn-border); }
    .rank-btn:hover { background: var(--rank-btn-bg-hover); }

    /* ==========================================================
       Tournament Layout (from original, kept)
       ========================================================== */
    .tournament-container-wrapper { width: 100vw; height: calc(100vh - 70px); overflow: hidden; background-color: var(--bg-body); position: relative; }
    .tournament-viewport { width: 100%; height: 100%; cursor: grab; background-image: radial-gradient(var(--table-cell-border) 1px, transparent 1px); background-size: 24px 24px; touch-action: none; }
    .tournament-canvas { transform-origin: center center; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; will-change: transform; }
    .tournament-tree { display: flex; justify-content: center; align-items: stretch; padding: 40px; gap: 0px; }
    .wing-container { display: flex; flex: 1; justify-content: flex-end; }
    .wing-container.right-wing { flex-direction: row-reverse; justify-content: flex-end; }
    .round-column { display: flex; flex-direction: column; justify-content: space-around; flex: 1; min-width: 320px; position: relative; }
    
    .match-card {
      background: #fff;
      border: 1px solid #ccc !important;
      border-radius: 4px !important;     /* 각진 모서리 */
      box-shadow: none !important;       /* 그림자 제거 */
      padding: 0 !important;             /* 패딩 제거 */
      min-height: 52px;                  /* 높이 고정 */
    }
    .match-card:hover {
      border-color: #888 !important;
    }
    .match-card.winner-card { border-color: var(--tournament-winner); box-shadow: 0 0 15px var(--tournament-winner-glow); background: linear-gradient(to bottom right, var(--table-cell-border), var(--tournament-winner-bg2)); }
    /* 팀명 사이 구분선 추가 */
    .match-wrapper .flex-col > div:first-child {
      border-bottom: 1px solid #eee !important;
    }
    /* 팀명 박스 스타일 */
    .match-wrapper .flex-col > div {
      border: none !important;           /* 내부 보더 제거 */
      background: transparent !important;
      padding: 2px 6px !important;
      margin: 0 !important;
      border-radius: 0 !important;
      font-size: 11px !important;        /* 폰트 작게 */
      height: 24px;
      display: flex;
      align-items: center;
    }
    
    /* 팀명 사이 구분선 추가 */
    .match-wrapper .flex-col > div:first-child {
      border-bottom: 1px solid #eee !important;
    }

    /* 승자 스타일 */
    .winner-text {
      color: #000 !important;
      font-weight: 800 !important;
    }
    .match-wrapper .flex-col > div:has(.winner-text) {
      background-color: #f8f8f8 !important; /* 승자 배경 살짝 회색 */
    }

    /* 3. 연결선(Bracket Line) 스타일 직각화 및 얇게 */
    .bracket-line {
      border-width: 0 !important; /* 기존 두께 초기화 */
      border-color: #bbb !important;
    }
    
    /* 각 라인별 1px 두께 적용 */
    .line-left-top { border-top-width: 1px !important; border-right-width: 1px !important; }
    .line-left-bottom { border-bottom-width: 1px !important; border-right-width: 1px !important; }
    .line-right-top { border-top-width: 1px !important; border-left-width: 1px !important; }
    .line-right-bottom { border-bottom-width: 1px !important; border-left-width: 1px !important; }
    .line-straight { border-top-width: 1px !important; }

    /* 활성화 된 라인 (승자 경로) */
    .bracket-line.active {
      border-color: #555 !important;
      z-index: 0;
    }
    
    
    .line-segment { position: absolute; background-color: var(--tournament-line); opacity: 0.8; z-index: 0; pointer-events: none; transition: background-color 0.3s; }
    .active-line { background-color: var(--tournament-line-active) !important; opacity: 1 !important; box-shadow: 0 0 6px var(--tournament-line-active); }
    .l-h-line { height: 2px; top: 50%; right: 0; width: 30px; }
    .l-v-top { width: 2px; right: 0; top: 50%; height: 50%; }
    .l-v-bottom { width: 2px; right: 0; top: 0; height: 50%; }
    .l-tail { height: 2px; top: 50%; left: 0; width: 30px; }
    .r-h-line { height: 2px; top: 50%; left: 0; width: 30px; }
    .r-v-top { width: 2px; left: 0; top: 50%; height: 50%; }
    .r-v-bottom { width: 2px; left: 0; top: 0; height: 50%; }
    .r-tail { height: 2px; top: 50%; right: 0; width: 30px; }
    .l-h-line.straight-only { width: 50px !important; right: -20px !important; }
    .r-h-line.straight-only { width: 50px !important; left: -20px !important; }

    .team-name-btn { cursor: pointer; font-size: 1rem; font-weight: 700; padding: 4px 8px; border-radius: 4px; display: block; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; color: var(--text-muted); }
    .team-name-btn:hover { color: var(--tournament-team-hover-text); background: var(--tournament-team-hover-bg); }
    .team-name-btn.winner-text { color: var(--tournament-winner); text-shadow: 0 0 10px var(--tournament-winner-shadow); }
    .score-input { width: 36px; height: 28px; text-align: center; border: 1px solid var(--table-border); background: var(--bg-body); color: var(--text-main); font-weight: bold; border-radius: 4px; font-size: 14px; }

    /* Modal */
    .modal-overlay { position: fixed; inset: 0; background: var(--modal-overlay-bg); z-index: 100; display: flex; justify-content: center; align-items: center; }
    .modal-content { background: var(--highlight-bg); padding: 20px; border-radius: 16px; width: 90%; max-width: 500px; max-height: 80vh; border: 1px solid var(--table-border); color: var(--text-main); }

    /* Print (kept, mostly black/white) */
    .print-only { display: none; }
    .print-only-inline { display: none; }
    .screen-only { display: inline; }

    @media print {
      .screen-only { display: none !important; }
      .print-only-inline { display: inline !important; }

      @page { size: A4 landscape; margin: 1cm; }

      html, body, #root {
        background-color: white !important;
        color: black !important;
        width: 100% !important;
        height: auto !important;
        overflow: visible !important;
        margin: 0 !important;
        padding: 0 !important;
        display: block !important;
        position: static !important;
        --bg-body: #fff;
        --text-main: #000;
      }

      .h-screen { height: auto !important; }
      .overflow-hidden, .overflow-y-auto { overflow: visible !important; }
      .tournament-container-wrapper, .tournament-viewport { height: auto !important; overflow: visible !important; }

      .no-print, header, .resize-handle, .card-header button, .zoom-controls { display: none !important; }
      .print-only { display: block !important; }

      .print-team-name { display: block !important; white-space: pre-line !important; line-height: 1.15 !important; }
      .stat-col { width: 5% !important; }

      .grid, .flex-wrap-container { display: block !important; width: 100% !important; }

      .print-page-wrapper {
        width: 100%;
        display: block;
        margin: 0;
        padding: 0;
        page-break-after: always;
        break-after: page;
        page-break-inside: avoid;
        break-inside: avoid;
      }
      .print-page-wrapper:last-child { page-break-after: auto; break-after: auto; }

      .resizable-card {
        width: 100% !important;
        height: auto !important;
        border: 2px solid #000 !important;
        background: #fff !important;
        box-shadow: none !important;
        margin: 0 !important;
        border-radius: 0 !important;
        color: #000 !important;
        overflow: visible !important;
        display: flex !important;
        flex-direction: column !important;
        page-break-inside: avoid;
        break-inside: avoid;
      }
      .resizable-card > div:nth-child(1) { flex: 0 0 auto !important; }
      .resizable-card > div:nth-child(2) { flex: 1 1 auto !important; padding: 6px 8px !important; }

      .card-header h3 { color: black !important; font-size: 16px; text-align: center; width: 100%; }
      .card-header { border-bottom: 2px solid #000 !important; padding: 5px !important; }

      .modern-table { page-break-inside: avoid; break-inside: avoid; }
      .modern-table tr { page-break-inside: avoid; break-inside: avoid; }
      .modern-table th {
        background-color: #eee !important;
        color: #000 !important;
        border: 1px solid #000 !important;
        padding: 6px 6px !important;
        font-size: 11px !important;
      }
      .modern-table td {
        border: 1px solid #000 !important;
        color: #000 !important;
        background-color: #fff !important;
        padding: 4px 6px !important;
        height: 36px !important;
        font-size: 11px !important;
      }
      .modern-table td.member-cell { background-color: #eee !important; }
      .highlight-header { background-color: #eee !important; color: #000 !important; }

      .diagonal-cell {
        background-color: #eee !important;
        background-image: linear-gradient(to bottom left, transparent calc(50% - 1px), #000 calc(50% - 1px), #000 calc(50% + 1px), transparent calc(50% + 1px)) !important;
      }

      input::placeholder { color: transparent !important; }
      input { border: none !important; background: transparent !important; color: #000 !important; font-weight: bold; }

      .print-schedule {
        display: block !important;
        margin-top: 6px !important;
        border-top: 2px solid #000;
        padding: 5px 10px !important;
        font-size: 11px;
        line-height: 1.4;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        background-color: #fff !important;
        color: #000 !important;
        width: 100%;
        page-break-inside: avoid;
        break-inside: avoid;
      }

      body.printing-single .print-page-wrapper { display: none !important; }
      body.printing-single .print-page-wrapper.target-print { display: block !important; }

      .print-highlight td { background-color: #e2e8f0 !important; font-weight: bold; }
      .print-highlight input { font-weight: 800; }
    }

    /* Toast */
    .pp-toast {
      position: fixed;
      left: 50%;
      bottom: 24px;
      transform: translateX(-50%);
      z-index: 10000;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid var(--table-border);
      background: var(--card-bg);
      color: var(--text-main);
      box-shadow: 0 10px 24px -16px rgba(0,0,0,0.6);
      font-size: 12px;
      opacity: 0;
      transition: opacity 180ms ease, transform 180ms ease;
      pointer-events: none;
    }
    .pp-toast.show { opacity: 1; transform: translateX(-50%) translateY(-4px); }
    
    /* ==========================================================
       [V2 스타일 적용] 심플 & 슬림 오버라이드
       ========================================================== */
    :root {
      /* 연결선 색상: 얇은 회색 */
      --tournament-line: #94a3b8; 
      --tournament-line-active: #475569;
      
      /* 카드 크기: 작고 컴팩트하게 고정 */
      --dynamic-card-width: 160px; 
    }

    /* 1. 매치 카드 공통 스타일 (박스) */
    .match-card {
      background-color: #ffffff !important;
      border: 1px solid #cbd5e1 !important; /* 연한 회색 테두리 */
      border-radius: 2px !important;        /* 거의 직각 */
      box-shadow: 0 1px 2px rgba(0,0,0,0.05) !important; /* 아주 약한 그림자 */
      padding: 0 !important;
      min-height: 46px !important;          /* 높이 줄임 */
      width: var(--dynamic-card-width) !important;
      position: relative;
      z-index: 10; /* 선보다 위에 표시 */
    }
    
    /* 다크모드 대응 */
    body:not(.light-mode) .match-card {
      background-color: #1e293b !important;
      border-color: #334155 !important;
    }

    /* 팀명 텍스트 박스 */
    .match-card > div {
      height: 23px; /* 46px의 절반 */
      padding: 0 6px;
      display: flex;
      align-items: center;
      font-size: 11px;
      font-weight: 500;
      color: var(--text-main);
    }

    /* 팀명 사이 구분선 */
    .match-card > div:first-child {
      border-bottom: 1px solid #e2e8f0 !important;
    }
    body:not(.light-mode) .match-card > div:first-child {
      border-bottom-color: #334155 !important;
    }

    /* 승자 강조 */
    .bg-slate-100 { background-color: #f1f5f9 !important; }
    body:not(.light-mode) .bg-slate-100 { background-color: #334155 !important; }
    .text-black { color: #000 !important; font-weight: 800 !important; }
    body:not(.light-mode) .text-black { color: #fff !important; }

    /* 2. 연결선 (Bracket Lines) 스타일 */
    .connector-line {
      position: absolute;
      background-color: var(--tournament-line);
      z-index: 0; /* 카드 뒤로 */
    }
    
    /* [수정] Setup Modal의 버튼 스타일 (배경/글자색 테마 연동 및 폰트 확대) */
    .setup-slot-btn {
        width: 100%;
        height: 28px;              /* [Req 4] 높이 약간 확대 */
        font-size: 14px;           /* [Req 4] 폰트 크기 확대 (기존 11px) */
        border: 1px solid var(--text-main);
        background: var(--btn-bg); /* [Req 3] 테마 변수 사용 (다크모드 자동 대응) */
        color: var(--text-main);             /* [Req 3] 테마 변수 사용 */
        padding: 0 6px;
        text-align: left;
        border-radius: 4px;
        margin-bottom: 2px;
        display: flex;
        align-items: center;
        transition: background 0.2s, color 0.2s;
    }
/* 위쪽 버튼 (Team A) 스타일: 아래 테두리 제거, 위쪽 둥글게 */
.setup-slot-btn:first-child {
    border-bottom: none;
    border-radius: 4px 4px 0 0;
    margin-bottom: 0;
}

/* 아래쪽 버튼 (Team B) 스타일: 아래쪽 둥글게 */
.setup-slot-btn:last-child {
    border-top: 1px dashed var(--text-main);
    border-radius: 0 0 4px 4px;
    margin-bottom: 0;
}
    .setup-slot-btn:hover {
        background: var(--btn-secondary-bg-hover); /* 호버 시 색상도 테마 연동 */
        color: var(--btn-secondary-text-hover);
    }
    body:not(.light-mode) .setup-slot-btn {
        background: #1e293b;
        border-color: #475569;
        color: #e2e8f0;
    }
    
    .bracket-column {
      display: flex;
      flex-direction: column;
      /* justify-content: space-around;  <-- 기존: 여백 기반 분배 (제거) */
      justify-content: center;        /* 변경: 중앙 정렬 */
      padding: 0 20px;
      flex: 1;
      height: 100%;                   /* [추가] 부모 높이를 꽉 채움 */
    }

    .match-node {
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      margin: 10px 0;  /*<-- 기존: 고정 마진 (제거) */
      /* margin: 0;          /* 변경: 마진 제거 */
      flex: 1;            /* [추가] 중요! 가용 높이를 N등분하여 정확한 슬롯 점유 */
      width: 100%;        /* [추가] 가로폭 확보 */
    }

/* 연결선 (커넥터) */
.connector {
  position: absolute;
  background-color: var(--tournament-line);
  z-index: 0;
  transition: background-color 0.3s;
}
.connector.active {
  background-color: var(--tournament-winner) !important; /* 색상은 유지 */
  box-shadow: none !important;       /* [핵심] 번짐(그림자) 효과 제거 */
  z-index: 5;                        /* [추가] 활성화된 선을 맨 위로 올려 끊김 없이 선명하게 표시 */
}

/* 팀 슬롯 카드 */
.team-slot {
  width: var(--dynamic-card-width);
  height: 32px;
  display: flex;
  align-items: center;
  padding: 0 10px;
  background: var(--card-bg);
  border: 1px solid var(--table-border);
  cursor: pointer;
  font-size: 14px; /* 글자 크기 키움 */
  font-weight: 600; /* 두께감 추가 */
  position: relative;
  z-index: 10;
  transition: all 0.2s;
}
.team-slot:first-child { border-bottom: none; border-radius: 4px 4px 0 0; }
.team-slot:last-child { border-radius: 0 0 4px 4px; }
.team-slot:hover:not(.disabled) { background-color: var(--table-row-hover-bg); border-color: var(--accent); }

/* 상태별 스타일 */
.team-slot.winner {
      background-color: var(--tournament-winner-bg2);
      color: var(--tournament-winner);
      font-weight: bold;
      border-color: var(--tournament-winner);
}
.team-slot:last-child.winner {
  border-top-color: var(--table-border);
}
.team-slot.loser { opacity: 0.5; }
.team-slot.bye { color: var(--text-muted); font-style: italic; cursor: default; }

/* [요구사항 2] 결승전 'ㅗ' 형태 연결선 스타일 */
.final-connector-stem {
  position: absolute;
  bottom: -20px; /* 카드 하단으로 내림 */
  left: 50%;
  width: 1px;
  height: 20px;
  background-color: var(--tournament-line);
  transform: translateX(-50%);
  z-index: 0;
}

.final-connector-bar {
  position: absolute;
  bottom: -20px; /* 줄기 끝부분에 위치 */
  left: -40px;   /* 좌우로 뻗어나가는 길이 */
  right: -40px;
  height: 1px;
  background-color: var(--tournament-line);
  z-index: 0;
}
    /* ==========================================================
       [추가] 모바일/반응형 대응 미디어 쿼리
       ========================================================== */
    @media (max-width: 768px) {
      /* 1. 헤더 높이 자동 조절 및 패딩 축소 */
      header .h-16, header .h-14 { height: auto !important; min-height: 56px; padding-top: 8px; padding-bottom: 8px; }
      header .max-w-\[98\%\] { max-width: 100% !important; padding-left: 10px; padding-right: 10px; flex-wrap: wrap; gap: 8px; }
      
      /* 2. 브랜드 로고 및 타이틀 크기 축소 */
      .brand-title { font-size: 1rem !important; }
      .brand-logo { width: 32px !important; height: 32px !important; }
      
      /* 3. 버튼 텍스트 숨기기 (아이콘만 표시) */
      .btn-base span:not(.tag), .btn-base .hidden.xl\:inline { display: none !important; }
      .btn-base { padding: 6px 8px !important; font-size: 12px !important; }

      /* 4. 탭 메뉴 가로 스크롤 허용 (줄바꿈 방지) */
      header .flex.mr-4 { overflow-x: auto; white-space: nowrap; max-width: 100%; margin-right: 0 !important; padding-bottom: 4px; }
      .tab-btn { padding: 8px 12px !important; font-size: 12px !important; }

      /* 5. 토너먼트/리그 툴바가 헤더 아래로 자연스럽게 흐르도록 설정 */
      header > div:nth-child(2) { flex-direction: column; align-items: flex-start; gap: 8px; height: auto !important; }
      header > div:nth-child(2) > div:last-child { width: 100%; justify-content: space-between; margin-top: 4px; }
      
      /* 6. 모달 및 카드 크기 모바일 최적화 */
      .resizable-card { width: 100% !important; height: auto !important; margin-bottom: 16px; }
      .modal-content { width: 95% !important; padding: 12px !important; }
      .popover-container { width: 200px !important; left: 50% !important; transform: translateX(-50%) !important; }
      
      /* 7. 줌 컨트롤 위치 조정 */
      .zoom-controls { bottom: 80px !important; right: 10px !important; }
    }
  </style>
</head>

<body class="light-mode">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useLayoutEffect, useMemo, useRef } = React;
    
    // ==========================================================
    // [NEW] V2 토너먼트 알고리즘 (지능형 시드 배정)
    // ==========================================================
    const nextPow2 = (n) => {
      let p = 1; while(p < n) p <<= 1; return p;
    };

    // 시드 배치 순서 계산 (1 vs 32, 2 vs 31 ...)
    const getSeedPlacementOrder = (size) => {
      if(size === 2) return [1, 2];
      const prev = getSeedPlacementOrder(size / 2);
      const out = [];
      for(let i=0; i<prev.length; i++){
        const s = prev[i];
        let pair = [s, size + 1 - s];
        // 홀수 인덱스(짝수 번째 페어)는 순서를 뒤집음 (표준 대진표 패턴)
        if(i % 2 === 1) pair.reverse();
        out.push(...pair);
      }
      return out;
    };

    // 참가자 분배 로직 (같은 조 회피 + 4분면 분산)
    const distributeEntrantsV2 = (entrants, M, placement) => {
      const seedToVisual = new Array(M + 1);
      for (let i = 0; i < M; i++) seedToVisual[placement[i]] = i;

      const quadrantSize = M / 4;
      const quadrantGroups = [new Set(), new Set(), new Set(), new Set()];
      
      // 결과 저장용 (Visual Index -> Team Object)
      const visualSlots = new Array(M).fill(null);
      
      let available = [...entrants]; // 대기 중인 팀들
      
      // 시드 1번부터 N번까지 순서대로 배정
      const N = entrants.length;
      
      // 시드별 배정된 팀의 Group ID를 추적 (1라운드 상대 확인용)
      const seedToGroupMap = new Map();

      for (let seed = 1; seed <= N; seed++) {
        const visualIdx = seedToVisual[seed];
        const qIdx = Math.floor(visualIdx / quadrantSize);
        
        // 내 상대(1라운드) 시드 번호
        const opponentSeed = (M + 1) - seed;
        const opponentGroup = seedToGroupMap.get(opponentSeed); // 상대가 이미 배정되었다면 그 조 ID

        let pickIndex = -1;

        // [조건 1] 1~4번 시드는 순서대로 고정 (강제 배정)
        if (seed <= 4) {
          pickIndex = 0;
        } else {
          // [조건 2] 대기열을 순회하며 조건에 맞는 팀 탐색
          for (let i = 0; i < available.length; i++) {
            const candidate = available[i];
            const cGroup = candidate.team.groupId; // 팀 객체에서 조 ID 추출

            // A. 1라운드 상대와 같은 조인가? (절대 회피)
            if (opponentGroup !== undefined && cGroup === opponentGroup) continue;

            // B. 현재 4분면에 같은 조가 있는가? (분산 배치)
            if (quadrantGroups[qIdx].has(cGroup)) continue;

            pickIndex = i;
            break;
          }
          // [Fallback] 조건에 맞는 팀이 없으면 대기열 1순위 강제 배정
          if (pickIndex === -1) pickIndex = 0;
        }

        // 배정 실행
        const picked = available[pickIndex];
        visualSlots[visualIdx] = picked; // 슬롯에 팀 할당
        seedToGroupMap.set(seed, picked.team.groupId);
        
        // 4분면 정보 업데이트
        quadrantGroups[qIdx].add(picked.team.groupId);
        
        // 대기열 제거
        available.splice(pickIndex, 1);
      }
      
      return visualSlots;
    };
    // ----------------------------------------------------------
    // Toast helper (safe default)
    // ----------------------------------------------------------
    const toast = (msg) => {
      try {
        let el = document.getElementById('pp-toast');
        if (!el) {
          el = document.createElement('div');
          el.id = 'pp-toast';
          el.className = 'pp-toast';
          document.body.appendChild(el);
        }
        el.textContent = String(msg ?? '');
        el.classList.add('show');
        clearTimeout(el._t1);
        clearTimeout(el._t2);
        el._t1 = setTimeout(() => el.classList.remove('show'), 1800);
        el._t2 = setTimeout(() => { /* keep node for reuse */ }, 2200);
      } catch (_) {}
    };

    // Icons
    const Icon = ({ path, size = 18, className = "" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size}
        viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"
        strokeLinecap="round" strokeLinejoin="round" className={className}>
        {path}
      </svg>
    );

    const Icons = {
      Plus: (p) => <Icon {...p} path={<><path d="M5 12h14"/><path d="M12 5v14"/></>} />,
      Trash: (p) => <Icon {...p} path={<><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-1 1-1h6c0 0 1 0 1 1v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></>} />,
      Save: (p) => <Icon {...p} path={<><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></>} />,
      Upload: (p) => <Icon {...p} path={<><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></>} />,
      Trophy: (p) => <Icon {...p} path={<><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></>} />,
      Users: (p) => <Icon {...p} path={<><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></>} />,
      List: (p) => <Icon {...p} path={<><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></>} />,
      Settings: (p) => <Icon {...p} path={<><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></>} />,
      ChevronRight: (p) => <Icon {...p} path={<polyline points="9 18 15 12 9 6"/>} />,
      ChevronDown: (p) => <Icon {...p} path={<polyline points="6 9 12 15 18 9"/>} />,
      Wand: (p) => <Icon {...p} path={<><path d="M15 4V2"/><path d="M15 16v-2"/><path d="M8 9h2"/><path d="M20 9h2"/><path d="M17.8 11.8 19 13"/><path d="M15 9h0"/><path d="M17.8 6.2 19 5"/><path d="M3 21l9-9"/><path d="M12.2 6.2 11 5"/></>} />,
      Edit: (p) => <Icon {...p} path={<path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/>} />,
      Check: (p) => <Icon {...p} path={<polyline points="20 6 9 17 4 12"/>} />,
      X: (p) => <Icon {...p} path={<><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></>} />,
      Lock: (p) => <Icon {...p} path={<><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></>} />,
      Unlock: (p) => <Icon {...p} path={<><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 9.9-1"/></>} />,
      SortAsc: (p) => <Icon {...p} path={<><path d="M11 5h10"/><path d="M11 9h7"/><path d="M11 13h4"/><path d="M3 17l3 3 3-3"/><path d="M6 18V4"/></>} />,
      SortDesc: (p) => <Icon {...p} path={<><path d="M11 5h10"/><path d="M11 9h7"/><path d="M11 13h4"/><path d="M3 5l3-3 3 3"/><path d="M6 18V4"/></>} />,
      SortGroup: (p) => <Icon {...p} path={<><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></>} />,
      Printer: (p) => <Icon {...p} path={<><polyline points="6 9 6 2 18 2 18 9"/><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/><rect x="6" y="14" width="12" height="8"/></>} />,
      ZoomIn: (p) => <Icon {...p} path={<><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></>} />,
      ZoomOut: (p) => <Icon {...p} path={<><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/></>} />,
      Refresh: (p) => <Icon {...p} path={<><path d="M23 4v6h-6"/><path d="M1 20v-6h6"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></>} />,
      Swap: (p) => <Icon {...p} path={<><path d="M7 16V4M7 4L3 8M7 4L11 8"/><path d="M17 8V20M17 20L21 16M17 20L13 16"/></>} />,
      ExternalLink: (p) => <Icon {...p} path={<><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></>} />,
      Move: (p) => <Icon {...p} path={<><polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="19 9 22 12 19 15"/><polyline points="9 19 12 22 15 19"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="12" y1="2" x2="12" y2="22"/></>} />,
      Sun: (p) => <Icon {...p} path={<><circle cx="12" cy="12" r="5"/><path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/></>} />,
      Moon: (p) => <Icon {...p} path={<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>} />,
    };

    // UI primitives
    const Card = ({ children, className = "" }) => <div className={`resizable-card p-6 ${className}`}>{children}</div>;

    const Button = ({ onClick, children, variant = "primary", className = "", disabled=false, title="" }) => {
      const baseStyle = "px-4 py-2 rounded-lg font-medium transition-all duration-200 flex items-center justify-center gap-2 cursor-pointer active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed no-print btn-base";
      const variants = { primary: "btn-primary", secondary: "btn-secondary", danger: "btn-danger", magic: "btn-magic", ghost: "btn-ghost" };
      return <button onClick={onClick} disabled={disabled} title={title} className={`${baseStyle} ${variants[variant]} ${className}`}>{children}</button>;
    };

    const Input = (props) => (
      <input {...props}
        className={`w-full px-3 py-2 rounded-lg focus:outline-none transition-all placeholder-slate-600 ${props.className || ''}`}
        style={{ backgroundColor: 'var(--input-bg)', color: 'var(--text-main)', border: `1px solid var(--table-border)` }}
      />
    );

    const Toggle = ({ label, checked, onChange }) => (
      <div className="flex items-center justify-between py-2 no-print">
        <span className="text-sm font-medium" style={{color:'var(--text-muted)'}}>{label}</span>
        <label className="relative inline-flex items-center cursor-pointer">
          <input type="checkbox" className="sr-only peer toggle-checkbox" checked={checked} onChange={onChange} />
          <div className="w-11 h-6 peer-focus:outline-none rounded-full peer toggle-label after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all"></div>
        </label>
      </div>
    );

    const ResizableCard = ({ id, width, height, onResize, className = "", children }) => {
      const handleResize = (e) => {
        e.preventDefault(); e.stopPropagation();
        const startX = e.clientX, startY = e.clientY;
        const startW = width, startH = typeof height === 'number' ? height : e.target.parentElement.offsetHeight;
        const onMouseMove = (me) => onResize(id, Math.max(350, startW + me.clientX - startX), Math.max(250, startH + me.clientY - startY));
        const onMouseUp = () => { document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); };
        document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp);
      };
      return (
        <div className={`resizable-card ${className}`} style={{ width, height: height === 'auto' ? 'auto' : height }}>
          <div className="flex-none px-4 py-3 card-header flex justify-between items-center">{children[0]}</div>
          <div className="flex-grow relative flex flex-col">{children[1]}</div>
          <div className="resize-handle no-print" onMouseDown={handleResize}></div>
        </div>
      );
    };

    // ----------------------------------------------------------
    // Schedule presets
    // ----------------------------------------------------------
    const FIXED_MATCH_ORDER = {
      2: [[1,2]],
      3: [[2,3], [1,3], [1,2]],
      4: [[1,4], [2,3], [1,3], [4,2], [1,2], [3,4]],
      5: [[2,5], [3,4], [1,5], [2,3], [1,4], [5,3], [1,3], [4,2], [1,2], [4,5]],
      6: [[1,6], [2,5], [3,4], [1,5], [6,4], [2,3], [1,4], [5,3], [6,2], [1,3], [4,2], [5,6], [1,2], [3,6], [4,5]],
      7: [[2,7], [3,6], [4,5], [1,7], [2,5], [3,4], [1,6], [7,5], [2,3], [1,5], [6,4], [7,3], [1,4], [5,3], [6,2], [1,3], [4,2], [6,7], [1,2], [4,7], [5,6]],
      8: [[1,8], [2,7], [3,6], [4,5], [1,7], [8,6], [2,5], [3,4], [1,6], [7,5], [8,4], [2,3], [1,5], [6,4], [7,3], [8,2], [1,4], [5,3], [6,2], [7,8], [1,3], [4,2], [5,8], [6,7], [1,2], [3,8], [4,7], [5,6]],
      9: [[2,9], [3,8], [4,7], [5,6], [1,9], [2,7], [3,6], [4,5], [1,8], [9,7], [2,5], [3,4], [1,7], [8,6], [9,5], [2,3], [1,6], [7,5], [8,4], [9,3], [1,5], [6,4], [7,3], [8,2], [1,4], [5,3], [6,2], [8,9], [1,3], [4,2], [6,9], [7,8], [1,2], [4,9], [5,8], [6,7]],
      10: [[1,10], [2,9], [3,8], [4,7], [5,6], [1,9], [10,8], [2,7], [3,6], [4,5], [1,8], [9,7], [10,6], [2,5], [3,4], [1,7], [8,6], [9,5], [10,4], [2,3], [1,6], [7,5], [8,4], [9,3], [10,2], [1,5], [6,4], [7,3], [8,2], [9,10], [1,4], [5,3], [6,2], [7,10], [8,9], [1,3], [4,2], [5,10], [6,9], [7,8], [1,2], [3,10], [4,9], [5,8], [6,7]],
      11: [[2,11], [3,10], [4,9], [5,8], [6,7], [1,11], [2,9], [3,8], [4,7], [5,6], [1,10], [11,9], [2,7], [3,6], [4,5], [1,9], [10,8], [11,7], [2,5], [3,4], [1,8], [9,7], [10,6], [11,5], [2,3], [1,7], [8,6], [9,5], [10,4], [11,3], [1,6], [7,5], [8,4], [9,3], [10,2], [1,5], [6,4], [7,3], [8,2], [10,11], [1,4], [5,3], [6,2], [8,11], [9,10], [1,3], [4,2], [6,11], [7,10], [8,9], [1,2], [4,11], [5,10], [6,9], [7,8]],
      12: [[1,12], [2,11], [3,10], [4,9], [5,8], [6,7], [1,11], [12,10], [2,9], [3,8], [4,7], [5,6], [1,10], [11,9], [12,8], [2,7], [3,6], [4,5], [1,9], [10,8], [11,7], [12,6], [2,5], [3,4], [1,8], [9,7], [10,6], [11,5], [12,4], [2,3], [1,7], [8,6], [9,5], [10,4], [11,3], [12,2], [1,6], [7,5], [8,4], [9,3], [10,2], [11,12], [1,5], [6,4], [7,3], [8,2], [9,12], [10,11], [1,4], [5,3], [6,2], [7,12], [8,11], [9,10], [1,3], [4,2], [5,12], [6,11], [7,10], [8,9], [1,2], [3,12], [4,11], [5,10], [6,9], [7,8]]
    };

    const NAMES = ['김철수', '이영희', '박민수', '김민준', '김서연', '김도윤', '김하은', '이준호', '이지아', '박지훈', '박수빈', '최예준', '최지우', '정현우', '정채원', '강태현', '강지민', '조승우', '조하린', '윤재현', '윤서아', '장우진', '장다은', '임시우', '임유나', '한성민', '한예린', '오지후', '오서현', '서도현', '서윤지', '신민재', '신가은', '권준서', '권나연', '황도경', '황소연', '안재훈', '안하율', '송현준', '송은채', '류지환', '류채린', '홍진우', '홍아윤', '고은우', '고지윤', '문태윤', '문서진', '양준혁', '양예원', '손민수', '손다현', '배성준', '배서영', '백지호', '백하린', '남궁민', '노현석', '노지은', '나유준', '나채은', '전준영', '전소민', '하준우', '하은서', '성민호', '성예지', '손우성', '손지안', '유태준', '유하늘', '라준혁', '라세윤', '심건우', '심채영', '변준희', '변서윤', '우지훈', '우하진', '주민규', '주예슬', '채민석', '채서린', '표진호', '표다인', '탁성현', '탁예나', '허준혁', '허지수', '진도현', '진예린', '공민재', '공서연', '신은호', '신다솔', '강민서', '강유진', '박현서', '박라희', '이채원', '최하윤'];
    // [추가] 소속 목록 정의 (NAMES 상수 아래 쯤에 위치)
    const AFFILIATION_LIST = ['이성숙', '김민성', '윤한미', '이태영', '신곡', '회룡', '정하영', '신효섭', '드림', '민락', '마스터', '현대', '개인', '서울', '남양주', '양주', '포천', '참피온', '도봉'];
    const getRandomItem = (arr) => arr[Math.floor(Math.random() * arr.length)];

// ----------------------------------------------------------
// [수정완료] MatchBox : V2 스타일 연결선 포함
// ----------------------------------------------------------
const MatchBox = React.memo(({ match, idx, bracketIdx, roundIdx, isRight = false, isFinal = false, noVertical = false, isJointWinner = false, onWin }) => {
  // 승자 판별
  const isWinnerA = isJointWinner ? !!match.teamA : (match.winner && match.teamA && match.winner.id === match.teamA.id);
  const isWinnerB = isJointWinner ? !!match.teamB : (match.winner && match.teamB && match.winner.id === match.teamB.id);

  // 짝수 인덱스(0, 2, 4...)는 위쪽 노드, 홀수는 아래쪽 노드
  const isEven = idx % 2 === 0;
  
  // 연결선 길이 설정
  const LINE_LENGTH = '20px'; 

  return (
    <div className="match-wrapper" style={{ padding: '4px 0', display: 'flex', flexDirection: 'column', justifyContent: 'center', flex: 1, position: 'relative' }}>
      
      {/* ================= 연결선 그리기 (Final이 아니고, 수직선이 필요한 경우) ================= */}
      {!isFinal && !noVertical && (
        <>
          {/* 1. 가로선 (카드에서 나가는 선) */}
          <div className="connector-line" style={{
              height: '1px',
              width: LINE_LENGTH,
              top: '50%',
              [isRight ? 'left' : 'right']: `-${LINE_LENGTH}`
          }} />

          {/* 2. 세로선 (형제 노드와 연결되는 선) */}
          <div className="connector-line" style={{
              width: '1px',
              // 짝수(위): 내 중심(50%)에서 아래로 50% + 갭 보정
              // 홀수(아래): 내 중심(50%)에서 위로 50% + 갭 보정
              top: isEven ? '50%' : 'auto',
              bottom: isEven ? 'auto' : '50%',
              height: 'calc(50% + 2px)', // 2px는 오차 보정
              [isRight ? 'left' : 'right']: `-${LINE_LENGTH}`
          }} />
        </>
      )}

      {/* ================= 매치 카드 (Team A & B) ================= */}
      <div className="match-card flex flex-col justify-center w-full relative overflow-hidden">
        {/* Team A */}
        <div 
          onClick={(e) => {
            e.stopPropagation(); 
            if (match.teamA && !match.teamA.isBye) onWin(bracketIdx, roundIdx, idx, match.teamA);
          }}
          className={`cursor-pointer ${isWinnerA ? 'bg-slate-100' : ''}`}
          title={match.teamA?.name}
        >
          <span className={`truncate w-full ${isWinnerA ? 'text-black' : ''} ${!match.teamA ? 'opacity-30' : ''}`}>
            {match.teamA ? match.teamA.name : 'TBD'}
          </span>
        </div>
        
        {/* Team B */}
        <div 
          onClick={(e) => {
            e.stopPropagation(); 
            if (match.teamB && !match.teamB.isBye) onWin(bracketIdx, roundIdx, idx, match.teamB);
          }}
          className={`cursor-pointer ${isWinnerB ? 'bg-slate-100' : ''}`}
          title={match.teamB?.name}
        >
          <span className={`truncate w-full ${isWinnerB ? 'text-black' : ''} ${!match.teamB ? 'opacity-30' : ''}`}>
            {match.teamB ? match.teamB.name : 'TBD'}
          </span>
        </div>
      </div>
    </div>
  );
});

    // ----------------------------------------------------------
    // THEME MANAGER — Full control (모든 변수/문자열 내 색상 토큰 지원)
    // ----------------------------------------------------------
    const THEME_STORAGE_KEY = 'league_theme_overrides_v2';
    const THEME_FILE_NAME = 'league_theme_overrides.json';

    const THEME_KEYS = [
      // Base
      "bg-body","text-main","text-muted","card-bg","card-border",
      "table-header-bg","table-border","table-cell-border",
      "input-bg","input-focus","highlight-bg",
      "diagonal-bg","diagonal-line",
      "select-bg","select-text",

      // Brand / header / tabs
      "brand-logo-grad-from","brand-logo-grad-to","brand-logo-text",
      "brand-title-grad-from","brand-title-grad-to",
      "divider",
      "tab-active-border","tab-active-text","tab-active-bg","tab-inactive-text","tab-inactive-hover-text",

      // Accent + buttons
      "accent","accent-strong","accent-2",
      "btn-primary-bg","btn-primary-shadow",
      "btn-secondary-bg","btn-secondary-bg-hover","btn-secondary-border","btn-secondary-text","btn-secondary-text-hover",
      "btn-danger-bg","btn-danger-bg-hover","btn-danger-border","btn-danger-text",
      "btn-ghost-bg-hover","btn-ghost-text","btn-ghost-text-hover",
      "tag-bg","tag-border","tag-text",
      "toggle-bg","toggle-bg-checked",

      // Group table
      "matrix-input-text","matrix-focus-ring","highlight-active-bg","highlight-mirror-bg","highlight-header-text","highlight-header-bg","resize-handle-accent",

      // Lists / rank / states
      "table-row-hover-bg","table-row-editing-bg","team-level-text","qualified-row-bg",
      "rank-btn-bg","rank-btn-bg-hover","rank-btn-border","rank-btn-text",

      // Modal
      "modal-overlay-bg","warning-bg","warning-text","warning-border","swap-item-hover-bg","swap-item-hover-border","swap-item-hover-shadow",

      // Tournament
      "tournament-line","tournament-line-active","tournament-card-hover-border",
      "tournament-team-hover-text","tournament-team-hover-bg",
      "tournament-winner","tournament-winner-shadow","tournament-winner-glow","tournament-winner-bg2",
      "final-title-text","final-title-shadow",
      "champion-grad-from","champion-grad-mid","champion-grad-to","champion-text","champion-subtext","champion-ring","champion-shadow",
      "trophy-placeholder-bg","trophy-placeholder-border","trophy-placeholder-icon",

      // Tournament controls
      "control-pill-bg","control-pill-border","control-icon","control-icon-hover","control-hover-bg","control-divider","control-helper-text",
    ];

    const THEME_CATEGORIES = [
      { id: "brand", label: "브랜드/상단", keys: ["brand-logo-grad-from","brand-logo-grad-to","brand-logo-text","brand-title-grad-from","brand-title-grad-to","divider"] },
      { id: "tabs", label: "상단 탭", keys: ["tab-active-border","tab-active-text","tab-active-bg","tab-inactive-text","tab-inactive-hover-text"] },
      { id: "base", label: "기본/레이아웃", keys: ["bg-body","text-main","text-muted","card-bg","card-border","highlight-bg","input-bg","input-focus","select-bg","select-text"] },
      { id: "tables", label: "표/리스트", keys: ["table-header-bg","table-border","table-cell-border","table-row-hover-bg","table-row-editing-bg","team-level-text","qualified-row-bg"] },
      { id: "buttons", label: "버튼/컨트롤", keys: ["accent","accent-strong","accent-2","btn-primary-bg","btn-primary-shadow","btn-secondary-bg","btn-secondary-bg-hover","btn-secondary-border","btn-secondary-text","btn-secondary-text-hover","btn-danger-bg","btn-danger-bg-hover","btn-danger-border","btn-danger-text","btn-ghost-bg-hover","btn-ghost-text","btn-ghost-text-hover","tag-bg","tag-border","tag-text","toggle-bg","toggle-bg-checked","rank-btn-bg","rank-btn-bg-hover","rank-btn-border","rank-btn-text"] },
      { id: "groups", label: "조별 결과(매트릭스)", keys: ["diagonal-bg","diagonal-line","matrix-input-text","matrix-focus-ring","highlight-active-bg","highlight-mirror-bg","highlight-header-text","highlight-header-bg","resize-handle-accent"] },
      { id: "modal", label: "모달/오버레이", keys: ["modal-overlay-bg","warning-bg","warning-text","warning-border","swap-item-hover-bg","swap-item-hover-border","swap-item-hover-shadow"] },
      { id: "tournament", label: "토너먼트", keys: ["tournament-line","tournament-line-active","tournament-card-hover-border","tournament-team-hover-text","tournament-team-hover-bg","tournament-winner","tournament-winner-shadow","tournament-winner-glow","tournament-winner-bg2","final-title-text","final-title-shadow","champion-grad-from","champion-grad-mid","champion-grad-to","champion-text","champion-subtext","champion-ring","champion-shadow","trophy-placeholder-bg","trophy-placeholder-border","trophy-placeholder-icon"] },
      { id: "tcontrols", label: "토너먼트 툴바", keys: ["control-pill-bg","control-pill-border","control-icon","control-icon-hover","control-hover-bg","control-divider","control-helper-text"] },
    ];

    const THEME_META = {
      // Base
      "bg-body": { label: "페이지 배경", desc: "앱 전체 배경(메인 캔버스/여백 포함)" },
      "text-main": { label: "기본 텍스트", desc: "본문/제목 등 주요 텍스트 색" },
      "text-muted": { label: "보조 텍스트", desc: "설명/보조 정보/비활성 텍스트 색" },
      "card-bg": { label: "카드 배경", desc: "카드(패널) 배경(반투명 가능)" },
      "card-border": { label: "카드 테두리", desc: "카드 외곽 테두리 색" },
      "highlight-bg": { label: "강조 배경", desc: "선택/모달/강조 영역 기본 배경" },
      "input-bg": { label: "입력 배경", desc: "Input 기본 배경" },
      "input-focus": { label: "입력 포커스 배경", desc: "Input 포커스 시 배경" },
      "select-bg": { label: "드롭다운 배경", desc: "Select(옵션 포함) 배경" },
      "select-text": { label: "드롭다운 텍스트", desc: "Select(옵션 포함) 글자색" },

      // Tables
      "table-header-bg": { label: "테이블 헤더 배경", desc: "표 헤더(TH) 배경" },
      "table-border": { label: "테이블 테두리/구분선", desc: "표 외곽/컴포넌트 기본 보더" },
      "table-cell-border": { label: "테이블 셀 구분선", desc: "표 행/열 내부 구분선" },
      "table-row-hover-bg": { label: "리스트 Hover 배경", desc: "팀 목록 등 행 Hover 배경" },
      "table-row-editing-bg": { label: "리스트 편집중 배경", desc: "팀 편집 중(선택 행) 배경" },
      "team-level-text": { label: "합부수 강조 텍스트", desc: "팀 합부수(강조 숫자) 텍스트 색" },
      "qualified-row-bg": { label: "본선 대상 행 배경", desc: "상위부/본선 진출 표시 행 배경" },

      // Brand / Tabs
      "brand-logo-grad-from": { label: "상단 로고 그라데이션(시작)", desc: "좌측 P 로고 배경 그라데이션 시작색" },
      "brand-logo-grad-to": { label: "상단 로고 그라데이션(끝)", desc: "좌측 P 로고 배경 그라데이션 끝색" },
      "brand-logo-text": { label: "상단 로고 텍스트", desc: "좌측 P 로고 글자색" },
      "brand-title-grad-from": { label: "상단 제목 그라데이션(시작)", desc: "Table Tennis League Manager 텍스트 그라데이션 시작" },
      "brand-title-grad-to": { label: "상단 제목 그라데이션(끝)", desc: "Table Tennis League Manager 텍스트 그라데이션 끝" },
      "divider": { label: "구분선(디바이더)", desc: "헤더/툴바 등 세로 구분선" },

      "tab-active-border": { label: "탭 활성 테두리", desc: "상단 탭 선택 시 하단 보더" },
      "tab-active-text": { label: "탭 활성 텍스트", desc: "상단 탭 선택 시 글자색" },
      "tab-active-bg": { label: "탭 활성 배경", desc: "상단 탭 선택 시 배경" },
      "tab-inactive-text": { label: "탭 비활성 텍스트", desc: "상단 탭 기본(비선택) 글자색" },
      "tab-inactive-hover-text": { label: "탭 Hover 텍스트", desc: "상단 탭 Hover 시 글자색" },

      // Accent + Buttons
      "accent": { label: "포인트(강조) 색", desc: "핵심 강조 색(텍스트/테두리/호버)" },
      "accent-strong": { label: "포인트(진한) 색", desc: "아이콘/헤딩 등에 쓰는 진한 포인트" },
      "accent-2": { label: "보조 포인트", desc: "그라데이션/보조 강조(인디고 계열)" },

      "btn-primary-bg": { label: "주요 버튼 배경", desc: "Primary 버튼 배경(그라데이션 문자열)" },
      "btn-primary-shadow": { label: "주요 버튼 그림자", desc: "Primary 버튼 그림자 색" },

      "btn-secondary-bg": { label: "보조 버튼 배경", desc: "Secondary 버튼 기본 배경" },
      "btn-secondary-bg-hover": { label: "보조 버튼 Hover 배경", desc: "Secondary 버튼 Hover 배경" },
      "btn-secondary-border": { label: "보조 버튼 테두리", desc: "Secondary 버튼 보더" },
      "btn-secondary-text": { label: "보조 버튼 텍스트", desc: "Secondary 버튼 글자색" },
      "btn-secondary-text-hover": { label: "보조 버튼 Hover 텍스트", desc: "Secondary 버튼 Hover 글자색" },

      "btn-danger-bg": { label: "위험 버튼 배경", desc: "Danger 버튼 배경" },
      "btn-danger-bg-hover": { label: "위험 버튼 Hover 배경", desc: "Danger 버튼 Hover 배경" },
      "btn-danger-border": { label: "위험 버튼 테두리", desc: "Danger 버튼 보더" },
      "btn-danger-text": { label: "위험 버튼 텍스트", desc: "Danger 버튼 글자색" },

      "btn-ghost-bg-hover": { label: "고스트 Hover 배경", desc: "Ghost 버튼 Hover 배경" },
      "btn-ghost-text": { label: "고스트 텍스트", desc: "Ghost 버튼 글자색" },
      "btn-ghost-text-hover": { label: "고스트 Hover 텍스트", desc: "Ghost 버튼 Hover 글자색" },

      "tag-bg": { label: "태그/배지 배경", desc: "스왑 모달 등에서 쓰는 배지 배경" },
      "tag-border": { label: "태그/배지 테두리", desc: "배지 보더" },
      "tag-text": { label: "태그/배지 텍스트", desc: "배지 글자색" },

      "toggle-bg": { label: "토글 OFF 배경", desc: "토글 스위치 OFF 배경" },
      "toggle-bg-checked": { label: "토글 ON 배경", desc: "토글 스위치 ON 배경" },

      "rank-btn-bg": { label: "순위 계산 버튼 배경", desc: "각 조의 '순위 계산' 버튼 배경" },
      "rank-btn-bg-hover": { label: "순위 계산 버튼 Hover 배경", desc: "각 조의 '순위 계산' 버튼 Hover 배경" },
      "rank-btn-border": { label: "순위 계산 버튼 테두리", desc: "각 조의 '순위 계산' 버튼 보더" },
      "rank-btn-text": { label: "순위 계산 버튼 텍스트", desc: "각 조의 '순위 계산' 버튼 글자색" },

      // Group matrix
      "diagonal-bg": { label: "대각선 셀 배경", desc: "자기 자신 셀(대각선) 배경" },
      "diagonal-line": { label: "대각선 선 색", desc: "대각선 슬래시(\\) 선 색" },

      "matrix-input-text": { label: "매트릭스 입력 텍스트", desc: "조별 결과 입력(점수) 글자색" },
      "matrix-focus-ring": { label: "매트릭스 포커스 링", desc: "입력 포커스 테두리(링)" },

      "highlight-active-bg": { label: "Hover 강조 배경(강)", desc: "현재 셀(직교) 강조 배경" },
      "highlight-mirror-bg": { label: "Hover 강조 배경(약)", desc: "미러 셀(대칭) 강조 배경" },
      "highlight-header-text": { label: "Hover 헤더 텍스트", desc: "강조된 헤더 텍스트 색" },
      "highlight-header-bg": { label: "Hover 헤더 배경", desc: "강조된 헤더 배경" },
      "resize-handle-accent": { label: "카드 리사이즈 핸들", desc: "우하단 리사이즈 핸들 색" },

      // Modal / overlay
      "modal-overlay-bg": { label: "모달 오버레이", desc: "모달 뒤 배경(딤) 색" },
      "warning-bg": { label: "경고 박스 배경", desc: "스왑 모달 상단 경고 박스 배경" },
      "warning-text": { label: "경고 박스 텍스트", desc: "스왑 모달 상단 경고 박스 글자색" },
      "warning-border": { label: "경고 박스 테두리", desc: "스왑 모달 상단 경고 박스 테두리" },

      "swap-item-hover-bg": { label: "스왑 항목 Hover 배경", desc: "스왑 대상 목록 Hover 배경" },
      "swap-item-hover-border": { label: "스왑 항목 Hover 테두리", desc: "스왑 대상 목록 Hover 테두리" },
      "swap-item-hover-shadow": { label: "스왑 항목 Hover 그림자", desc: "스왑 대상 목록 Hover 그림자" },

      // Tournament
      "tournament-line": { label: "대진 연결선(기본)", desc: "토너먼트 라인 기본 색" },
      "tournament-line-active": { label: "대진 연결선(활성)", desc: "승자 경로 라인 색" },
      "tournament-card-hover-border": { label: "매치 카드 Hover 테두리", desc: "매치 카드 Hover 보더" },
      "tournament-team-hover-text": { label: "팀명 Hover 텍스트", desc: "팀명 Hover 글자색" },
      "tournament-team-hover-bg": { label: "팀명 Hover 배경", desc: "팀명 Hover 배경" },
      "tournament-winner": { label: "승자 강조 색", desc: "승자 텍스트/테두리 색" },
      "tournament-winner-shadow": { label: "승자 텍스트 그림자", desc: "승자 텍스트 글로우(그림자)" },
      "tournament-winner-glow": { label: "승자 카드 글로우", desc: "승자 카드 외곽 글로우" },
      "tournament-winner-bg2": { label: "승자 카드 보조 배경", desc: "승자 카드 그라데이션 두번째 색" },

      "final-title-text": { label: "FINAL 제목 텍스트", desc: "FINAL MATCH 타이틀 텍스트 색" },
      "final-title-shadow": { label: "FINAL 제목 그림자", desc: "FINAL MATCH 타이틀 그림자" },

      "champion-grad-from": { label: "우승 배지 그라데이션(1)", desc: "Champion 배지 그라데이션 첫 색" },
      "champion-grad-mid": { label: "우승 배지 그라데이션(2)", desc: "Champion 배지 그라데이션 중간 색" },
      "champion-grad-to": { label: "우승 배지 그라데이션(3)", desc: "Champion 배지 그라데이션 마지막 색" },
      "champion-text": { label: "우승 배지 메인 텍스트", desc: "🏆 우승자 이름 텍스트" },
      "champion-subtext": { label: "우승 배지 서브 텍스트", desc: "Champion 라벨(작은 글씨)" },
      "champion-ring": { label: "우승 배지 링", desc: "배지 외곽 링(반투명 흰색)" },
      "champion-shadow": { label: "우승 배지 그림자", desc: "배지 전체 글로우/그림자" },

      "trophy-placeholder-bg": { label: "우승 미정 아이콘 배경", desc: "우승자 미정 시 원형 배경" },
      "trophy-placeholder-border": { label: "우승 미정 아이콘 테두리", desc: "우승자 미정 시 원형 테두리" },
      "trophy-placeholder-icon": { label: "우승 미정 아이콘 색", desc: "우승자 미정 트로피 아이콘 색" },

      // Tournament toolbar
      "control-pill-bg": { label: "토너먼트 툴바 배경", desc: "우측 상단 줌/초기화/새창 버튼 패널 배경" },
      "control-pill-border": { label: "토너먼트 툴바 테두리", desc: "우측 상단 툴바 패널 보더" },
      "control-icon": { label: "툴바 아이콘(기본)", desc: "우측 상단 버튼 아이콘 기본 색" },
      "control-icon-hover": { label: "툴바 아이콘(Hover)", desc: "우측 상단 버튼 Hover 아이콘 색" },
      "control-hover-bg": { label: "툴바 버튼 Hover 배경", desc: "우측 상단 버튼 Hover 배경" },
      "control-divider": { label: "툴바 구분선", desc: "우측 상단 툴바 내부 구분선" },
      "control-helper-text": { label: "툴바 안내 텍스트", desc: "Drag 등의 도움말 텍스트" },
    };

    const getThemeLabel = (k) => (THEME_META[k]?.label || k);
    const getThemeDesc = (k) => (THEME_META[k]?.desc || "");

    const clamp = (n, min, max) => Math.min(max, Math.max(min, n));

    const rgbToHex = (r, g, b) => {
      const toHex = (x) => x.toString(16).padStart(2, '0');
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    };

    const hexToRgb = (hex) => {
      const h = (hex || '').trim().replace('#','');
      if (h.length === 3) {
        const r = parseInt(h[0]+h[0], 16);
        const g = parseInt(h[1]+h[1], 16);
        const b = parseInt(h[2]+h[2], 16);
        return { r, g, b, a: 1 };
      }
      if (h.length === 6) {
        const r = parseInt(h.slice(0,2), 16);
        const g = parseInt(h.slice(2,4), 16);
        const b = parseInt(h.slice(4,6), 16);
        return { r, g, b, a: 1 };
      }
      return null;
    };

    const parseRgbLike = (s) => {
      const str = (s || '').trim();
      if (!str) return null;
      if (str.toLowerCase() === 'transparent') return { r: 0, g: 0, b: 0, a: 0 };
      const m = str.match(/rgba?\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)(?:\s*,\s*([0-9]*\.?[0-9]+))?\s*\)/i);
      if (!m) return null;
      const r = clamp(parseInt(m[1], 10), 0, 255);
      const g = clamp(parseInt(m[2], 10), 0, 255);
      const b = clamp(parseInt(m[3], 10), 0, 255);
      const a = m[4] == null ? 1 : clamp(parseFloat(m[4]), 0, 1);
      return { r, g, b, a };
    };

    const formatRgba = (rgba) => {
      const r = clamp(Math.round(rgba.r), 0, 255);
      const g = clamp(Math.round(rgba.g), 0, 255);
      const b = clamp(Math.round(rgba.b), 0, 255);
      const a = clamp(rgba.a ?? 1, 0, 1);
      return `rgba(${r}, ${g}, ${b}, ${a.toFixed(3).replace(/0+$/,'').replace(/\.$/,'')})`;
    };

    const COLOR_TOKEN_RE = /rgba?\(\s*[0-9]+\s*,\s*[0-9]+\s*,\s*[0-9]+(?:\s*,\s*[0-9]*\.?[0-9]+)?\s*\)|#(?:[0-9a-f]{3}|[0-9a-f]{6})\b|\btransparent\b/ig;

    const extractColorTokens = (value) => {
      const v = (value || '');
      COLOR_TOKEN_RE.lastIndex = 0; // ✅ 필수: global regex 상태 초기화
      const out = [];
      let m;
      while ((m = COLOR_TOKEN_RE.exec(v)) !== null) {
        out.push({ start: m.index, end: m.index + m[0].length, token: m[0] });
      }
      return out;
    };

    const tokenToRgba = (token) => {
      const t = (token || '').trim();
      if (!t) return null;
      if (t.toLowerCase() === 'transparent') return { r: 0, g: 0, b: 0, a: 0 };
      if (t.startsWith('#')) return hexToRgb(t);
      return parseRgbLike(t);
    };

    function MultiColorValueEditor({ value, onChange }) {
      const tokens = useMemo(() => extractColorTokens(value), [value]);
      const hasTokens = tokens.length > 0;

      const updateToken = (idx, nextTokenStr) => {
        const t = tokens[idx];
        if (!t) return;
        const updated = value.slice(0, t.start) + nextTokenStr + value.slice(t.end);
        onChange(updated);
      };

      return (
        <div className="flex flex-col gap-2 w-full">
          {hasTokens ? (
            <div className="flex flex-col gap-2">
              {tokens.map((t, idx) => {
                const rgba = tokenToRgba(t.token);
                const hex = rgba ? rgbToHex(rgba.r, rgba.g, rgba.b) : '#000000';
                const alpha = rgba ? clamp(rgba.a ?? 1, 0, 1) : 1;
                const swatch = rgba ? `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${alpha})` : 'transparent';

                const setColor = (nextHex) => {
                  const next = hexToRgb(nextHex);
                  if (!next) return;
                  // Preserve alpha if current token was rgba/transparent or alpha != 1
                  const preferAlpha = /^rgba\(/i.test(t.token) || t.token.toLowerCase()==='transparent' || alpha < 1;
                  const nextStr = preferAlpha ? formatRgba({ ...next, a: alpha }) : rgbToHex(next.r, next.g, next.b);
                  updateToken(idx, nextStr);
                };

                const setAlpha = (nextAlpha01) => {
                  const nextA = clamp(nextAlpha01, 0, 1);
                  if (!rgba) return;
                  updateToken(idx, formatRgba({ ...rgba, a: nextA }));
                };

                return (
                  <div key={idx} className="flex items-center gap-2">
                    <div className="text-[10px] font-bold w-7 text-center rounded border"
                      style={{ borderColor:'var(--table-border)', color:'var(--text-muted)', background:'var(--input-bg)' }}>
                      {idx+1}
                    </div>

                    <div className="w-5 h-5 rounded border" style={{ background: swatch, borderColor: 'var(--table-border)' }} />

                    <input type="color" value={hex} onChange={(e)=>setColor(e.target.value)}
                      className="h-8 w-10 p-0 bg-transparent border rounded"
                      style={{borderColor:'var(--table-border)'}} />

                    <div className="flex items-center gap-2 min-w-[160px]">
                      <span className="text-[11px]" style={{color:'var(--text-muted)'}}>A</span>
                      <input type="range" min="0" max="100" value={Math.round(alpha*100)}
                        onChange={(e)=>setAlpha(parseInt(e.target.value,10)/100)}
                        className="w-28" />
                      <span className="text-[11px] tabular-nums" style={{color:'var(--text-muted)'}}>{Math.round(alpha*100)}%</span>
                    </div>

                    <span className="ml-auto text-[10px] font-mono opacity-70"
                      style={{color:'var(--text-muted)'}} title="편집 중인 토큰">
                      {t.token}
                    </span>
                  </div>
                );
              })}
            </div>
          ) : (
            <div className="text-[11px]" style={{color:'var(--text-muted)'}}>
              이 값은 색상 토큰(#HEX, rgb/rgba, transparent)을 포함하지 않거나 복합 문자열입니다. 아래 텍스트로 직접 편집하세요.
            </div>
          )}

          <input
            className="w-full text-xs px-2 py-1 rounded border"
            style={{ background:'var(--input-bg)', borderColor:'var(--table-border)', color:'var(--text-main)' }}
            value={value || ''}
            onChange={(e)=>onChange(e.target.value)}
            spellCheck={false}
          />
        </div>
      );
    }

// ==========================================================
  // [NEW] Tournament Setup Modal (Tighter Layout + Bigger Boxes + Solid Popover)
  // ==========================================================
  const TournamentSetupModal = ({ isOpen, onClose, config, groups, onConfirm }) => {
    // 윈도우(모달) 상태
    const [win, setWin] = useState(() => ({
      x: 20, 
      y: 20, 
      w: window.innerWidth - 40, 
      h: window.innerHeight - 40 
    }));
    
    // 캔버스 뷰(Zoom/Pan) 상태
    const [view, setView] = useState({ zoom: 1, x: 0, y: 0 });
    const [isPanning, setIsPanning] = useState(false);
    
    // Refs for Dragging
    const winDragRef = useRef({ mode: null, startX: 0, startY: 0, init: {} });
    const panDragRef = useRef({ startX: 0, startY: 0, initX: 0, initY: 0 });
    const popoverDragRef = useRef({ startX: 0, startY: 0, initX: 0, initY: 0 });

    // 데이터 상태
    const [activeTab, setActiveTab] = useState('upper');
    const [slots, setSlots] = useState({ upper: [], lower: [] });
    const [bracketSize, setBracketSize] = useState({ upper: 4, lower: 4 });
    const [qualifiers, setQualifiers] = useState({ upper: [], lower: [] });
    
    // Popover State (slotIdx, x, y)
    const [popover, setPopover] = useState(null); 
    const [hoveredTeamId, setHoveredTeamId] = useState(null); // [추가] 리스트 호버 상태

    // --- 초기화 로직 ---
useEffect(() => {
      if (!isOpen) return;
      
      const upperQ = [], lowerQ = [];
      // 전체 조 중에서 가장 팀이 많은 조의 팀 수(=최대 순위) 계산
      const maxRank = Math.max(...groups.map(g => g.teams.length));

      // 특정 조의 N위 팀을 가져오는 헬퍼 함수
      const getTeamByRank = (gId, rank) => {
        // rank는 1부터 시작하므로 인덱스는 rank-1
        // teams는 이미 정렬되어 있다고 가정하지만 안전을 위해 다시 정렬
        const sorted = [...groups[gId].teams].sort((a,b)=>(a.leagueStats.rank||99)-(b.leagueStats.rank||99));
        return sorted[rank-1];
      };

      // [수정 핵심] 순위별 스네이크 방식 배정 루프
      for (let r = 1; r <= maxRank; r++) {
        
        // 1. 현재 순위(r)가 하위부인지 판단 (스플릿 모드일 때만)
        let isLowerBracket = (config.tournamentMode === 'split' && r > config.topN);

        // 2. 해당 부(Bracket) 내에서의 "상대적 순위" 계산
        // - 상위부(또는 통합): r 그대로 사용 (1위 -> 1, 2위 -> 2...)
        // - 하위부: (현재순위 - 커트라인) 사용 (예: topN이 3이면, 4위 -> 1, 5위 -> 2...)
        let relativeRank = isLowerBracket ? (r - config.topN) : r;

        // 3. 스네이크 방향 결정 (상대적 순위가 짝수면 역방향)
        // 홀수(1,3,5): 정방향 (1조 -> N조)
        // 짝수(2,4,6): 역방향 (N조 -> 1조)
        const isReverse = (relativeRank % 2 === 0);

        // 4. 순회할 조의 순서 결정
        // 원본 groups 배열을 건드리지 않기 위해 복사([...groups]) 후 뒤집음
        const targetGroups = isReverse ? [...groups].reverse() : groups;

        targetGroups.forEach(g => {
          const team = getTeamByRank(g.id, r);
          if (team) {
            const item = { 
              id: `${g.id}-${r}`, 
              label: `${g.name} ${r}위`, 
              team: { ...team, sourceLabel: `${g.name} ${r}위` } 
            };

            // 모드에 따라 상위/하위 큐에 분배
            if (config.tournamentMode === 'split') {
              if (r <= config.topN) upperQ.push(item); 
              else lowerQ.push(item);
            } else if (config.tournamentMode === 'topN') {
              // 상위부만 진행하는 모드
              if (r <= config.topN) upperQ.push(item);
            } else {
              // 전체 통합 모드
              upperQ.push(item);
            }
          }
        });
      }

      setQualifiers({ upper: upperQ, lower: lowerQ });

      // --- 이하 브라켓 사이즈 계산 로직은 기존과 동일 ---
      const calcSize = (n) => {
        if (n <= 4) return 4;
        if (n <= 8) return 8;
        if (n <= 16) return 16;
        if (n <= 32) return 32;
        if (n <= 64) return 64;
        if (n <= 128) return 128;
        return 256;
      };

      const uSize = calcSize(upperQ.length);
      const lSize = calcSize(lowerQ.length);
      
      setBracketSize({ upper: uSize, lower: lSize });
      setSlots({ 
          upper: Array(uSize).fill(null), 
          lower: Array(lSize).fill(null) 
      });
      setActiveTab('upper');
      
      const initialSize = activeTab === 'upper' ? uSize : lSize;
      let startZoom = 1.8;
      if (initialSize >= 32) startZoom = 1.0;
      if (initialSize >= 64) startZoom = 0.4;
      if (initialSize >= 128) startZoom = 0.3;
      
      setView({ zoom: startZoom, x: 0, y: 0 });

    }, [isOpen, config, groups]);
        
    useEffect(() => {
      setPopover(null);
    }, [activeTab]);
    
    // --- 통합 드래그 핸들러 ---
    useEffect(() => {
      const onMove = (e) => {
        if (winDragRef.current.mode) {
            const { startX, startY, init } = winDragRef.current;
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            if (winDragRef.current.mode === 'move') {
              setWin(p => ({ ...p, x: init.x + dx, y: init.y + dy }));
            } else {
              setWin(p => ({ ...p, w: Math.max(800, init.w + dx), h: Math.max(600, init.h + dy) }));
            }
            return;
        }
        if (isPanning) {
            e.preventDefault();
            const dx = e.clientX - panDragRef.current.startX;
            const dy = e.clientY - panDragRef.current.startY;
            setView(p => ({ ...p, x: panDragRef.current.initX + dx, y: panDragRef.current.initY + dy }));
            return;
        }
        if (popoverDragRef.current.active) {
            e.preventDefault();
            const dx = e.clientX - popoverDragRef.current.startX;
            const dy = e.clientY - popoverDragRef.current.startY;
            setPopover(p => p ? ({ ...p, x: popoverDragRef.current.initX + dx, y: popoverDragRef.current.initY + dy }) : null);
        }
      };

      const onUp = () => { 
          winDragRef.current.mode = null; 
          setIsPanning(false);
          popoverDragRef.current.active = false;
          document.body.style.userSelect = ''; 
          document.body.style.cursor = '';
      };

      if(isOpen) { window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onUp); }
      return () => { window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onUp); };
    }, [isOpen, isPanning]);

    const startWinDrag = (mode, e) => {
      e.stopPropagation();
      winDragRef.current = { mode, startX: e.clientX, startY: e.clientY, init: { ...win } };
      document.body.style.userSelect = 'none';
    };

    const startPan = (e) => {
        if (e.target.closest('button') || e.target.closest('.match-card') || e.target.closest('.popover-container')) return;
        
        if (popover) {
        setPopover(null); // 리스트 닫기
        setHoveredTeamId(null); // 호버 상태도 초기화 (안전장치)
        return; // 드래그 모드로 진입하지 않고 종료
        }
    
        setIsPanning(true);
        panDragRef.current = { startX: e.clientX, startY: e.clientY, initX: view.x, initY: view.y };
        document.body.style.cursor = 'grabbing';
        document.body.style.userSelect = 'none';
    };

    const startPopoverDrag = (e) => {
        e.stopPropagation();
        if(!popover) return;
        popoverDragRef.current = { active: true, startX: e.clientX, startY: e.clientY, initX: popover.x, initY: popover.y };
        document.body.style.userSelect = 'none';
    };

    // --- 슬롯 조작 ---
    const handleSlotClick = (idx, e) => {
      e.stopPropagation();
      const popWidth = 180;
      const popHeight = 300;
      
      const initialX = win.x + (win.w / 2) - (popWidth / 2); 
      const initialY = win.y + (win.h / 2) - (popHeight / 2);
      
      setPopover({ slotIdx: idx, x: initialX, y: initialY });
    };

    const assignTeam = (slotIdx, qItem) => {
      const newSlots = [...slots[activeTab]];
      const existingIdx = newSlots.findIndex(s => s && s.id === qItem.id);

      if (existingIdx !== -1 && existingIdx !== slotIdx) {
          const targetOccupant = newSlots[slotIdx];
          newSlots[existingIdx] = targetOccupant;
          newSlots[slotIdx] = qItem;
      } else {
          newSlots[slotIdx] = qItem;
      }

      setSlots(p => ({ ...p, [activeTab]: newSlots }));
      setPopover(null);
      setHoveredTeamId(null);
    };

    const resetCurrent = () => {
      if(!confirm('현재 탭의 대진 설정을 초기화하시겠습니까?')) return;
      setSlots(p => ({ ...p, [activeTab]: Array(bracketSize[activeTab]).fill(null) }));
    };

    const handleAutoAssign = () => {
      if (!confirm('자동 배정하시겠습니까?')) return;

      const qList = [...qualifiers[activeTab]]; // 현재 탭(상위/하위)의 팀 목록
      const currentSize = bracketSize[activeTab]; // 현재 슬롯 크기 (8, 16, 32...)
      
      // 1. 시드 배치 순서 계산 (1, 32, 16, 17...)
      const placement = getSeedPlacementOrder(currentSize);

      // 2. V2 분배 로직 실행
      // qList는 이미 성적순(1조1위, 2조1위... 1조2위...)으로 정렬되어 있다고 가정
      const assignedSlots = distributeEntrantsV2(qList, currentSize, placement);

      // 3. 빈 자리는 BYE로 채우기
      for(let i=0; i<currentSize; i++) {
          if(!assignedSlots[i]) {
            assignedSlots[i] = { 
              id: `auto-bye-${i}`, 
              label: 'BYE', 
              isBye: true, 
              team: { id: `bye-${Math.random()}`, name: 'BYE', isBye: true } 
            };
          }
      }

      setSlots(prev => ({ ...prev, [activeTab]: assignedSlots }));
      toast("배정이 완료되었습니다.");
    };

    const handleConfirm = () => {
      const hasSplit = config.tournamentMode === 'split';
      const checkEmpty = (arr, name) => {
          if (arr.some(s => s === null)) {
              alert(`[${name}] 배정되지 않은 대진칸이 있습니다.\n빈 칸을 클릭하여 팀을 선택하거나 'BYE'를 지정해주세요.`);
              return false;
          }
          return true;
      };

      if (qualifiers.upper.length > 0 && !checkEmpty(slots.upper, hasSplit ? '상위부' : '통합')) return;
      if (hasSplit && qualifiers.lower.length > 0 && !checkEmpty(slots.lower, '하위부')) return;

      const result = {};
      if (qualifiers.upper.length > 0) result.upper = slots.upper.map(s => s.team);
      if (qualifiers.lower.length > 0) result.lower = slots.lower.map(s => s.team);
      
      onConfirm(result);
    };

// [수정] 토너먼트 셋팅 노드 (팀 이름 외곽 표시 기능 추가)
// [수정] SetupMatchNode: 하이라이트 처리를 위해 activeSlotIdx, highlightTeamId props 추가
const SetupMatchNode = ({ roundIdx, matchIdx, isRight, totalRounds, slotIdxA, slotIdxB, currentSlots, activeSlotIdx, highlightTeamId }) => {
    const isLeaf = roundIdx === 0;
    const isLastRound = roundIdx === totalRounds - 2; 
    const isEven = matchIdx % 2 === 0;
    
    const slotA = isLeaf ? currentSlots[slotIdxA] : null;
    const slotB = isLeaf ? currentSlots[slotIdxB] : null;
    const LINE_LEN = '16px'; 

    const getSlotTooltip = (slot) => {
        if (!slot) return '미배정';
        if (slot.team && !slot.team.isBye) return slot.team.name;
        return slot.label;
    };

    const renderTeamName = (slot) => {
        if (!slot || !slot.team || slot.team.isBye) return null;
        return (
            <span style={{
                position: 'absolute', top: '50%', transform: 'translateY(-50%)',
                [isRight ? 'left' : 'right']: '105%', whiteSpace: 'nowrap',
                color: 'var(--text-muted)', fontSize: '11px', fontWeight: 'bold', pointerEvents: 'none',
                textShadow: '0 1px 2px var(--bg-body)'
            }}>
                {slot.team.name}
            </span>
        );
    };

    // [추가 로직] 하이라이트 여부 판별 함수
    // 1. 현재 팝업이 열린 슬롯(activeSlotIdx)인가?
    // 2. 리스트에서 마우스 올린 팀(highlightTeamId)이 배정된 슬롯인가?
    const isHighlighted = (slotIdx, slot) => {
        if (activeSlotIdx === slotIdx) return true; // 클릭된 칸
        if (highlightTeamId && slot && slot.team && slot.team.id === highlightTeamId) return true; // 교체 대상
        return false;
    };

    const highlightStyle = (isHigh) => isHigh ? {
        background: 'var(--btn-secondary-bg-hover)',
        color: 'var(--btn-secondary-text-hover)',
        borderColor: 'var(--accent)'
    } : {};
    
    return (
        <div style={{ 
            display: 'flex', flexDirection: 'column', justifyContent: 'center', position: 'relative', 
            flex: 1, width: isLeaf ? 'var(--dynamic-card-width)' : '10px', alignSelf: 'center', minHeight: isLeaf ? '60px' : '20px' 
        }}>
            {!isLastRound && (
                <>
                    <div className="connector-line" style={{ height: '1px', width: LINE_LEN, top: '50%', [isRight ? 'left' : 'right']: `-${LINE_LEN}` }} />
                    <div className="connector-line" style={{ width: '1px', top: isEven ? '50%' : 'auto', bottom: isEven ? 'auto' : '50%', height: 'calc(50% + 2px)', [isRight ? 'left' : 'right']: `-${LINE_LEN}` }} />
                </>
            )}
            {isLastRound && (
                <div className="connector-line" style={{ height: '1px', width: LINE_LEN, top: '50%', [isRight ? 'right' : 'left']: `-${LINE_LEN}` }} />
            )}

            <div className="relative z-10 flex flex-col justify-center w-full" style={{ margin: isLeaf ? '4px 0' : '0' }}>
                {isLeaf ? (
                    <div className="flex flex-col w-full">
                        {/* Team A Button */}
                        <button onClick={(e)=>handleSlotClick(slotIdxA, e)}
                            className="setup-slot-btn hover:brightness-95"
                            style={{ 
                                position: 'relative', overflow: 'visible',
                                ...highlightStyle(isHighlighted(slotIdxA, slotA)) // [적용]
                            }}
                            title={getSlotTooltip(slotA)}>
                            {slotA ? slotA.label : (slotIdxA+1)}
                            {renderTeamName(slotA)}
                        </button>

                        {/* Team B Button */}
                        <button onClick={(e)=>handleSlotClick(slotIdxB, e)}
                            className="setup-slot-btn hover:brightness-95"
                            style={{ 
                                position: 'relative', overflow: 'visible',
                                ...highlightStyle(isHighlighted(slotIdxB, slotB)) // [적용]
                            }}
                            title={getSlotTooltip(slotB)}>
                            {slotB ? slotB.label : (slotIdxB+1)}
                            {renderTeamName(slotB)}
                        </button>
                    </div>
                ) : null}
            </div>
        </div>
    );
};

const renderWing = (isRight) => {
        const size = bracketSize[activeTab];
        const halfSize = size / 2;
        const totalRounds = Math.log2(size); 
        const wingRounds = Array.from({length: totalRounds - 1}, (_, i) => i);
        const startSlot = isRight ? halfSize : 0;
        
        return (
            <div className={`wing-container ${isRight ? 'right-wing' : 'left-wing'}`} style={{gap:0}}>
                {wingRounds.map((rIdx) => {
                    const matchesInRound = halfSize / Math.pow(2, rIdx + 1);
                    
                    // [수정 핵심] 
                    // 1라운드(rIdx===0): 버튼을 보여주기 위해 160px 확보
                    // 2라운드 이상: 선만 보여주면 되므로 40px로 축소 (기존 100px -> 40px)
                    const columnWidth = rIdx === 0 ? '160px' : '40px';

                    return (
                        <div key={rIdx} className="round-column justify-around" 
                             style={{ minWidth: columnWidth, transition: 'min-width 0.3s' }}> 
                            {Array.from({length: matchesInRound}, (_, mIdx) => {
                                const actualLeafBase = startSlot + (mIdx * 2);
                                return (
                                    <SetupMatchNode 
                                        key={mIdx} 
                                        roundIdx={rIdx} 
                                        matchIdx={mIdx}
                                        isRight={isRight}
                                        totalRounds={totalRounds}
                                        slotIdxA={actualLeafBase}
                                        slotIdxB={actualLeafBase + 1}
                                        currentSlots={slots[activeTab]}
                                        activeSlotIdx={popover?.slotIdx}
                                        highlightTeamId={hoveredTeamId}
                                    />
                                );
                            })}
                        </div>
                    );
                })}
            </div>
        );
    };

    if (!isOpen) return null;

    const currentSlots = slots[activeTab];
    const currentQualifiers = qualifiers[activeTab];
    const usedIds = currentSlots.filter(Boolean).map(s => s.id);
    const hasSplit = config.tournamentMode === 'split';

    return (
      <div className="fixed inset-0 z-[9999]">
        <div className="absolute inset-0 bg-black/60 backdrop-blur-sm" onClick={onClose} />
        <div className="absolute flex flex-col rounded-xl border shadow-2xl overflow-hidden"
          style={{ 
              left: win.x, top: win.y, width: win.w, height: win.h, 
              borderColor: 'var(--card-border)', 
              background: 'var(--bg-body)',
              color: 'var(--text-main)'
          }}>
          
          {/* Header */}
          <div className="flex justify-between items-center px-4 py-2 border-b cursor-move"
            onMouseDown={(e)=>startWinDrag('move',e)} 
            style={{borderColor:'var(--table-border)', background:'var(--table-header-bg)'}}>
            <h3 className="font-bold flex items-center gap-2 text-base">
              <Icons.Trophy size={18} style={{color:'var(--tournament-winner)'}}/> 토너먼트 대진 설정
            </h3>
            <button onClick={onClose} className="p-1 rounded opacity-70 hover:opacity-100"><Icons.X size={18}/></button>
          </div>

          {/* Toolbar */}
          <div className="px-4 py-2 border-b flex justify-between items-center" 
               style={{borderColor:'var(--table-border)', background: 'var(--card-bg)'}}>
             <div className="flex gap-2 items-center">
               {hasSplit ? (
                 <div className="flex rounded-lg p-0.5 border" style={{borderColor:'var(--table-border)', background:'var(--input-bg)'}}>
                   <button onClick={()=>setActiveTab('upper')} 
                           className={`px-3 py-1 rounded text-xs font-bold transition-all`}
                           style={{
                               background: activeTab==='upper' ? 'var(--accent)' : 'transparent',
                               color: activeTab==='upper' ? '#fff' : 'var(--text-muted)'
                           }}>
                           상위부 ({qualifiers.upper.length})
                   </button>
                   <button onClick={()=>setActiveTab('lower')} 
                           className={`px-3 py-1 rounded text-xs font-bold transition-all`}
                           style={{
                               background: activeTab==='lower' ? 'var(--accent-2)' : 'transparent',
                               color: activeTab==='lower' ? '#fff' : 'var(--text-muted)'
                           }}>
                           하위부 ({qualifiers.lower.length})
                   </button>
                 </div>
               ) : (
                 <span className="text-xs font-bold px-3 py-1 rounded border" 
                       style={{color:'var(--accent)', borderColor:'var(--accent)', background:'var(--highlight-bg)'}}>
                       통합 토너먼트
                 </span>
               )}
               
               <div className="w-px h-4 mx-1" style={{background:'var(--divider)'}}></div>

               <button onClick={handleAutoAssign} 
                       className="text-xs flex items-center gap-1 border px-2 py-1 rounded hover:opacity-80"
                       style={{borderColor:'var(--accent)', color:'var(--accent)', background:'var(--input-bg)'}}>
                 <Icons.Wand size={10}/> 자동 배정
               </button>

               <button onClick={resetCurrent} 
                       className="text-xs flex items-center gap-1 border px-2 py-1 rounded hover:opacity-80"
                       style={{borderColor:'var(--table-border)', color:'var(--text-muted)', background:'var(--input-bg)'}}>
                 <Icons.Refresh size={10}/> 초기화
               </button>
             </div>
             
             <button onClick={handleConfirm} 
               className="px-4 py-1.5 rounded-lg font-bold shadow-lg flex items-center gap-1.5 text-white text-xs transition-all transform active:scale-95"
               style={{background: 'var(--btn-primary-bg)'}}>
               <Icons.Check size={14}/> 대진표 확정
             </button>
          </div>

          {/* Canvas Area (No Wheel) */}
          <div className="flex-1 overflow-hidden relative cursor-grab active:cursor-grabbing"
               style={{background: 'var(--bg-body)'}}
               onMouseDown={startPan}>
             
             {/* Background Grid */}
             <div className="absolute inset-0 pointer-events-none opacity-10" 
                  style={{backgroundImage: 'radial-gradient(var(--table-border) 1px, transparent 1px)', backgroundSize: '20px 20px', transform: `translate(${view.x}px, ${view.y}px) scale(${view.zoom})`, transformOrigin: '0 0'}}>
             </div>

             <div className="w-full h-full flex items-center justify-center origin-center will-change-transform"
                  style={{ transform: `translate(${view.x}px, ${view.y}px) scale(${view.zoom})` }}>
                
                {/* Butterfly Bracket Layout */}
                <div className="tournament-tree flex items-stretch justify-center p-10 gap-0">
                    
                    {/* Left Wing */}
                    {renderWing(false)}

                    {/* Center Final */}
                    <div className="round-column justify-center mx-2 relative z-10" style={{minWidth:'100px'}}>
                        
                        <div className="w-24 h-16 border rounded-xl shadow-lg flex flex-col items-center justify-center gap-1"
                             style={{
                                 borderColor: 'var(--tournament-winner)', 
                                 background: 'linear-gradient(to bottom, var(--card-bg), var(--tournament-winner-bg2))'
                             }}>
                            <Icons.Trophy size={20} style={{color:'var(--tournament-winner)'}}/>
                            <span className="text-[10px] font-bold" style={{color:'var(--text-main)'}}>WINNER</span>
                        </div>
                    </div>

                    {/* Right Wing */}
                    {renderWing(true)}

                </div>
             </div>

             {/* Zoom Controls */}
             <div className="absolute bottom-6 right-6 flex flex-col gap-2 border rounded-lg p-1.5 shadow-xl z-50 backdrop-blur-sm"
                  style={{background:'var(--control-pill-bg)', borderColor:'var(--control-pill-border)'}}>
                 <button onClick={()=>setView(p=>({...p, zoom: Math.min(2.0, p.zoom+0.1)}))} className="p-1.5 rounded hover:bg-black/10" style={{color:'var(--accent)'}}><Icons.Plus size={16}/></button>
                 <button onClick={()=>setView(p=>({...p, zoom: Math.max(0.2, p.zoom-0.1)}))} className="p-1.5 rounded hover:bg-black/10" style={{color:'var(--accent)'}}><span className="block w-4 h-0.5 bg-current my-2"></span></button>
                 <div className="h-px my-0.5" style={{background:'var(--control-divider)'}}></div>
                 <button onClick={()=>setView({zoom: 0.8, x:0, y:0})} className="p-1.5 rounded hover:bg-black/10" style={{color:'var(--text-muted)'}} title="화면 맞춤"><Icons.Refresh size={14}/></button>
             </div>

{/* [UPDATE] Draggable Team Select Popover (Solid Background) */}
             {popover && (
               <div className="popover-container fixed z-[10000] border shadow-2xl rounded-lg flex flex-col animate-in fade-in zoom-in-95 duration-100"
                   // [수정] w-52 -> w-44로 사이즈 축소
                   style={{ 
                       top: popover.y, left: popover.x,
                       width: '176px', // w-44 equivalent
                       background: 'var(--btn-secondary-bg)', 
                       borderColor: 'var(--btn-secondary-bg)',
                       maxHeight: '350px', // 높이 제한 약간 축소
                       boxShadow: '0 20px 40px -5px rgba(0,0,0,0.5)' 
                   }}>
                   
                   <div className="sticky top-0 p-2 border-b flex justify-between items-center z-10 cursor-move"
                        onMouseDown={startPopoverDrag}
                        style={{background: 'var(--select-bg)', borderColor: 'var(--divider)'}}>
                       <div className="flex items-center gap-2 pl-1">
                           <Icons.List size={12} style={{color:'var(--text-muted)'}}/>
                           <span className="text-[11px] font-bold" style={{color:'var(--text-main)'}}>팀 선택</span>
                       </div>
                           <button onClick={()=>{ setPopover(null); setHoveredTeamId(null); }}>
                           <Icons.X size={12} style={{color:'var(--text-muted)'}}/>
                       </button>
                   </div>

                   <div className="py-1 overflow-y-auto custom-scrollbar" style={{backgroundColor: 'var(--select-bg)'}}>
                       {/* BYE Option */}
                       <button 
                           onClick={()=>{ assignTeam(popover.slotIdx, { id: `manual-bye-${popover.slotIdx}`, label: 'BYE', isBye: true, team: { id: `bye-${Math.random()}`, name: 'BYE', isBye: true } }); }}
                           className={`w-full text-left px-3 py-2 text-xs border-b transition-colors flex justify-between items-center group`}
                           style={{borderColor:'var(--table-cell-border)', color: 'var(--accent)'}}
                       >
                           <span className="font-bold">✨ BYE</span>
                           <span className="text-[10px] opacity-0 group-hover:opacity-100">선택</span>
                       </button>
			      {currentQualifiers
			      .slice() // 1. 원본 배열(스네이크 순서)을 건드리지 않기 위해 복사
			      .sort((a, b) => {
			          // 2. ID 포맷이 "그룹ID-순위" (예: "0-1", "3-2") 이므로 이를 파싱하여 정렬
			          const [gA, rA] = a.id.split('-').map(Number);
			          const [gB, rB] = b.id.split('-').map(Number);
			          
			          // 우선 순위(Rank) 오름차순 (1위 -> 2위 -> 3위...)
			          if (rA !== rB) return rA - rB;
			          
			          // 그 다음 조(Group) 오름차순 (1조 -> 2조 -> 3조...)
			          return gA - gB;
			      })
			      .map(q => {
			          const isUsed = usedIds.includes(q.id) && currentSlots[popover.slotIdx]?.id !== q.id;
			          return (
			            <button key={q.id} 
			              onClick={()=>{ assignTeam(popover.slotIdx, q); }}
			              onMouseEnter={() => setHoveredTeamId(q.team?.id)}
			              onMouseLeave={() => setHoveredTeamId(null)}
			              
			              title={q.team ? q.team.name : ''}
			              className={`w-full text-left px-3 py-2 text-xs border-b transition-colors flex justify-between items-center group`}
			              style={{
			                  borderColor: 'var(--table-cell-border)',
			                  background: isUsed ? 'var(--btn-secondary-bg)' : 'transparent', 
			                  color: isUsed ? 'var(--text-muted)' : 'var(--text-main)'
			              }}
			            >
			              <span className={`truncate ${isUsed ? 'font-bold' : ''}`}>{q.label}</span>
			              {isUsed 
			                 ? <span className="text-[9px] font-bold border rounded px-1" style={{borderColor:'currentColor'}}>교체</span>
			                 : <span className="text-[9px] opacity-0 group-hover:opacity-100" style={{color:'var(--accent)'}}>선택</span>
			              }
			            </button>
			          );
			    })}

			    {currentQualifiers.length === 0 && <div className="p-4 text-center text-[10px]" style={{color:'var(--text-muted)'}}>팀 없음</div>}
                   </div>
               </div>
             )}
          </div>

          {/* Resize Handle */}
          <div className="absolute bottom-0 right-0 w-6 h-6 cursor-nwse-resize z-50" 
               style={{background: 'linear-gradient(135deg, transparent 50%, var(--resize-handle-accent) 50%)', opacity:0.8}}
               onMouseDown={(e)=>startWinDrag('resize',e)}/>
        </div>
      </div>
    );
  };
  
    function ThemeManagerModal({
      open,
      onClose,
      themeKey,
      setThemeKey,
      themeValues,
      onChangeValue,
      onSaveToBrowser,
      onExportFile,
      onImportFile,
      onResetTheme
    }) {
      const fileRef = useRef(null);
      // 카테고리 접기/펼치기 상태
      const [openCats, setOpenCats] = useState(() => Object.fromEntries(THEME_CATEGORIES.map(c => [c.id, true])));
      const [query, setQuery] = useState("");

      // --------------------------------------------------------
      // [추가] 윈도우 이동/크기조절 상태 관리
      // --------------------------------------------------------
      // 초기 위치: 화면 중앙쯤, 크기: 800x600
      const [winState, setWinState] = useState({
        x: typeof window !== 'undefined' ? window.innerWidth / 2 - 400 : 100,
        y: 100,
        w: 800,
        h: 600
      });

      const dragRef = useRef({ mode: null, startX: 0, startY: 0, initX: 0, initY: 0, initW: 0, initH: 0 });

      // 드래그/리사이즈 이벤트 핸들러
      useEffect(() => {
        const onMouseMove = (e) => {
          if (!dragRef.current.mode) return;
          e.preventDefault();
          const { mode, startX, startY, initX, initY, initW, initH } = dragRef.current;
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;

          if (mode === 'move') {
            setWinState(prev => ({ ...prev, x: initX + dx, y: initY + dy }));
          } else if (mode === 'resize') {
            setWinState(prev => ({
              ...prev,
              w: Math.max(400, initW + dx), // 최소 너비 400
              h: Math.max(300, initH + dy)  // 최소 높이 300
            }));
          }
        };

        const onMouseUp = () => {
          if (dragRef.current.mode) {
            dragRef.current.mode = null;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
          }
        };

        if (open) {
          window.addEventListener('mousemove', onMouseMove);
          window.addEventListener('mouseup', onMouseUp);
        }
        return () => {
          window.removeEventListener('mousemove', onMouseMove);
          window.removeEventListener('mouseup', onMouseUp);
        };
      }, [open]);

      const startMove = (e) => {
        // 헤더 버튼 클릭 시 드래그 방지
        if (e.target.closest('button') || e.target.closest('input')) return;
        dragRef.current = {
          mode: 'move',
          startX: e.clientX, startY: e.clientY,
          initX: winState.x, initY: winState.y,
          initW: winState.w, initH: winState.h
        };
        document.body.style.userSelect = 'none';
      };

      const startResize = (e) => {
        e.stopPropagation();
        dragRef.current = {
          mode: 'resize',
          startX: e.clientX, startY: e.clientY,
          initX: winState.x, initY: winState.y,
          initW: winState.w, initH: winState.h
        };
        document.body.style.userSelect = 'none';
        document.body.style.cursor = 'nwse-resize';
      };

      useEffect(() => {
        if (open) setQuery("");
      }, [open]);

      if (!open) return null;

      const q = (query || '').trim().toLowerCase();
      const keyMatches = (k) => {
        if (!q) return true;
        return (
          k.toLowerCase().includes(q) ||
          getThemeLabel(k).toLowerCase().includes(q) ||
          getThemeDesc(k).toLowerCase().includes(q)
        );
      };

      return (
        // 배경 오버레이 (클릭 시 닫힘) -> 배경 클릭이 필요 없다면 pointer-events-none 처리 가능
        <div className="fixed inset-0 z-[9999]">
          <div className="absolute inset-0" style={{background:'var(--modal-overlay-bg)'}} onClick={onClose}></div>

          {/* [변경] 위치/크기를 state로 제어하는 윈도우 컨테이너 
             - 기존: 중앙 정렬된 정적 div
             - 변경: fixed position + style로 x, y, w, h 제어
          */}
          <div 
            className="absolute flex flex-col rounded-2xl border shadow-2xl overflow-hidden"
            style={{
              left: winState.x,
              top: winState.y,
              width: winState.w,
              height: winState.h,
              background: 'var(--bg-body)',
              borderColor: 'var(--card-border)',
              transition: dragRef.current.mode ? 'none' : 'box-shadow 0.2s' // 드래그 중엔 부드럽게
            }}
          >
            {/* [변경] 헤더: onMouseDown 이벤트 추가 (드래그 시작점)
               - cursor: move 추가
            */}
            <div 
              className="flex items-center justify-between px-4 py-3 border-b cursor-move flex-none select-none"
              style={{borderColor:'var(--table-border)', background: 'var(--table-header-bg)'}}
              onMouseDown={startMove}
            >
              <div className="flex items-center gap-2 pointer-events-none">
                <span className="inline-flex items-center justify-center w-8 h-8 rounded-xl border"
                  style={{borderColor:'var(--table-border)', background:'var(--card-bg)'}}>
                  <Icons.Settings size={16} />
                </span>
                <div>
                  <div className="font-bold tracking-tight" style={{color:'var(--text-main)'}}>테마 관리</div>
                </div>
              </div>

              <div className="flex items-center gap-2">
                 {/* 닫기 버튼 */}
                <button className="px-3 py-1.5 rounded-lg border text-xs font-bold hover:bg-red-500/10 hover:text-red-500 hover:border-red-500/50 transition-colors"
                  style={{borderColor:'var(--table-border)', color:'var(--text-muted)'}}
                  onClick={onClose}>
                  <Icons.X size={14}/>
                </button>
              </div>
            </div>

            {/* 툴바 영역 (크기 고정) */}
            <div className="px-4 py-3 flex-none border-b" style={{borderColor:'var(--divider)'}}>
                <div className="flex flex-wrap items-center gap-2">
                  <button onClick={()=>setThemeKey('dark')}
                    className={`px-3 py-2 rounded-xl border text-sm font-semibold transition-all ${themeKey==='dark' ? 'opacity-100 ring-2 ring-offset-1 ring-offset-transparent' : 'opacity-70 hover:opacity-100'}`}
                    style={{
                      borderColor: themeKey==='dark' ? 'var(--accent)' : 'var(--table-border)',
                      color: 'var(--text-main)',
                      background: themeKey==='dark' ? 'var(--highlight-bg)' : 'transparent',
                      '--tw-ring-color': 'var(--accent)'
                    }}
                  >다크</button>

                  <button onClick={()=>setThemeKey('light')}
                    className={`px-3 py-2 rounded-xl border text-sm font-semibold transition-all ${themeKey==='light' ? 'opacity-100 ring-2 ring-offset-1 ring-offset-transparent' : 'opacity-70 hover:opacity-100'}`}
                    style={{
                      borderColor: themeKey==='light' ? 'var(--accent)' : 'var(--table-border)',
                      color: 'var(--text-main)',
                      background: themeKey==='light' ? 'var(--highlight-bg)' : 'transparent',
                      '--tw-ring-color': 'var(--accent)'
                    }}
                  >라이트</button>

                  <div className="ml-auto flex flex-wrap items-center gap-2">
                    <input
                      value={query}
                      onChange={(e)=>setQuery(e.target.value)}
                      placeholder="검색..."
                      className="px-3 py-2 rounded-xl border text-sm w-32 focus:w-48 transition-all"
                      style={{ background:'var(--input-bg)', borderColor:'var(--table-border)', color:'var(--text-main)' }}
                    />
                    
                    {/* 버튼들을 아이콘으로 간소화하여 공간 절약 */}
                    <button onClick={onResetTheme} className="p-2 rounded-xl border" title="초기화" style={{borderColor:'var(--table-border)', color:'var(--text-main)'}}><Icons.Refresh size={16}/></button>
                    <button onClick={onSaveToBrowser} className="p-2 rounded-xl border" title="브라우저 저장" style={{borderColor:'var(--table-border)', color:'var(--text-main)'}}><Icons.Save size={16}/></button>
                    <button onClick={onExportFile} className="p-2 rounded-xl border" title="내보내기" style={{borderColor:'var(--table-border)', color:'var(--text-main)'}}><Icons.Upload size={16} className="rotate-180"/></button>
                    <button onClick={()=>fileRef.current?.click()} className="p-2 rounded-xl border" title="불러오기" style={{borderColor:'var(--table-border)', color:'var(--text-main)'}}><Icons.Upload size={16}/></button>
                    
                    <input ref={fileRef} type="file" accept=".json" className="hidden"
                      onChange={(e)=> { const f = e.target.files?.[0]; if (f) onImportFile(f); e.target.value = ''; }}
                    />
                  </div>
                </div>
            </div>

            {/* 메인 컨텐츠 (스크롤 가능) */}
            <div className="flex-1 overflow-hidden flex flex-col relative">
                <div className="flex-1 overflow-y-auto p-4 custom-scrollbar">
                  <div className="rounded-2xl border overflow-hidden" style={{borderColor:'var(--table-border)'}}>
                    <div className="grid grid-cols-12 px-3 py-2 text-xs font-bold sticky top-0 z-10"
                      style={{background:'var(--table-header-bg)', color:'var(--text-muted)', borderBottom: '1px solid var(--table-border)'}}>
                      <div className="col-span-4">항목</div>
                      <div className="col-span-8">값</div>
                    </div>

                    <div className="">
                      {THEME_CATEGORIES.map((cat) => {
                        const catKeys = (cat.keys || []).filter(k => THEME_KEYS.includes(k)).filter(keyMatches);
                        if (!catKeys.length) return null;
                        const isOpen = !!openCats[cat.id];

                        return (
                          <div key={cat.id}>
                            <button
                              type="button"
                              className="w-full flex items-center justify-between px-3 py-2 border-t text-sm font-bold"
                              style={{borderColor:'var(--table-cell-border)', background:'var(--highlight-bg)', color:'var(--text-main)'}}
                              onClick={() => setOpenCats(p => ({...p, [cat.id]: !p[cat.id]}))}
                            >
                              <div className="flex items-center gap-2">
                                {isOpen ? <Icons.ChevronDown size={16}/> : <Icons.ChevronRight size={16}/>}
                                <span>{cat.label}</span>
                                <span className="text-xs font-normal" style={{color:'var(--text-muted)'}}>({catKeys.length})</span>
                              </div>
                            </button>

                            {isOpen && catKeys.map((k) => (
                              <div key={k} className="grid grid-cols-12 gap-2 px-3 py-2 border-t items-start"
                                style={{borderColor:'var(--table-cell-border)'}}>
                                <div className="col-span-4 pt-1">
                                  <div className="text-xs font-semibold break-keep" style={{color:'var(--text-main)'}}>{getThemeLabel(k)}</div>
                                  <div className="font-mono text-[9px] mt-0.5 opacity-60 truncate" style={{color:'var(--text-muted)'}} title={`--${k}`}>--{k}</div>
                                </div>
                                <div className="col-span-8">
                                  <MultiColorValueEditor value={themeValues?.[k] ?? ''} onChange={(v)=>onChangeValue(k, v)} />
                                </div>
                              </div>
                            ))}
                          </div>
                        );
                      })}
                    </div>
                  </div>
                  
                  <div className="text-xs mt-4 mb-2 leading-relaxed opacity-70" style={{color:'var(--text-muted)'}}>
                    * 윈도우 우측 하단을 드래그하여 크기를 조절할 수 있습니다.
                  </div>
                </div>
            </div>

            {/* [추가] 리사이즈 핸들 */}
            <div 
              className="absolute bottom-0 right-0 w-5 h-5 cursor-nwse-resize z-20"
              style={{
                background: 'linear-gradient(135deg, transparent 50%, var(--resize-handle-accent, #38bdf8) 50%)',
                opacity: 0.8
              }}
              onMouseDown={startResize}
            />
          </div>
        </div>
      );
    }

// ==========================================================
// [NEW] V2 토너먼트 컴포넌트 (버터플라이 레이아웃)
// ==========================================================

// 1. 개별 팀 카드 (클릭 이벤트 및 스타일 처리)
const TeamSlot = React.memo(({ team, isWinner, isLoser, isFinal,onClick }) => {
  const isBye = team && team.isBye;
  const displayClass = isWinner ? 'winner' : isLoser ? 'loser' : isBye ? 'bye' : '';
  
  const tooltipText = (team && !isBye && team.sourceLabel) ? team.sourceLabel : '';
  
const finalStyle = isFinal ? {
      width: '180px',      // 너비 2배 (160px * 2)
      height: '48px',      // 높이 2배 (32px * 2)
      fontSize: '14px',    // 글자 크기 2배 (14px * 2)
      padding: '0 12px',   // 내부 여백 확대
      fontWeight: '800',   // 글자 두께 강조
      lineHeight: '1.2'    // 줄간격 조정
  } : {};
  
  return (
    <div 
      className={`team-slot ${displayClass} ${!team ? 'opacity-30' : ''}`}
      style={finalStyle}
      onClick={(e) => {
        e.stopPropagation();
        if (team && !isBye && !isWinner && onClick) onClick();
      }}
      title={tooltipText}
    >
      <span className="truncate w-full">
        {team ? team.name : '-'}
      </span>
      {/* 여기에 있던 {isWinner && <Icons.Check ... />} 코드를 삭제했습니다. */}
    </div>
  );
});

// 2. 매치 노드 (두 팀 카드 + 연결선)
// hideConnector prop 추가: 특정 라운드에서 기본 연결선을 숨김
// 공동우승 버튼 및 하이라이팅 로직 추가 props에 onJointWin 추가됨
const MatchNode = React.memo(({ match, roundIdx, matchIdx, isLeft, isFinal, hideConnector, onWin, onJointWin }) => {
  const [hover, setHover] = React.useState(false); // 호버 상태
  const { teamA, teamB, winner, isJointWinner } = match;

  const winA = isJointWinner || (winner && teamA && winner.id === teamA.id);
  const winB = isJointWinner || (winner && teamB && winner.id === teamB.id);
  
  const isEven = matchIdx % 2 === 0;
  const LineWidth = 20;

  const handleWin = (team) => {
    if (team && !team.isBye) onWin(match, team);
  };

  return (
    <div 
      className="match-node relative"
      onMouseEnter={() => setHover(true)}
      onMouseLeave={() => setHover(false)}
    >
      {/* [수정 핵심] Hover Bridge 
         결승전(isFinal)일 때, 카드 본체와 상단 버튼 사이의 빈 공간을 
         투명한 박스로 채워 마우스가 끊기지 않고 이동하게 합니다.
      */}
      {isFinal && (
        <div className="absolute -top-10 left-0 w-full h-10 bg-transparent z-40" />
      )}

      {/* 결승전이고 마우스가 올라갔을 때 공동우승 버튼 표시 */}
      {isFinal && hover && teamA && teamB && (
        <button
          onClick={(e) => {
            e.stopPropagation();
            onJointWin(match);
          }}
          className="absolute -top-8 left-1/2 transform -translate-x-1/2 px-2 py-1 text-[10px] font-bold text-white rounded shadow-lg z-50 animate-in fade-in slide-in-from-bottom-2"
          style={{ background: 'var(--accent)', whiteSpace: 'nowrap' }}
        >
          공동우승
        </button>
      )}

      {/* 카드 영역 */}
      <div className="flex flex-col shadow-sm relative z-10">
        <TeamSlot team={teamA} isWinner={winA} isLoser={!winA && (winner || isJointWinner)} isFinal={isFinal} onClick={() => handleWin(teamA)} />
        <TeamSlot team={teamB} isWinner={winB} isLoser={!winB && (winner || isJointWinner)} isFinal={isFinal} onClick={() => handleWin(teamB)} />
      </div>

      {/* 연결선 */}
      {!isFinal && !hideConnector && (
        <>
          <div 
            className={`connector ${winner ? 'active' : ''}`}
            style={{
              height: '1px',
              width: `${LineWidth}px`,
              top: '50%',
              [isLeft ? 'right' : 'left']: `-${LineWidth}px`
            }}
          />
          <div 
            className={`connector ${winner ? 'active' : ''}`}
            style={{
              width: '1px',
              top: isEven ? '50%' : 'auto',
              bottom: isEven ? 'auto' : '50%',
              height: 'calc(50% + 10px + 2px)', 
              [isLeft ? 'right' : 'left']: `-${LineWidth}px`
            }} 
          />
        </>
      )}
    </div>
  );
});

// 버터플라이 레이아웃
const ButterflyLayout = ({ bracket, bIdx, onWinMatch, onToggleJointWin }) => {
  const rounds = bracket.rounds;
  if (!rounds || rounds.length === 0) return <div className="text-muted p-10">대진표 데이터가 없습니다.</div>;

  const totalRounds = rounds.length;
  const finalRoundIdx = totalRounds - 1;
  const finalMatch = rounds[finalRoundIdx][0];

  const leftWingColumns = [];
  const rightWingColumns = [];
  
  for (let r = 0; r < finalRoundIdx; r++) {
    const roundMatches = rounds[r];
    const half = Math.ceil(roundMatches.length / 2);
    leftWingColumns.push(roundMatches.slice(0, half));
    rightWingColumns.push(roundMatches.slice(half));
  }

  const GAP_SIZE = '-60px'; 
  const ELEVATION = '120px'; 

  // [수정 포인트] 최상위 컨테이너에 h-full 적용 및 items-stretch 사용
  return (
    <div className="flex items-stretch justify-center p-10 gap-0 h-full w-full">
      
      {/* Left Wing: items-center -> items-stretch로 변경하여 높이 100% 사용 */}
      <div className="flex flex-row items-stretch relative z-10">
        {leftWingColumns.map((colMatches, colIdx) => {
          const isLastWingRound = colIdx === leftWingColumns.length - 1;
          return (
            <div key={`L-col-${colIdx}`} className="bracket-column">
              {colMatches.map((match, idx) => (
                <MatchNode 
                  key={match.id} 
                  match={match} 
                  roundIdx={colIdx} 
                  matchIdx={idx} 
                  isLeft={true} 
                  hideConnector={isLastWingRound}
                  onWin={(m, w) => onWinMatch(bIdx, colIdx, idx, w)} 
                />
              ))}
            </div>
          );
        })}
      </div>

      {/* ===== CENTER (FINAL) 유지 (기존 코드와 동일) ===== */}
      {/* 결승전은 독립적인 위치를 가지므로 items-stretch의 영향을 받지 않도록 flex-col/center 유지 */}
      <div className="flex flex-col items-center justify-center relative" style={{ margin: `0 ${GAP_SIZE}`, pointerEvents: 'none' }}>
         <div className="relative z-20 scale-110" style={{ transform: `translateY(-${ELEVATION})`, pointerEvents: 'auto' }}> 
             <MatchNode 
               match={finalMatch} 
               roundIdx={finalRoundIdx} 
               matchIdx={0} 
               isLeft={false} 
               isFinal={true} 
               onWin={(m, w) => onWinMatch(bIdx, finalRoundIdx, 0, w)} 
               onJointWin={() => onToggleJointWin(bIdx, finalRoundIdx, 0)}
             />
         </div>
      </div>

      {/* Right Wing: items-center -> items-stretch로 변경 */}
      <div className="flex flex-row-reverse items-stretch relative z-10">
        {rightWingColumns.map((colMatches, colIdx) => {
            const isLastWingRound = colIdx === rightWingColumns.length - 1;
            return (
              <div key={`R-col-${colIdx}`} className="bracket-column">
                {colMatches.map((match, idx) => {
                  const originalIdx = (rounds[colIdx].length / 2) + idx;
                  return (
                    <MatchNode 
                      key={match.id} 
                      match={match} 
                      roundIdx={colIdx} 
                      matchIdx={idx} 
                      isLeft={false} 
                      hideConnector={isLastWingRound}
                      onWin={(m, w) => onWinMatch(bIdx, colIdx, originalIdx, w)} 
                    />
                  );
                })}
              </div>
            );
        })}
      </div>

    </div>
  );
};

    // ----------------------------------------------------------
    // Main App
    // ----------------------------------------------------------
    function PingPongManager() {
      const DATA_STORAGE_KEY = 'pingpong_data_autosave_v1';
      // 저장된 데이터가 있으면 불러오고, 없으면 기본값(fallback)을 사용하는 헬퍼 함수
	const getSavedState = (key, fallback) => {
	  try {
	    const saved = localStorage.getItem(DATA_STORAGE_KEY);
	    if (!saved) return fallback;
	    const parsed = JSON.parse(saved);
	    // 저장된 객체 안에 해당 key가 있으면 반환, 없으면 기본값 반환
	    return parsed[key] !== undefined ? parsed[key] : fallback;
	  } catch (e) {
	    console.error("Data load failed", e);
	    return fallback;
	  }
	};
	
      // --- [수정] 상태 초기화 시 getSavedState 사용하여 복원 ---
      const [activeTab, setActiveTab] = useState(() => getSavedState('activeTab', 'register'));
      const [isDarkMode, setIsDarkMode] = useState(false); // 테마는 별도 스토리지 사용하므로 유지
      
      const [themeMenuOpen, setThemeMenuOpen] = useState(false);
      const [themeManagerOpen, setThemeManagerOpen] = useState(false);
      const [themeManagerTab, setThemeManagerTab] = useState('dark');
      const themeMenuRef = useRef(null);

      const [themeDefaults, setThemeDefaults] = useState(null);
      const [themeOverrides, setThemeOverrides] = useState(null);
      
      // [NEW] Setup Modal State
      const [showSetupModal, setShowSetupModal] = useState(false);
    
      // [추가] 팀 등록 시 입력할 소속 정보 state
      const [newAffiliation, setNewAffiliation] = useState('');
      
      // 토너먼트 뷰 필터 상태 (0: 첫번째/상위, 1: 두번째/하위)
      const [visibleBracketIdx, setVisibleBracketIdx] = useState(0);
      
      // Apply overrides to live UI
      useEffect(() => {
        if (!themeOverrides) return;
        let el = document.getElementById('theme-overrides-style');
        if (!el) {
          el = document.createElement('style');
          el.id = 'theme-overrides-style';
          document.head.appendChild(el);
        }
        const cssFor = (selector, vars) => {
          const entries = THEME_KEYS.map(k => `--${k}:${(vars?.[k] ?? '').trim()};`).join('');
          return `${selector}{${entries}}`;
        };
        el.textContent = cssFor(':root', themeOverrides.dark) + cssFor('body.light-mode', themeOverrides.light);
      }, [themeOverrides]);

      const [teams, setTeams] = useState(() => getSavedState('teams', []));
      const [groups, setGroups] = useState(() => getSavedState('groups', []));
      const [tournamentData, setTournamentData] = useState(() => getSavedState('tournamentData', { type: 'single', brackets: [] }));
      const [isLeagueGenerated, setIsLeagueGenerated] = useState(() => getSavedState('isLeagueGenerated', false));
      const [cardSizes, setCardSizes] = useState(() => getSavedState('cardSizes', {}));
      
      const [viewStates, setViewStates] = useState(() => getSavedState('viewStates', {
        0: { zoom: 0.85, pan: { x: 0, y: 0 } },
        1: { zoom: 0.85, pan: { x: 0, y: 0 } }
      }));
      
      const currentView = viewStates[visibleBracketIdx] || { zoom: 0.85, pan: { x: 0, y: 0 } };
      
      const updateCurrentZoom = (action) => {
        setViewStates(prev => {
          const idx = visibleBracketIdx;
          const current = prev[idx] || { zoom: 0.85, pan: { x: 0, y: 0 } };
          // 함수형 업데이트 지원 (예: z => z + 0.1)
          const nextZoom = typeof action === 'function' ? action(current.zoom) : action;
          const clamped = Math.min(2.0, Math.max(0.3, nextZoom)); // 범위 제한
          return { ...prev, [idx]: { ...current, zoom: clamped } };
        });
      };
      // [추가] 현재 탭의 Pan 업데이트 헬퍼
      const updateCurrentPan = (newPan) => {
        setViewStates(prev => ({
          ...prev,
          [visibleBracketIdx]: { ...(prev[visibleBracketIdx] || {}), pan: newPan }
        }));
      };

      const [sortMode, setSortMode] = useState(() => getSavedState('sortMode', 'input'));
      
      const [isDragging, setIsDragging] = useState(false);
      const dragStart = useRef({ x: 0, y: 0 });
      const [isAdminMode, setIsAdminMode] = useState(false);
      const [autoGenCount, setAutoGenCount] = useState(1);

      const [editingTeamId, setEditingTeamId] = useState(null);
      const [editTeamData, setEditTeamData] = useState(null);
      const [hoverState, setHoverState] = useState(null);
      const [printGroupId, setPrintGroupId] = useState(null);
      const [swapModalData, setSwapModalData] = useState(null);

      const [config, setConfig] = useState(() => getSavedState('config', {
        teamSize: 1, minSumLevel: '', groupCount: 4,
        tournamentMode: 'all', topN: 2, rankMethod: '1',
      }));
      
      const [newTeamName, setNewTeamName] = useState('');
      const [newMembers, setNewMembers] = useState([{ name: '', level: '' }]);
      
      const dynamicCardStyle = useMemo(() => {
      return { '--dynamic-card-width': '40px' };
    }, []); // 의존성 배열 비움 (팀 목록 변경 상관없음)
    
      useEffect(() => {
        setNewMembers(Array(config.teamSize).fill({ name: '', level: '' }));
      }, [config.teamSize]);

      useEffect(() => {
        if (isDarkMode) document.body.classList.remove('light-mode');
        else document.body.classList.add('light-mode');
      }, [isDarkMode]);

      // Close theme menu on outside click
      useEffect(() => {
        const onDown = (e) => {
          if (!themeMenuOpen) return;
          const el = themeMenuRef.current;
          if (el && !el.contains(e.target)) setThemeMenuOpen(false);
        };
        window.addEventListener('mousedown', onDown);
        return () => window.removeEventListener('mousedown', onDown);
      }, [themeMenuOpen]);

      // Theme manager helpers
      useEffect(() => { setThemeManagerTab(isDarkMode ? 'dark' : 'light'); }, [themeManagerOpen]);
      useEffect(() => { if (themeManagerOpen) setIsDarkMode(themeManagerTab === 'dark'); }, [themeManagerOpen, themeManagerTab]);

	useEffect(() => {
	  const handler = setTimeout(() => {
	    const dataToSave = {
	      teams,
	      groups,
	      tournamentData,
	      isLeagueGenerated,
	      cardSizes,
	      config,
	      activeTab,
	      sortMode
	    };
	    localStorage.setItem(DATA_STORAGE_KEY, JSON.stringify(dataToSave));
	  }, 1000); // 1초 동안 추가 변경이 없으면 저장 (Debounce)

	  return () => clearTimeout(handler);
	}, [teams, groups, tournamentData, isLeagueGenerated, cardSizes, config, activeTab, sortMode, viewStates]);
	
      const updateThemeValue = (varKey, nextValue) => {
        setThemeOverrides(prev => {
          if (!prev) return prev;
          return { ...prev, [themeManagerTab]: { ...prev[themeManagerTab], [varKey]: nextValue } };
        });
      };

      const saveThemeToBrowser = () => {
        try {
          const payload = { version: 2, themes: themeOverrides || {} };
          localStorage.setItem(THEME_STORAGE_KEY, JSON.stringify(payload));
          toast('테마가 브라우저에 저장되었습니다.');
        } catch (e) { 
          // [수정] 용량 초과 에러 구체적 명시
          if (e.name === 'QuotaExceededError') {
            toast('저장 용량이 부족합니다. 불필요한 데이터를 정리해주세요.');
          } else {
            toast('저장에 실패했습니다. (알 수 없는 오류)');
          }
        }
      };

      const exportThemeFile = () => {
        try {
          const payload = { version: 2, themes: themeOverrides || {} };
          const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = THEME_FILE_NAME;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
          toast('테마 파일을 내보냈습니다.');
        } catch (e) { toast('내보내기에 실패했습니다.'); }
      };

      const importThemeFile = (file) => {
        try {
          const reader = new FileReader();
          reader.onload = () => {
            try {
              const parsed = JSON.parse(reader.result);
              if (!parsed || typeof parsed !== 'object' || !parsed.themes) {
                toast('올바른 테마 파일이 아닙니다.');
                return;
              }
              setThemeOverrides(prev => {
                if (!prev) return prev;
                const next = {
                  dark: { ...prev.dark, ...(parsed.themes.dark || {}) },
                  light: { ...prev.light, ...(parsed.themes.light || {}) }
                };
                return next;
              });
              toast('테마 파일을 불러왔습니다.');
            } catch (e) { toast('파일 해석에 실패했습니다.'); }
          };
          reader.readAsText(file, 'utf-8');
        } catch (e) { toast('파일 불러오기에 실패했습니다.'); }
      };

      const resetThemeToDefaults = () => {
        if (!themeDefaults || !themeOverrides) return;
        setThemeOverrides(prev => {
          if (!prev) return prev;
          return { ...prev, [themeManagerTab]: { ...themeDefaults[themeManagerTab] } };
        });
        toast('기본값으로 초기화했습니다.');
      };

      // Load theme defaults + saved overrides (file > localStorage) and apply
      useLayoutEffect(() => {
        const wasLight = document.body.classList.contains('light-mode');

        document.body.classList.remove('light-mode');
        const rootStyle = getComputedStyle(document.documentElement);
        const dark = {};
        THEME_KEYS.forEach(k => { dark[k] = rootStyle.getPropertyValue(`--${k}`).trim(); });

        document.body.classList.add('light-mode');
        const bodyStyle = getComputedStyle(document.body);
        const light = {};
        THEME_KEYS.forEach(k => {
          const v = bodyStyle.getPropertyValue(`--${k}`).trim();
          light[k] = v || dark[k] || '';
        });

        if (wasLight) document.body.classList.add('light-mode');
        else document.body.classList.remove('light-mode');

        const defaults = { dark, light };
        setThemeDefaults(defaults);

        const merge = (base, patch) => {
          const out = { dark: { ...base.dark }, light: { ...base.light } };
          if (patch?.themes?.dark) out.dark = { ...out.dark, ...patch.themes.dark };
          if (patch?.themes?.light) out.light = { ...out.light, ...patch.themes.light };
          // Ensure all keys exist
          THEME_KEYS.forEach(k => {
            if (out.dark[k] == null || out.dark[k] === '') out.dark[k] = base.dark[k] || '';
            if (out.light[k] == null || out.light[k] === '') out.light[k] = base.light[k] || '';
          });
          return out;
        };

        const fromLocalStorage = () => {
          try {
            const raw = localStorage.getItem(THEME_STORAGE_KEY);
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            if (!parsed || typeof parsed !== 'object') return null;
            return parsed;
          } catch (_) { return null; }
        };

        (async () => {
          let ov = { dark: { ...defaults.dark }, light: { ...defaults.light } };

          try {
            const url = new URL(THEME_FILE_NAME, window.location.href).toString();
            const res = await fetch(url, { cache: 'no-store' });
            if (res.ok) {
              const parsed = await res.json();
              ov = merge(ov, parsed);
              setThemeOverrides(ov);
              return;
            }
          } catch (_) {}

          setThemeOverrides(ov);
        })();
      }, []);
      
	// [추가] 팀명 자동 생성 규칙 통합
	const buildAutoTeamName = (members, teamSize) => {
	  const size = Number(teamSize) || (members?.length ?? 0);

	  // 3인 이상 단체전 + 팀명 미지정일 때: "첫번째(실제로는 첫 유효 이름) + 팀"
	  if (size >= 3) {
	    const firstName = (members || [])
	      .map(m => (m?.name || '').trim())
	      .find(n => n.length > 0);

	    if (firstName) return `${firstName}팀`;
	  }

	  // 그 외(1~2인 경기) 또는 이름이 비어있어 첫이름을 못 찾은 경우: 기존 방식 유지
	  return (members || [])
	    .map(m => `${(m?.name || '').trim()}(${m?.level || 0})`)
	    .join(', ');
	};
	
	// [추가] 팀원 입력값 정규화: name trim, level 공백이면 0으로 보정
	const normalizeMembers = (members) => {
	  return (members || []).map((m) => {
	    const name = String(m?.name ?? '').trim();

	    const rawLevel = String(m?.level ?? '').trim();
	    const parsed = rawLevel === '' ? 0 : parseInt(rawLevel, 10);
	    const level = Number.isFinite(parsed) ? parsed : 0;

	    return { ...m, name, level };
	  });
	};
	
	// [추가] 예선 리그 표시에 쓰는 팀명 규칙
	const getLeagueDisplayName = (team) => {
	  const size = team?.members?.length ?? 0;
	  const fixedName = String(team?.name ?? '').trim();

	  // ✅ 3인 이상: 팀 목록에서 정해진 팀명 우선 사용
	  if (size >= 3) return fixedName || buildAutoTeamName(team?.members, size);

	  // 1~2인은 기존 방식 유지(현재 team.name 자체가 이미 기존 규칙을 따르고 있음)
	  return fixedName || buildAutoTeamName(team?.members, size);
	};
      // ----------------------------------------------------------
      // Teams / League logic (mostly original)
      // ----------------------------------------------------------
      const handleMemberChange = (idx, field, val) => {
        const u = [...newMembers];
        u[idx] = { ...u[idx], [field]: val };
        setNewMembers(u);
      };

      const addTeam = () => {
	  // 1) 멤버 정규화 (level 공백 -> 0)
	  const normalizedMembers = normalizeMembers(newMembers);

	  // 2) 이름 검증: 하나라도 비면 등록 불가
	  const hasEmptyName = normalizedMembers.some(m => !m.name);
	  if (hasEmptyName) {
	    toast('팀원 이름을 모두 입력해야 등록할 수 있습니다.');
	    return;
	  }

	  // 3) 합부수 계산 (정규화된 level 기반)
	  const totalLevel = normalizedMembers.reduce((s, m) => s + (parseInt(m.level || 0, 10) || 0), 0);

	  // 4) 최소 합부수 조건 체크
	  const minSum = parseInt(config.minSumLevel, 10) || 0;
	  if (totalLevel < minSum) {
	    toast(`팀 합산 부수 ${minSum} 이상 필요`);
	    return;
	  }

	  // 5) 팀명 결정 (기존 규칙 유지)
	  let teamName = newTeamName.trim();
	  if (!teamName) teamName = buildAutoTeamName(normalizedMembers, config.teamSize);

	  // 소속 정보가 없으면 빈 문자열(또는 '무소속') 처리
	  const affiliation = newAffiliation.trim();

	  setTeams([
	    ...teams,
	    {
	      id: Date.now(),
	      name: teamName,
	      affiliation: affiliation, // [New] 소속 정보 추가
	      members: normalizedMembers, // ✅ 보정된 값 저장
	      totalLevel,
	      totalAge: 0,
	      stats: { wins: 0, losses: 0 },
	      groupId: null
	    }
	  ]);

	  setNewTeamName('');
	  setNewAffiliation('');
	  setNewMembers(Array.from({ length: config.teamSize }, () => ({ name: '', level: '' })));
      };

const generateRandomTeams = () => {
        const count = parseInt(autoGenCount) || 1;
        const teamSize = parseInt(config.teamSize) || 1;
        
        // 부수 범위 설정 (1~9부)
        const MIN_LEVEL = 1;
        const MAX_LEVEL = 9;
        
        // 팀당 가능한 최대 합부수 (예: 3인전이면 27)
        const MAX_POSSIBLE_SCORE = teamSize * MAX_LEVEL;

        // 사용자가 입력한 최소 합부수
        let minSum = parseInt(config.minSumLevel) || 0;
        
        // 입력된 최소 합부수가 물리적으로 불가능한 수치(최대치 초과)라면 최대치로 보정
        if (minSum > MAX_POSSIBLE_SCORE) {
          alert(`설정된 최소 합부수(${minSum})가 생성 가능한 최대치(${MAX_POSSIBLE_SCORE})보다 높습니다. 최대치로 조정하여 생성합니다.`);
          minSum = MAX_POSSIBLE_SCORE;
        }

        // [핵심 로직 변경 함수]
        const makeLevels = () => {
          // 1. 목표 합부수 결정 (Random Total)
          // 최소 합부수가 없으면 그냥 랜덤, 있으면 '최소 ~ 최대' 사이 랜덤
          let targetTotal = 0;
          
          if (!minSum || minSum <= 0) {
            // 최소 기준이 없으면 완전 랜덤 (팀원별 1~9 랜덤)
            return Array.from({ length: teamSize }, () => (MIN_LEVEL + Math.floor(Math.random() * (MAX_LEVEL - MIN_LEVEL + 1))));
          } else {
            // 최소 기준이 있으면: [최소값, 최대값] 구간 내에서 랜덤 총점 결정
            targetTotal = minSum + Math.floor(Math.random() * (MAX_POSSIBLE_SCORE - minSum + 1));
          }

          // 2. 초기화: 모든 팀원을 최소 부수(1)로 시작
          const levels = Array(teamSize).fill(MIN_LEVEL);
          
          // 3. 목표 점수까지 남은 점수 분배
          let remaining = targetTotal - (teamSize * MIN_LEVEL);

          let guard = 0;
          while (remaining > 0 && guard < 5000) {
            guard++;
            const idx = Math.floor(Math.random() * teamSize);
            
            // 해당 팀원이 아직 최대 부수(9) 미만이라면 1 증가
            if (levels[idx] < MAX_LEVEL) {
              levels[idx] += 1;
              remaining -= 1;
            }
          }
          return levels;
        };

        const newTeams = [];
        for (let i = 0; i < count; i++) {
          const levels = makeLevels(); // 위에서 수정된 로직 사용
          
          const members = Array.from({ length: teamSize }, (_, idx) => ({
            name: getRandomItem(NAMES),
            level: levels[idx],
          }));
          
          const totalLevel = levels.reduce((s, v) => s + v, 0);
          const name = buildAutoTeamName(members, teamSize);
          const randomAffiliation = getRandomItem(AFFILIATION_LIST);
          
          newTeams.push({
            id: Date.now() + Math.random() + i,
            name,
            affiliation: randomAffiliation,
            members,
            totalLevel,
            totalAge: 0,
            stats: { wins: 0, losses: 0 },
            groupId: null
          });
        }

        setTeams([...teams, ...newTeams]);
      };

      const removeTeam = (id) => { if(confirm('삭제?')) setTeams(teams.filter(t => t.id !== id)); };
      const clearAllTeams = () => { 
        if(teams.length && confirm("전체 팀 목록을 삭제하시겠습니까?\n(예선 및 본선 결과도 모두 초기화됩니다)")) { 
          setTeams([]); 
          setIsLeagueGenerated(false); 
          setGroups([]); 

          // [추가됨] 본선 토너먼트 데이터도 초기 상태로 리셋
          setTournamentData({ type: 'single', brackets: [] });
        } 
      };
      
      const startEditing = (team) => { setEditingTeamId(team.id); setEditTeamData(JSON.parse(JSON.stringify(team))); };
      const cancelEditing = () => { setEditingTeamId(null); setEditTeamData(null); };
      const saveEditing = () => {
	  const normalizedMembers = normalizeMembers(editTeamData.members);

	  if (normalizedMembers.some(m => !m.name)) {
	    toast('팀원 이름을 모두 입력해야 저장할 수 있습니다.');
	    return;
	  }

	  const totalLevel = normalizedMembers.reduce((s,m)=>s+(parseInt(m.level||0,10)||0),0);

	  const trimmedName = (editTeamData.name || '').trim();
	  const finalName = trimmedName || buildAutoTeamName(normalizedMembers, normalizedMembers.length);

	  const updatedTeam = { ...editTeamData, name: finalName, members: normalizedMembers, totalLevel };

	  const updatedTeams = teams.map(t => t.id === updatedTeam.id ? updatedTeam : t);
	  setTeams(updatedTeams); setEditingTeamId(null);

	  if (isLeagueGenerated) rebuildGroupsFromTeams(updatedTeams);
      };

      const handleEditChange = (field, val, mIdx = -1, mField = '') => {
        if (mIdx === -1) setEditTeamData({ ...editTeamData, [field]: val });
        else {
          const u = [...editTeamData.members];
          u[mIdx] = { ...u[mIdx], [mField]: val };
          setEditTeamData({ ...editTeamData, members: u });
        }
      };

      const handleGroupChange = (tId, gId) => {
        const updatedTeams = teams.map(t => t.id === tId ? { ...t, groupId: parseInt(gId) } : t);
        setTeams(updatedTeams);
        if(isLeagueGenerated) rebuildGroupsFromTeams(updatedTeams);
      };

// [수정] generateGroups 함수: 합부수 최저순(오름차순) + 최저 부수 보유 팀 우선 정렬 적용
      const generateGroups = () => {
        if (teams.length < config.groupCount) return alert("팀이 부족하여 조를 생성할 수 없습니다.");

        // [New] 정렬 기준 함수 (1. 합부수 오름차순, 2. 팀 내 최저 부수 오름차순)
        const compareLeagueSort = (a, b) => {
            // 1. 합부수 비교 (낮은 팀이 상위)
            if (a.totalLevel !== b.totalLevel) {
                return a.totalLevel - b.totalLevel;
            }
            // 2. 동률 시: 팀원 중 가장 낮은 부수가 있는 팀이 상위
            const minA = Math.min(...a.members.map(m => parseInt(m.level || 0) || 0));
            const minB = Math.min(...b.members.map(m => parseInt(m.level || 0) || 0));
            return minA - minB;
        };

        // 1. 기준에 따라 전체 팀 정렬 (시드 배정을 위함)
        const sortedTeams = [...teams].sort(compareLeagueSort);

        // 2. [1단계] 스네이크 방식으로 일단 무조건 균등 배정
        const tempGroups = Array.from({ length: config.groupCount }, () => []);
        
        sortedTeams.forEach((t, i) => {
            const round = Math.floor(i / config.groupCount);
            const isEven = round % 2 === 0;
            // 짝수 라운드는 정방향, 홀수 라운드는 역방향 (스네이크)
            const gIdx = isEven ? (i % config.groupCount) : (config.groupCount - 1 - (i % config.groupCount));
            tempGroups[gIdx].push(t);
        });

        // 3. [2단계] 배정 후 소속 충돌 발생 시, 1:1 교환 (Swap) 로직 (기존 유지)
        for (let gIdx = 0; gIdx < config.groupCount; gIdx++) {
            for (let tIdx = 0; tIdx < tempGroups[gIdx].length; tIdx++) {
                const currentTeam = tempGroups[gIdx][tIdx];
                if (!currentTeam.affiliation) continue;

                const hasConflict = tempGroups[gIdx].some((t, i) => i !== tIdx && t.affiliation === currentTeam.affiliation);
                
                if (hasConflict) {
                    let swapped = false;
                    for (let otherGIdx = 0; otherGIdx < config.groupCount; otherGIdx++) {
                        if (gIdx === otherGIdx || swapped) continue;
                        if (tIdx >= tempGroups[otherGIdx].length) continue;

                        const targetTeam = tempGroups[otherGIdx][tIdx];
                        const conflictThere = tempGroups[otherGIdx].some((t, i) => i !== tIdx && t.affiliation === currentTeam.affiliation);
                        const conflictHere = tempGroups[gIdx].some((t, i) => i !== tIdx && t.affiliation === targetTeam.affiliation);

                        if (!conflictThere && !conflictHere) {
                            tempGroups[gIdx][tIdx] = targetTeam;
                            tempGroups[otherGIdx][tIdx] = currentTeam;
                            swapped = true;
                        }
                    }
                }
            }
        }

        // [New] 4. 최종 결과 반영 전, 각 조 내부를 다시 '합부수 최저순'으로 정렬 (테이블 표시용)
        // 스네이크 방식이나 교환으로 인해 섞인 순서를 테이블 상단부터 예쁘게 정렬합니다.
        tempGroups.forEach(group => {
            group.sort(compareLeagueSort);
        });

	// [아래 코드로 교체 (수정됨)]
	// 5. 최종 결과 State 업데이트 (기존 코드 유지)
	const finalTeams = [];
	tempGroups.forEach((group, gId) => {
	    group.forEach(t => {
	        finalTeams.push({ ...t, groupId: gId });
	    });
	});

	setTeams(finalTeams);
	rebuildGroupsFromTeams(finalTeams);
	setIsLeagueGenerated(true);

	// [수정] 카드 사이즈 초기화 로직 변경
	// 팀 수에 맞춰 너비를 자동 계산: 기본영역(이름+승패등 약 260px) + (팀당 약 65px)
	const initSizes = {};
	tempGroups.forEach((group, i) => {
	    const teamCount = group.length;
	    // 내용이 잘리지 않도록 기본 폭과 팀당 폭을 여유 있게 설정
	    const autoWidth = Math.max(550, 320 + (teamCount * 90));
	    //initSizes[i] = { w: autoWidth, h: 'auto' };
	    initSizes[i] = { w: autoWidth, h: 'auto' };
	});
	setCardSizes(initSizes);

	setActiveTab('league');
      };

// [수정] 조별 데이터 재구성 함수 (정렬 로직 추가)
      const rebuildGroupsFromTeams = (currentTeams) => {
        const matrixMap = {};
        groups.forEach(g => matrixMap[g.id] = g.matrix);

        let newGroups = Array.from({ length: config.groupCount }, (_, i) => ({
          id: i,
          name: `${i + 1}조`,
          teams: [],
          matrix: matrixMap[i] || {}
        }));

        // 1. 각 팀을 해당 조(groupId)에 배정
        currentTeams.forEach(t => {
          if (t.groupId !== null && newGroups[t.groupId]) {
            const exist = groups.find(g => g.id === t.groupId)?.teams.find(old => old.id === t.id);
            newGroups[t.groupId].teams.push({
              ...t,
              leagueStats: exist ? exist.leagueStats : { win: 0, loss: 0, scoreWin: 0, scoreLoss: 0, rank: 0 }
            });
          }
        });

        // ---------------------------------------------------------
        // [추가] 요구사항: 각 조 내부의 팀들을 합부수 기준 오름차순 정렬
        // (합부수 최저 팀이 상위, 최고 팀이 하위)
        // ---------------------------------------------------------
        newGroups.forEach(group => {
          group.teams.sort((a, b) => {
            // 합부수 오름차순 (낮은 수가 먼저)
            if (a.totalLevel !== b.totalLevel) {
              return a.totalLevel - b.totalLevel;
            }
            // 합부수가 같을 경우 이름순 (보조 정렬)
            return a.name.localeCompare(b.name);
          });
        });
        // ---------------------------------------------------------

        setGroups(newGroups);
      };

      const getFormattedSchedule = (teamCount) => {
        const schedule = FIXED_MATCH_ORDER[teamCount];
        if (!schedule) return "대진 순서 : 일정 없음";
        const matchesPerBlock = Math.floor(teamCount / 2);
        let formatted = [];
        let currentBlock = [];
        schedule.forEach((match, idx) => {
          currentBlock.push(`${match[0]}:${match[1]}`);
          if (currentBlock.length === matchesPerBlock) {
            formatted.push(currentBlock.join(" "));
            currentBlock = [];
          }
        });
        if (currentBlock.length > 0) formatted.push(currentBlock.join(" "));
        return "대진 순서 : " + formatted.join(" | ");
      };

      const formatPrintTeamName = (name, fallback) => {
        const s = (name || '').trim();
        if (!s) return String(fallback);
        return s.replace(/,\s*/g, '\n');
      };

      const updateMatrixScore = (gId, tA, tB, val) => {
        const updated = groups.map(g => g.id !== gId ? g : { ...g, matrix: { ...g.matrix, [`${tA}_vs_${tB}`]: val } });
        setGroups(recalculateStats(updated, gId));
      };

      const updateStatManual = (gId, tId, field, val) => {
        setGroups(groups.map(g => g.id !== gId ? g : { ...g, teams: g.teams.map(t => t.id !== tId ? t : { ...t, leagueStats: { ...t.leagueStats, [field]: parseInt(val)||0 } }) }));
      };

      const updateRankManual = (gId, tId, val) => {
        setGroups(groups.map(g => g.id!==gId ? g : { ...g, teams: g.teams.map(t => t.id!==tId ? t : { ...t, leagueStats: { ...t.leagueStats, rank: parseInt(val)||0 } }) }));
      };

      const recalculateStats = (gData, gId) => {
        return gData.map(g => {
          if (g.id !== gId) return g;
          const newTeams = g.teams.map(t => {
            let win = 0, loss = 0, sw = 0, sl = 0;
            g.teams.forEach(opp => {
              if (t.id === opp.id) return;
              const my = g.matrix[`${t.id}_vs_${opp.id}`], op = g.matrix[`${opp.id}_vs_${t.id}`];
              const hasScore = (v) => v !== undefined && v !== null && v !== '';
              if (hasScore(my) && hasScore(op)) {
                const m = parseInt(my, 10);
                const o = parseInt(op, 10);
                if (!Number.isNaN(m) && !Number.isNaN(o)) {
                  sw += m; sl += o;
                  if (m > o) win++;
                  else if (m < o) loss++;
                }
              }
            });
            return { ...t, leagueStats: { ...t.leagueStats, win, loss, scoreWin: sw, scoreLoss: sl } };
          });
          return { ...g, teams: newTeams };
        });
      };

      // [수정] 순위 계산 로직 (미니 리그 득실률 로직 추가)
      const getSortedTeams = (teams, matrix, rankMethod) => {
        // --- 헬퍼 함수들 ---
        // 1. 전체 득실률
        const getRate = (t) => (t.leagueStats.scoreLoss === 0 ? t.leagueStats.scoreWin * 1000 : t.leagueStats.scoreWin / t.leagueStats.scoreLoss);
        // 2. 승패차
        const getWinDiff = (t) => t.leagueStats.win - t.leagueStats.loss;
        // 3. 상대전적 체크 (a가 b를 이겼으면 true)
        const isWinH2H = (a, b) => {
          const sA = parseInt(matrix[`${a.id}_vs_${b.id}`] || 0);
          const sB = parseInt(matrix[`${b.id}_vs_${a.id}`] || 0);
          return sA > sB;
        };

        // ---------------------------------------------------------
        // [핵심] 재귀적 동률 처리 함수 (Tie Breaker)
        // ---------------------------------------------------------
        const resolveTies = (tiedTeams, depth = 0) => {
          // 1팀이면 정렬 끝
          if (tiedTeams.length <= 1) return tiedTeams; 

          // 안전장치: 너무 깊은 재귀 방지
          if (depth > 10) return tiedTeams.sort((a, b) => a.totalLevel - b.totalLevel);

          // A. [2팀 동률] -> 승자승 원칙
          if (tiedTeams.length === 2) {
            const [a, b] = tiedTeams;
            if (isWinH2H(a, b)) return [a, b];
            if (isWinH2H(b, a)) return [b, a];
            // 완전 무승부면 합부수 -> 등록순
            return [a, b].sort((x, y) => (x.totalLevel - y.totalLevel) || (x.id - y.id));
          }

          // B. [3팀 이상 동률]
          
          // B-1. 압도적 승자 확인 (해당 그룹 내에서 전승한 팀이 있는지)
          const internalWins = new Map();
          tiedTeams.forEach(t => internalWins.set(t.id, 0));
          
          for (let i = 0; i < tiedTeams.length; i++) {
            for (let j = i + 1; j < tiedTeams.length; j++) {
              const A = tiedTeams[i], B = tiedTeams[j];
              if (isWinH2H(A, B)) internalWins.set(A.id, internalWins.get(A.id) + 1);
              else if (isWinH2H(B, A)) internalWins.set(B.id, internalWins.get(B.id) + 1);
            }
          }

          // 3팀일 때 2승 한 팀이 있다면 그 팀이 1위 (나머지는 재귀로 승자승 처리)
          if (tiedTeams.length === 3) {
            const dominant = tiedTeams.find(t => internalWins.get(t.id) === 2);
            if (dominant) {
              const others = tiedTeams.filter(t => t.id !== dominant.id);
              return [dominant, ...resolveTies(others, depth + 1)];
            }
          }

          // B-2. 물고 물리는 상황 (가위바위보) -> 정밀 비교 정렬
          // 정렬 기준: 1.전체득실률 -> 2.미니리그득실률 -> 3.합부수
          
          // [New] 미니 리그 득실률 계산 헬퍼
          // 현재 묶여있는 tiedTeams 끼리의 경기 결과만 합산
          const getMiniRate = (target) => {
            let winScore = 0;
            let lossScore = 0;
            tiedTeams.forEach(opp => {
              if (target.id === opp.id) return;
              winScore += parseInt(matrix[`${target.id}_vs_${opp.id}`] || 0);
              lossScore += parseInt(matrix[`${opp.id}_vs_${target.id}`] || 0);
            });
            return lossScore === 0 ? winScore * 1000 : winScore / lossScore;
          };

          // 정렬 수행
          tiedTeams.sort((a, b) => {
            // 1순위: 전체 득실률
            const rateDiff = getRate(b) - getRate(a);
            if (Math.abs(rateDiff) > 0.0001) return rateDiff;

            // 2순위: 미니 리그 득실률 (끼리끼리 득실)
            const miniDiff = getMiniRate(b) - getMiniRate(a);
            if (Math.abs(miniDiff) > 0.0001) return miniDiff;

            // 3순위: 합부수 (낮은 팀 우선)
            return a.totalLevel - b.totalLevel;
          });

          // B-3. 정렬 후에도 여전히 동률인 그룹이 있는지 확인하여 재귀 호출
          // (예: 전체득실, 미니득실, 합부수까지 모두 같은 기적적인 경우 -> 2팀 남으면 승자승으로 감)
          const finalResult = [];
          let subGroup = [tiedTeams[0]];

          const isReallySame = (t1, t2) => {
             const r1 = getRate(t1), r2 = getRate(t2);
             const m1 = getMiniRate(t1), m2 = getMiniRate(t2);
             return Math.abs(r1 - r2) < 0.0001 && 
                    Math.abs(m1 - m2) < 0.0001 && 
                    t1.totalLevel === t2.totalLevel;
          };

          for (let i = 1; i < tiedTeams.length; i++) {
            const prev = subGroup[0];
            const curr = tiedTeams[i];

            if (isReallySame(prev, curr)) {
              subGroup.push(curr);
            } else {
              if (subGroup.length > 1) finalResult.push(...resolveTies(subGroup, depth + 1));
              else finalResult.push(...subGroup);
              subGroup = [curr];
            }
          }
          if (subGroup.length > 1) finalResult.push(...resolveTies(subGroup, depth + 1));
          else finalResult.push(...subGroup);

          return finalResult;
        };

        // ---------------------------------------------------------
        // 1. 전체 목록 1차 정렬 (선택한 기준에 따라)
        // ---------------------------------------------------------
        const sorted = [...teams].sort((a, b) => {
          if (rankMethod === 'WIN_PRIORITY') {
            // [승패] 기준: 승패차 우선
            if (getWinDiff(b) !== getWinDiff(a)) return getWinDiff(b) - getWinDiff(a);
          } else {
            // [득실] 기준: 득실률 우선
            if (Math.abs(getRate(b) - getRate(a)) > 0.0001) return getRate(b) - getRate(a);
          }
          return 0; // 1차 기준 동률
        });

        // ---------------------------------------------------------
        // 2. 동률 그룹핑 후 상세 룰(resolveTies) 적용
        // ---------------------------------------------------------
        const finalized = [];
        let currentTieGroup = [sorted[0]];

        for (let i = 1; i < sorted.length; i++) {
          const prev = currentTieGroup[0];
          const curr = sorted[i];

          let isTied = false;
          if (rankMethod === 'WIN_PRIORITY') {
             isTied = (getWinDiff(prev) === getWinDiff(curr));
          } else {
             isTied = (Math.abs(getRate(prev) - getRate(curr)) < 0.0001);
          }

          if (isTied) {
            currentTieGroup.push(curr);
          } else {
            finalized.push(...resolveTies(currentTieGroup));
            currentTieGroup = [curr];
          }
        }
        finalized.push(...resolveTies(currentTieGroup));

        return finalized;
      };

      const recalcAllGroupRanks = (rankMethod) => {
        setGroups(prev =>
          prev.map(g => {
            const sorted = getSortedTeams(g.teams, g.matrix, rankMethod);
            const rankMap = {};
            sorted.forEach((t, i) => { rankMap[t.id] = i + 1; });

            return {
              ...g,
              teams: g.teams.map(t => ({
                ...t,
                leagueStats: { ...t.leagueStats, rank: rankMap[t.id] || 0 }
              }))
            };
          })
        );
      };

      const calculateRank = (gId) => {
        setGroups(groups.map(g => {
          if (g.id !== gId) return g;
          const sorted = getSortedTeams(g.teams, g.matrix, config.rankMethod);
          const rankMap = {}; sorted.forEach((t, i) => rankMap[t.id] = i + 1);
          return { ...g, teams: g.teams.map(t => ({ ...t, leagueStats: { ...t.leagueStats, rank: rankMap[t.id] } })) };
        }));
      };

      const generateAutoLeagueResults = () => {
        if (!confirm("⚠️ 경고: 모든 예선 조의 경기 결과를 자동으로 생성하시겠습니까?\n\n기존에 입력된 점수는 모두 덮어씌워지며, 합산 3점(3:0, 2:1...) 규칙으로 자동 입력되고 순위가 결정됩니다.")) return;
        const newGroups = groups.map(g => {
          const newMatrix = { ...g.matrix };
          let currentTeams = [...g.teams];
          for (let i = 0; i < currentTeams.length; i++) {
            for (let j = i + 1; j < currentTeams.length; j++) {
              const tA = currentTeams[i].id;
              const tB = currentTeams[j].id;
              const scoreA = Math.floor(Math.random() * 4);
              const scoreB = 3 - scoreA;
              newMatrix[`${tA}_vs_${tB}`] = scoreA;
              newMatrix[`${tB}_vs_${tA}`] = scoreB;
            }
          }

          let statsCalculatedTeams = currentTeams.map(t => {
            let win = 0, loss = 0, sw = 0, sl = 0;
            currentTeams.forEach(opp => {
              if (t.id === opp.id) return;
              const my = newMatrix[`${t.id}_vs_${opp.id}`];
              const op = newMatrix[`${opp.id}_vs_${t.id}`];
              if (my !== undefined && op !== undefined) {
                const m = parseInt(my), o = parseInt(op);
                sw += m; sl += o;
                if (m > o) win++; else if (m < o) loss++;
              }
            });
            return { ...t, leagueStats: { ...t.leagueStats, win, loss, scoreWin: sw, scoreLoss: sl } };
          });

          const sortedForRank = getSortedTeams(statsCalculatedTeams, newMatrix, config.rankMethod);
          const rankMap = {};
          sortedForRank.forEach((t, i) => rankMap[t.id] = i + 1);

          const finalTeams = statsCalculatedTeams.map(t => ({
            ...t,
            leagueStats: { ...t.leagueStats, rank: rankMap[t.id] }
          }));

          return { ...g, matrix: newMatrix, teams: finalTeams };
        });
        setGroups(newGroups);
        alert("✅ 모든 경기 결과가 입력되고 순위가 결정되었습니다.");
      };
      
      // [추가] 예선 리그 결과 초기화 함수
      const handleResetLeagueResults = () => {
        if (!confirm("⚠️ 경고: 모든 조별 예선 경기 결과와 순위가 초기화됩니다.\n\n이 작업 수행 시 [본선 토너먼트 대진]도 함께 삭제됩니다.\n\n정말 초기화하시겠습니까?")) return;

        const newGroups = groups.map(g => ({
          ...g,
          // 1. 경기 결과 매트릭스 초기화
          matrix: {}, 
          // 2. 각 팀의 승패/점수/순위 초기화
          teams: g.teams.map(t => ({
            ...t,
            leagueStats: { win: 0, loss: 0, scoreWin: 0, scoreLoss: 0, rank: 0 }
          }))
        }));

        setGroups(newGroups);
        
        setTournamentData({ type: 'single', brackets: [] });
        
        setViewStates({
          0: { zoom: 0.85, pan: { x: 0, y: 0 } },
          1: { zoom: 0.85, pan: { x: 0, y: 0 } }
        });
        
        toast("경기 결과가 초기화되었습니다.");
      };
      
      // Tournament bracket builder (부전승 우선순위 준수 + 충돌 회피)
      const createBracket = (teamList) => {
        const n = teamList.length; if(n<2) return [];
        
        const power = Math.ceil(Math.log2(n)); 
        const totalSlots = Math.pow(2, power);

        // 시드 배정 순서 (Snake Order)
        const getSeedOrder = (slots) => {
          let seeds = [1];
          while (seeds.length < slots) {
            const next = []; const len = seeds.length*2+1;
            seeds.forEach(s => { next.push(s); next.push(len-s); }); seeds = next;
          }
          return seeds;
        };

        const seedOrder = getSeedOrder(totalSlots);
        let bracketSlots = new Array(totalSlots).fill(null);
        
        // 팀 배치: teamList는 이미 [1위 그룹 -> 2위 그룹...] 순서로 정렬됨
        // 따라서 앞쪽 인덱스(상위 시드)일수록 부전승(BYE)과 매칭될 확률이 높음 (Seed 1 vs Seed Last)
        teamList.forEach((t, i) => { bracketSlots[seedOrder.indexOf(i+1)] = t; });
        
        // 빈 자리는 BYE 처리 (최하위 시드 역할)
        bracketSlots = bracketSlots.map(s => s || { id: `bye-${Math.random()}`, name: 'BYE', isBye: true });

        // Helper
        const isConflict = (t1, t2) => {
          if (!t1 || !t2 || t1.isBye || t2.isBye) return false;
          return t1.groupId === t2.groupId;
        };
        const getR1OpponentIdx = (idx) => (idx % 2 === 0) ? idx + 1 : idx - 1;

        // =========================================================================
        // [Pass 1] Round 1 충돌 방지
        // 조건: 상위 시드는 고정, 하위 시드만 교체하되 **BYE는 절대 건드리지 않음**
        // =========================================================================
        for (let i = 0; i < totalSlots; i += 2) {
          const highSeed = bracketSlots[i];
          const lowSeed = bracketSlots[i+1];
          
          // 충돌 발생! (둘 다 BYE가 아니므로 lowSeed는 Real Team임)
          if (isConflict(highSeed, lowSeed)) {
            let swapped = false;

            // 다른 매치들의 하위 시드를 탐색
            for (let j = 0; j < totalSlots; j += 2) {
              if (i === j) continue;

              const targetLow = bracketSlots[j+1];
              const targetHigh = bracketSlots[j];
              
              // [최우선 규칙 보호]
              // 교체 대상(targetLow)이 BYE라면 절대 가져오지 않음.
              // 이유: targetLow가 BYE라는 것은 targetHigh가 상위 시드라 BYE를 받았다는 뜻임.
              // 이걸 가져오면 targetHigh는 BYE를 뺏기고, 내 highSeed(더 낮은 순위일 수 있음)가 BYE를 받게 됨.
              if (targetLow.isBye) continue;

              // 교체 안전 검사
              if (!isConflict(highSeed, targetLow) && !isConflict(targetHigh, lowSeed)) {
                // Swap
                bracketSlots[i+1] = targetLow;
                bracketSlots[j+1] = lowSeed;
                swapped = true;
                break;
              }
            }
          }
        }

        // =========================================================================
        // [Pass 2] Round 2 충돌 방지 (같은 조 1,2위 격돌 방지)
        // 조건: 매치 통째로 교체. (매치 내부의 Seed vs BYE 관계는 유지되므로 안전)
        // =========================================================================
        for (let q = 0; q < totalSlots; q += 4) {
          // Quad: Match A [q, q+1] vs Match B [q+2, q+3]
          const matchA_High = bracketSlots[q];
          const matchB_High = bracketSlots[q+2];

          if (isConflict(matchA_High, matchB_High)) {
            // 다른 Quad의 매치와 통교체 시도
            for (let k = 0; k < totalSlots; k += 4) {
              if (q === k) continue;

              // 후보 Quad의 첫 번째 매치 [k, k+1]의 상위 시드 확인
              const targetHigh = bracketSlots[k];
              
              // 교체 시 Match A와 충돌하지 않는지 확인
              if (!isConflict(matchA_High, targetHigh)) {
                 // 매치 B ([q+2, q+3]) <-> 후보 매치 ([k, k+1]) 통교체
                 const tempH = bracketSlots[q+2];
                 const tempL = bracketSlots[q+3];
                 
                 bracketSlots[q+2] = bracketSlots[k];
                 bracketSlots[q+3] = bracketSlots[k+1];
                 
                 bracketSlots[k] = tempH;
                 bracketSlots[k+1] = tempL;
                 break; 
              }
            }
          }
        }

        // 매치 객체 생성 (기존 유지)
        let round1 = [];
        for(let i=0; i<totalSlots/2; i++) {
          const tA = bracketSlots[i*2], tB = bracketSlots[i*2+1];
          let w = null; 
          if(tA.isBye && tB.isBye) w=tA; 
          else if(tA.isBye) w=tB; 
          else if(tB.isBye) w=tA;
          
          round1.push({ 
            id: `r0-${i}`, 
            nextMatchId: `r1-${Math.floor(i/2)}`, 
            teamA: tA, teamB: tB, 
            winner: w, scoreA:'', scoreB:'' 
          });
        }
        const rounds = [round1];

        while(rounds[rounds.length-1].length > 1) {
          const prev = rounds[rounds.length-1], next = [];
          for(let i=0; i<prev.length/2; i++) {
            const mId = `r${rounds.length}-${i}`;
            prev[i*2].nextMatchId = mId; prev[i*2+1].nextMatchId = mId;
            const tA = prev[i*2].winner;
            const tB = prev[i*2+1].winner;
            let w = null;
            if(tA && tA.isBye && tB && !tB.isBye) w=tB;
            if(tB && tB.isBye && tA && !tA.isBye) w=tA;
            if(tA && tA.isBye && tB && tB.isBye) w=tA;
            next.push({ id: mId, nextMatchId: (rounds.length+1 < power)?`r${rounds.length+1}-${Math.floor(i/2)}`:null, teamA: tA, teamB: tB, winner: w, scoreA:'', scoreB:'' });
          }
          rounds.push(next);
        }
        return rounds;
      };

        // [MODIFIED] Setup Modal 열기
        const prepareTournamentSetup = () => {
          // 기본 Validation
          if (groups.length === 0) return alert("조별 예선 데이터가 없습니다.");
          
        // 각 조를 순회하며 순위(rank)가 0이거나 없는 팀이 있는지 검사
        for (const group of groups) {
          const hasUnranked = group.teams.some(t => !t.leagueStats.rank || t.leagueStats.rank === 0);
          if (hasUnranked) {
            alert(`[${group.name}] 순위가 정해지지 않은 팀이 있습니다.\n각 조의 '순위 계산' 버튼을 눌러 순위를 확정해주세요.`);
            return; // 셋팅창 열지 않고 종료
          }
        }
        
        // 각 조를 순회하며 같은 순위를 가진 팀이 있는지 검사
        for (const group of groups) {
          const ranks = group.teams.map(t => t.leagueStats.rank);
          const uniqueRanks = new Set(ranks); // 중복 제거된 순위 집합
          
          // 원래 팀 수와 중복 제거된 순위 개수가 다르면 동순위가 있다는 뜻
          if (ranks.length !== uniqueRanks.size) {
            alert(`[${group.name}] 동순위(같은 등수) 팀이 존재합니다.\n규칙을 변경하거나 점수를 확인하여 동률을 해결해주세요.`);
            return; // 셋팅창 열지 않고 종료
          }
        }
        
          setShowSetupModal(true);
        };
        
      // [수정] 모달에서 확정된 데이터로 토너먼트 생성 및 무결성 검증
      const handleConfirmSetup = (setupResult) => {
        
        // 1. 대진 생성 헬퍼 함수 (순서 그대로 매핑)
        const buildRoundsFromOrderedTeams = (orderedTeams) => {
           let round1 = [];
           // orderedTeams 배열의 0,1번 -> 1경기, 2,3번 -> 2경기 ... 순서대로 매핑
           for(let i=0; i < orderedTeams.length/2; i++) {
             const tA = orderedTeams[i*2];
             const tB = orderedTeams[i*2 + 1];
             
             let w = null;
             // 둘 다 BYE면 앞쪽이 승, 하나만 BYE면 BYE 아닌 쪽이 승
             if(tA.isBye && tB.isBye) w = tA;
             else if(tA.isBye) w = tB;
             else if(tB.isBye) w = tA;
             
             round1.push({
               id: `r0-${i}`,
               nextMatchId: `r1-${Math.floor(i/2)}`,
               teamA: tA, 
               teamB: tB,
               winner: w, 
               scoreA: '', 
               scoreB: ''
             });
           }
           
           // 이후 라운드 구조 생성 (기존 로직 유지)
           const rounds = [round1];
           const power = Math.ceil(Math.log2(orderedTeams.length));
           
           while(rounds[rounds.length-1].length > 1) {
             const prev = rounds[rounds.length-1];
             const next = [];
             for(let i=0; i<prev.length/2; i++) {
               const mId = `r${rounds.length}-${i}`;
               prev[i*2].nextMatchId = mId; 
               prev[i*2+1].nextMatchId = mId;
               
               next.push({ 
                 id: mId, 
                 nextMatchId: (rounds.length+1 < power) ? `r${rounds.length+1}-${Math.floor(i/2)}` : null, 
                 teamA: null, teamB: null, winner: null, scoreA:'', scoreB:'' 
               });
             }
             rounds.push(next);
           }
           
           // 초기 BYE 승자 다음 라운드로 전파
           for(let r=0; r<rounds.length-1; r++) {
              rounds[r].forEach((m, idx) => {
                 if(m.winner) {
                    const nextM = rounds[r+1].find(nm => nm.id === m.nextMatchId);
                    if(nextM) {
                       if(idx % 2 === 0) nextM.teamA = m.winner;
                       else nextM.teamB = m.winner;
                       
                       // 연쇄 부전승 처리
                       if(nextM.teamA && nextM.teamA.isBye && nextM.teamB && !nextM.teamB.isBye) nextM.winner = nextM.teamB;
                       else if(nextM.teamB && nextM.teamB.isBye && nextM.teamA && !nextM.teamA.isBye) nextM.winner = nextM.teamA;
                       else if(nextM.teamA && nextM.teamA.isBye && nextM.teamB && nextM.teamB.isBye) nextM.winner = nextM.teamA;
                    }
                 }
              });
           }
           return rounds;
        };

        // [추가] 무결성 검증 함수: 셋팅 데이터(Source) vs 생성된 대진(Rounds) 비교
        const verifyIntegrity = (sourceList, generatedRounds, sectionTitle) => {
            const r1 = generatedRounds[0]; // 1라운드
            for(let i=0; i<r1.length; i++) {
                const match = r1[i];
                const expectedA = sourceList[i*2];
                const expectedB = sourceList[i*2+1];

                // ID 비교 (없으면 null 처리)
                const matchAId = match.teamA ? match.teamA.id : 'null';
                const matchBId = match.teamB ? match.teamB.id : 'null';
                const sourceAId = expectedA ? expectedA.id : 'null';
                const sourceBId = expectedB ? expectedB.id : 'null';

                if(matchAId !== sourceAId || matchBId !== sourceBId) {
                    alert(`⛔ [${sectionTitle}] 대진 불일치 감지!\n\n` +
                          `매치 ${i+1}번에서 데이터가 어긋났습니다.\n` +
                          `셋팅값: ${expectedA?.name} vs ${expectedB?.name}\n` +
                          `생성값: ${match.teamA?.name} vs ${match.teamB?.name}\n\n` +
                          `시스템 오류일 수 있으니 다시 시도해주세요.`);
                    return false; // 검증 실패
                }
            }
            return true; // 검증 통과
        };

        // --- 실행 및 검증 절차 ---
        const brackets = [];
        
        if (setupResult.upper) {
           const roundsUpper = buildRoundsFromOrderedTeams(setupResult.upper);
           // 검증 실행
           if (!verifyIntegrity(setupResult.upper, roundsUpper, '상위부')) return; 
           brackets.push({ title: config.tournamentMode==='split'?'(상위부)':'토너먼트', rounds: roundsUpper });
        }
        
        if (setupResult.lower) {
           const roundsLower = buildRoundsFromOrderedTeams(setupResult.lower);
           // 검증 실행
           if (!verifyIntegrity(setupResult.lower, roundsLower, '하위부')) return;
           brackets.push({ title: '(하위부)', rounds: roundsLower });
        }
        
        // 모든 검증 통과 시 데이터 반영
        setTournamentData({ type: config.tournamentMode==='split'?'split':'single', brackets });
        setShowSetupModal(false);
        setActiveTab('tournament');
        setViewStates({
          0: { zoom: 0.85, pan: { x: 0, y: 0 } },
          1: { zoom: 0.85, pan: { x: 0, y: 0 } }
        });
        setVisibleBracketIdx(0);
        
        toast('✅ 대진표가 정확하게 생성되었습니다.');
      };
      
      // [추가] 토너먼트 대진 데이터 초기화 (리셋) 함수
const clearTournamentData = () => {
  if (confirm("⚠️ 본선 토너먼트 대진을 초기화하시겠습니까?\n\n대진표가 화면에서 사라집니다.")) {
    // 토너먼트 데이터를 빈 상태로 초기화
    setTournamentData({ type: 'single', brackets: [] });
    // 화면 줌/위치도 초기값으로 복구
    setViewStates({
      0: { zoom: 0.85, pan: { x: 0, y: 0 } },
      1: { zoom: 0.85, pan: { x: 0, y: 0 } }
    });
    toast("토너먼트 대진이 초기화되었습니다.");
  }
};

      const openSwapModal = (bracketIdx, roundIdx, matchIdx, side) => setSwapModalData({ bracketIdx, roundIdx, matchIdx, side });

      const executeSwap = (tBIdx, tRIdx, tMIdx, tSide) => {
        const { bracketIdx: sB, roundIdx: sR, matchIdx: sM, side: sSide } = swapModalData;
        const newB = JSON.parse(JSON.stringify(tournamentData.brackets));
        const sMatch = newB[sB].rounds[sR][sM];
        const tMatch = newB[tBIdx].rounds[tRIdx][tMIdx];
        const sTeam = sSide==='teamA'?sMatch.teamA:sMatch.teamB;
        const tTeam = tSide==='teamA'?tMatch.teamA:tMatch.teamB;
        if(sSide==='teamA') sMatch.teamA=tTeam; else sMatch.teamB=tTeam;
        if(tSide==='teamA') tMatch.teamA=sTeam; else tMatch.teamB=sTeam;
        [sMatch, tMatch].forEach(m => {
          m.scoreA=''; m.scoreB=''; m.winner=null;
          if(m.teamA && m.teamA.isBye && m.teamB && !m.teamB.isBye) m.winner = m.teamB;
          else if(m.teamA && !m.teamA.isBye && m.teamB && m.teamB.isBye) m.winner = m.teamA;
        });
        setTournamentData({...tournamentData, brackets: newB});
        setSwapModalData(null);
      };

      const getAllTeams = () => {
        let list = [];
        tournamentData.brackets.forEach((b, bIdx) => {
          if(b.rounds[0]) b.rounds[0].forEach((m, mIdx) => {
            if(m.teamA) list.push({ team: m.teamA, bIdx, rIdx:0, mIdx, side: 'teamA', bTitle: b.title });
            if(m.teamB) list.push({ team: m.teamB, bIdx, rIdx:0, mIdx, side: 'teamB', bTitle: b.title });
          });
        });
        return list;
      };

      const handleScore = (bIdx, rIdx, mIdx, f, v) => {
        const newB = [...tournamentData.brackets];
        const m = newB[bIdx].rounds[rIdx][mIdx];
        m[f] = v;

        const sA = parseInt(m.scoreA), sB = parseInt(m.scoreB);
        m.winner = (!isNaN(sA) && !isNaN(sB)) ? (sA>sB?m.teamA:(sB>sA?m.teamB:null)) : null;

        if(m.nextMatchId) {
          const nextR = newB[bIdx].rounds[rIdx+1];
          const nextM = nextR.find(nm=>nm.id===m.nextMatchId);
          if(nextM) {
            if(mIdx % 2 === 0) nextM.teamA = m.winner;
            else nextM.teamB = m.winner;
            nextM.winner = null; nextM.scoreA = ''; nextM.scoreB = '';
          }
        }
        setTournamentData({...tournamentData, brackets: newB});
      };

      const handleManualWin = (bIdx, rIdx, mIdx, w) => {
        const newB = [...tournamentData.brackets];
        const m = newB[bIdx].rounds[rIdx][mIdx];
        m.winner = w;
        if(m.nextMatchId) {
          const nextR = newB[bIdx].rounds[rIdx+1];
          const nextM = nextR.find(nm=>nm.id===m.nextMatchId);
          if(nextM) {
            if(mIdx % 2 === 0) nextM.teamA = w;
            else nextM.teamB = w;
            nextM.winner = null; nextM.scoreA = ''; nextM.scoreB = '';
          }
        }
        setTournamentData({...tournamentData, brackets: newB});
      };
      
const handleJointWin = (bIdx, rIdx, mIdx) => {
  const newB = [...tournamentData.brackets];
  const match = newB[bIdx].rounds[rIdx][mIdx];
  
  // 1. 상태 토글
  match.isJointWinner = !match.isJointWinner;
  
  // 2. 공동 우승 활성화 시, 기존 단독 승자 정보는 초기화 (둘 다 하이라이팅 되도록)
  if (match.isJointWinner) {
    match.winner = null; 
  }
  
  setTournamentData({ ...tournamentData, brackets: newB });
};

      const openNewWindow = () => {
        const win = window.open('', '_blank');
        const content = document.getElementById('tournament-print-area').innerHTML;
        const styles = document.getElementsByTagName('style')[0].innerHTML;
        const tailwind = '<script src="https://cdn.tailwindcss.com"><\/script>';
        const isLight = document.body.classList.contains('light-mode');
        win.document.write(
          `<html><head><title>Tournament View</title>${tailwind}<style>${styles}
            body { padding: 40px; background-color: var(--bg-body); overflow: visible; color: var(--text-main); }
            .no-print { display: none !important; }
            .tournament-canvas { transform: none !important; }
            .tournament-viewport { overflow: visible !important; height: auto !important; background: none; }
          </style></head><body class="${isLight ? 'light-mode' : ''}">${content}</body></html>`
        );
        win.document.close();
      };

      // Save/Load data (file-based)
      const dataFileInputRef = useRef(null);

      const saveDataAsFile = () => {
        try {
          const defaultName = `pingpong_manager_${new Date().toISOString().slice(0,10)}.json`;
          let fileName = prompt('저장할 파일 이름을 입력하세요.', defaultName);
          if (!fileName) return;
          if (!fileName.toLowerCase().endsWith('.json')) fileName += '.json';

          const payload = {
            version: 1,
            app: 'Table Tennis League Manager',
            exportedAt: new Date().toISOString(),
            data: {
              teams, groups, tournamentData, config, isLeagueGenerated, cardSizes, isDarkMode, themeOverrides,
              // 파일 저장시에도 UI 상태 포함
              activeTab, sortMode, viewStates
            }
          };
          // ... (이하 blob 생성 및 다운로드 코드는 기존과 동일) ...
          const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = fileName;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
          toast('파일로 저장했습니다.');
        } catch (e) { toast('저장에 실패했습니다.'); }
      };
      
      const loadDataFromFile = (file) => {
        try {
          const reader = new FileReader();
          reader.onload = () => {
            try {
              const parsed = JSON.parse(reader.result);
              const d = parsed?.data ?? parsed;
              if (!d || typeof d !== 'object') { toast('올바른 데이터 파일이 아닙니다.'); return; }

              if (Array.isArray(d.teams)) setTeams(d.teams);
              if (Array.isArray(d.groups)) setGroups(d.groups);
              if (d.tournamentData) setTournamentData(d.tournamentData);
              if (d.config) setConfig(d.config);
              if (typeof d.isLeagueGenerated === 'boolean') setIsLeagueGenerated(d.isLeagueGenerated);
              if (d.cardSizes) setCardSizes(d.cardSizes);
              if (typeof d.isDarkMode === 'boolean') setIsDarkMode(d.isDarkMode);
              if (d.themeOverrides) setThemeOverrides(d.themeOverrides);

              // 추가된 항목 복원
              if (d.activeTab) setActiveTab(d.activeTab);
              if (d.sortMode) setSortMode(d.sortMode);
              if (d.viewStates) setViewStates(d.viewStates);

              toast('파일에서 데이터를 불러왔습니다.');
            } catch (e) { toast('파일 해석에 실패했습니다.'); }
          };
          reader.readAsText(file, 'utf-8');
        } catch (e) { toast('불러오기에 실패했습니다.'); }
      };

      // Tournament pan/zoom
      const handleMouseDown = (e) => { if(activeTab!=='tournament') return; setIsDragging(true); dragStart.current = { x: e.clientX - currentView.pan.x, y: e.clientY - currentView.pan.y }; };
      const handleMouseMove = (e) => { if (!isDragging) return; e.preventDefault(); updateCurrentPan({ x: e.clientX - dragStart.current.x, y: e.clientY - dragStart.current.y }); };
      const handleMouseUp = () => setIsDragging(false);

      const handleTouchStart = (e) => {
        if(activeTab!=='tournament') return;
        setIsDragging(true);
        const touch = e.touches[0]; // 첫 번째 터치 지점 인식
        dragStart.current = { x: touch.clientX - currentView.pan.x, y: touch.clientY - currentView.pan.y };
      };
      
      const handleTouchMove = (e) => {
        if (!isDragging) return;
        // e.preventDefault(); // 필요 시 주석 해제 (브라우저 스크롤 방지)
        const touch = e.touches[0];
        updateCurrentPan({ x: touch.clientX - dragStart.current.x, y: touch.clientY - dragStart.current.y });
      };
      
      const displayedTeams = useMemo(() => {
        const s = [...teams];
        if(sortMode==='level') return s.sort((a,b)=>a.totalLevel-b.totalLevel);
        if (sortMode === 'affiliation') return s.sort((a, b) => (a.affiliation || '').localeCompare(b.affiliation || ''));
        
        // [수정] 조별 정렬 로직 변경: 1순위 조(오름차순) + 2순위 합부수(오름차순/작은수부터)
        if(sortMode==='group') {
          return s.sort((a,b) => {
            // 미배정(null)은 가장 뒤(9999)로 보냄
            const groupA = a.groupId === null ? 9999 : a.groupId;
            const groupB = b.groupId === null ? 9999 : b.groupId;
            
            // 1. 조 번호가 다르면 조 번호 순서대로 정렬
            if (groupA !== groupB) return groupA - groupB;
            
            // 2. 조 번호가 같으면 합부수(totalLevel) 작은 순서대로 정렬
            return a.totalLevel - b.totalLevel;
          });
        }

        return s.sort((a,b)=>a.id-b.id);
      }, [teams, sortMode]);

      const cycleSort = () => setSortMode(prev => 
        prev === 'input' ? 'level' : 
        prev === 'level' ? 'affiliation' : // [추가] level 다음은 affiliation
        prev === 'affiliation' ? 'group' : // [추가] affiliation 다음은 group
        'input'
      );

      // getSortLabel 함수 수정
      const getSortLabel = () => 
        sortMode === 'input' ? '등록순' : 
        sortMode === 'level' ? '합부수순' : 
        sortMode === 'affiliation' ? '소속순' : // [추가] 라벨 반환
        '조별순';

      const getHighlight = (gId, rId, cId) => (!hoverState || hoverState.g !== gId) ? '' : (hoverState.r === rId && hoverState.c === cId) ? 'highlight-active' : (hoverState.r === cId && hoverState.c === rId) ? 'highlight-mirror' : '';

      const getHeaderHighlight = (gId, tId) => {
        if (!hoverState || hoverState.g !== gId) return '';
        if (hoverState.c === tId) return 'highlight-header';
        if (hoverState.r === tId || hoverState.c === tId) return 'highlight-header';
        return '';
      };

      const renderTab = (id, l, I) => {
        const active = activeTab===id;
        return (
          <button
            onClick={()=>setActiveTab(id)}
            className="tab-btn flex items-center gap-2 px-6 py-3 font-medium text-sm transition-all no-print"
            style={{
              borderColor: active ? 'var(--tab-active-border)' : 'transparent',
              color: active ? 'var(--tab-active-text)' : 'var(--tab-inactive-text)',
              backgroundColor: active ? 'var(--tab-active-bg)' : 'transparent'
            }}
          >
            <I size={18}/> {l}
          </button>
        );
      };

      const handlePrint = (groupId) => {
        if (groupId !== null && groupId !== undefined) {
          setPrintGroupId(groupId); document.body.classList.add('printing-single');
          setTimeout(() => { window.print(); document.body.classList.remove('printing-single'); setPrintGroupId(null); }, 100);
        } else { window.print(); }
      };

// [수정] 토너먼트 승리 처리 함수 (MatchNode에서 호출)
const handleTournamentWin = (bIdx, rIdx, mIdx, winnerTeam) => {
  // 1. 상태 복제
  const newBrackets = [...tournamentData.brackets];
  const currentMatch = newBrackets[bIdx].rounds[rIdx][mIdx];
  
  // 2. 승자 업데이트
  currentMatch.winner = winnerTeam;
  
  // 팀을 선택했으므로 공동우승 상태는 무조건 해제
  currentMatch.isJointWinner = false;
  
  // 3. 다음 라운드 진출 처리
  if (currentMatch.nextMatchId) {
    const nextRound = newBrackets[bIdx].rounds[rIdx + 1];
    const nextMatch = nextRound.find(m => m.id === currentMatch.nextMatchId);
    
    if (nextMatch) {
      // 짝수 인덱스는 TeamA(위/왼쪽), 홀수는 TeamB(아래/오른쪽) 자리로 진출
      if (mIdx % 2 === 0) {
        nextMatch.teamA = winnerTeam;
      } else {
        nextMatch.teamB = winnerTeam;
      }
      
      // [중요] 기존 승자/점수 초기화 (새로운 팀이 올라왔으므로)
      nextMatch.winner = null;
      nextMatch.scoreA = '';
      nextMatch.scoreB = '';
      
      // [자동 진출 로직] 상대가 BYE라면 자동 승리 처리 (재귀적 호출 가능성 고려)
      const opponent = (mIdx % 2 === 0) ? nextMatch.teamB : nextMatch.teamA;
      if (opponent && opponent.isBye) {
         nextMatch.winner = winnerTeam;
         // 재귀적으로 그 다음 라운드도 처리하려면 로직 추가 필요하지만, 
         // UI 클릭 기반이므로 일단 여기까지 업데이트 후 렌더링
      }
    }
  }
  
  setTournamentData({ ...tournamentData, brackets: newBrackets });
};

      return (
        <div className="flex flex-col h-screen overflow-hidden">
<header className="backdrop-blur-md border-b flex-none z-30 shadow-lg no-print"
  style={{ backgroundColor:'var(--table-header-bg)', borderColor:'var(--table-border)' }}>
  
  {/* 상단 1행: 로고 및 전역 설정 */}
  <div className="w-full max-w-[98%] mx-auto px-4 py-2 flex flex-wrap items-center justify-between gap-2">
    <div className="flex items-center gap-3">
      <div className="w-10 h-10 rounded-xl font-bold flex items-center justify-center shadow-lg transform rotate-3 brand-logo"></div>
      <h1 className="text-xl font-bold tracking-tight bg-clip-text text-transparent drop-shadow-sm brand-title">
        탁구 리그전 관리
        <span className="text-xs font-medium tracking-normal ml-1 border rounded px-1"
          style={{ borderColor:'var(--table-border)', color:'var(--text-muted)' }}>
          v1.0
        </span>
      </h1>
    </div>

    <div className="flex gap-2 items-center ml-auto">
      {/* [수정됨] 테마 관리(드롭다운) 버튼 제거 -> 단순 모드 전환 버튼만 유지 */}
      <div className="relative">
        <div className="flex items-center">
          <Button variant="secondary" onClick={()=>setIsDarkMode(!isDarkMode)} title="테마 전환">
            {isDarkMode ? <Icons.Sun size={16}/> : <Icons.Moon size={16}/>}
          </Button>
          {/* 여기에 있던 화살표 버튼과 드롭다운 메뉴 코드를 제거했습니다. */}
        </div>
      </div>

      <div className="w-px h-8 mx-2 self-center divider"></div>
      
      <Button variant="secondary" onClick={()=>dataFileInputRef.current?.click()} title="파일 불러오기"><Icons.Upload size={16}/></Button>
      <Button variant="primary" onClick={saveDataAsFile} title="파일로 저장"><Icons.Save size={16}/></Button>
      <button onClick={()=>setIsAdminMode(!isAdminMode)} className="p-2 rounded border" style={{ borderColor: 'var(--table-border)', backgroundColor: isAdminMode ? 'var(--highlight-bg)' : 'var(--table-cell-border)', color: isAdminMode ? 'var(--accent)' : 'var(--text-muted)' }} title="관리자 모드">
        {isAdminMode ? <Icons.Unlock size={20}/> : <Icons.Lock size={20}/>}
      </button>
    </div>
  </div>

  {/* 상단 2행: 탭 메뉴 + 리그 툴바 (기존 코드 유지) */}
  <div className="w-full max-w-[98%] mx-auto px-4 py-1 flex flex-wrap items-center gap-y-2 border-t border-slate-700/30 lg:border-none">
    <div className="flex mr-4">
      {renderTab('register','참가 등록',Icons.Users)}
      {renderTab('league','예선 리그',Icons.List)}
      {renderTab('tournament','본선 토너먼트',Icons.Trophy)}
    </div>
    
    {/* ... (이하 탭별 툴바 내용은 기존과 동일하므로 생략 가능) ... */}
    {activeTab === 'tournament' && tournamentData.brackets.length > 0 && (
       // ... (기존 토너먼트 툴바 코드 유지)
       <div className="flex items-center gap-3 animate-in fade-in slide-in-from-left-4 duration-300 ml-4">
          {/* ... */}
           {/* 여기에 있던 Zoom Controls 등 기존 로직 그대로 유지 */}
           {tournamentData.type === 'split' && (
            <>
              <div className="w-px h-6 bg-slate-500/30 mx-2"></div>
              <div className="flex rounded-lg p-0.5 border" style={{borderColor:'var(--table-border)', background:'var(--input-bg)'}}>
                <button onClick={()=>setVisibleBracketIdx(0)} className={`px-3 py-1 rounded text-xs font-bold transition-all`} style={{background: visibleBracketIdx===0 ? 'var(--accent)' : 'transparent', color: visibleBracketIdx===0 ? '#ffffff' : 'var(--text-muted)'}}>상위부</button>
                <button onClick={()=>setVisibleBracketIdx(1)} className={`px-3 py-1 rounded text-xs font-bold transition-all`} style={{background: visibleBracketIdx===1 ? 'var(--accent-2)' : 'transparent', color: visibleBracketIdx===1 ? '#ffffff' : 'var(--text-muted)'}}>하위부</button>
              </div>
            </>
          )}
          <div className="w-px h-6 bg-slate-500/30 mx-2"></div>
          <div className="flex items-center gap-1 bg-slate-500/10 p-1 rounded-lg border border-slate-500/20">
             <button onClick={() => updateCurrentZoom(z => z + 0.1)} title="확대" className="h-7 w-7 flex items-center justify-center rounded border shadow-sm transition-all hover:brightness-95 active:scale-95" style={{ background: 'var(--card-bg)', borderColor: 'var(--table-border)', color: 'var(--accent)' }}><Icons.ZoomIn size={14}/></button>
             <button onClick={() => updateCurrentZoom(z => z - 0.1)} title="축소" className="h-7 w-7 flex items-center justify-center rounded border shadow-sm transition-all hover:brightness-95 active:scale-95" style={{ background: 'var(--card-bg)', borderColor: 'var(--table-border)', color: 'var(--text-main)' }}><Icons.ZoomOut size={14}/></button>
             <div className="w-px h-3 bg-slate-500/30 mx-1"></div>
             <button onClick={() => { updateCurrentZoom(0.85); updateCurrentPan({x:0, y:0}); }} title="화면 맞춤" className="h-7 w-7 flex items-center justify-center rounded border shadow-sm transition-all hover:brightness-95 active:scale-95" style={{ background: 'var(--card-bg)', borderColor: 'var(--table-border)', color: 'var(--text-muted)' }}><Icons.Refresh size={14}/></button>
          </div>
          {/* 리셋 버튼 */}
          <div className="w-px h-6 bg-slate-500/30 mx-1"></div>
          <button 
            onClick={clearTournamentData} 
            title="대진 초기화 (대진화면 전체 지우기)" 
            className="h-7 px-2 flex items-center justify-center gap-1 rounded border shadow-sm transition-all hover:bg-red-500/10 hover:border-red-500/30 hover:text-red-500 active:scale-95"
            style={{ background: 'var(--card-bg)', borderColor: 'var(--table-border)', color: 'var(--text-muted)' }}
          >
            <Icons.Trash size={12}/>
            <span className="text-xs font-bold">초기화</span>
          </button>
       </div>
    )}

    {activeTab === 'league' && (
      // ... (기존 리그 툴바 코드 유지)
      <div className="flex items-center gap-4 animate-in fade-in slide-in-from-left-4 duration-300">
         {/* ... */}
         <div className="w-px h-6 bg-slate-500/30 mx-2"></div>
         <div className="flex items-center gap-3 bg-slate-500/10 px-3 py-1 rounded-lg border border-slate-500/20">
            <div className="flex items-center gap-2">
              <span className="font-bold text-xs" style={{color:'var(--accent)'}}>본선:</span>
              <select className="rounded px-2 py-1 text-xs outline-none" style={{background:'var(--select-bg)', color:'var(--select-text)', border:'1px solid var(--table-border)'}} value={config.tournamentMode} onChange={(e)=>setConfig({...config,tournamentMode:e.target.value})}>
                <option value="all">전체</option>
                <option value="topN">상위부</option>
                <option value="split">상하위</option>
              </select>
              {(config.tournamentMode!=='all') && (
                <div className="flex items-center text-xs gap-1">
                  <span style={{color:'var(--text-muted)'}}>N=</span>
                  <input type="number" min="1" max="12" className="w-10 text-center rounded p-0.5 outline-none" style={{backgroundColor:'var(--input-bg)', color:'var(--text-main)', border:`1px solid var(--table-border)`}} value={config.topN} onChange={(e)=>setConfig({...config,topN:Math.min(12, Math.max(1, parseInt(e.target.value)))})}/>
                </div>
              )}
            </div>
            <div className="w-px h-3 bg-slate-500/30"></div>
            <div className="flex items-center gap-2">
              <span className="font-bold text-xs" style={{color:'var(--text-muted)'}}>순위:</span>
              <select 
                className="rounded px-2 py-1 text-xs outline-none" 
                style={{background:'var(--select-bg)', color:'var(--select-text)', border:'1px solid var(--table-border)'}} 
                value={config.rankMethod} 
                onChange={(e)=>{
                    const rm = e.target.value; 
                    setConfig(prev => ({...prev, rankMethod: rm})); 
                    recalcAllGroupRanks(rm);
                }}
              >
                {/* [수정] 옵션을 2가지로 간소화 */}
                <option value="WIN_PRIORITY">승패</option>
                <option value="SCORE_PRIORITY">득실</option>
              </select>
            </div>
         </div>
         <div className="flex gap-2 items-center">
            {isAdminMode && (
              <Button variant="magic" onClick={generateAutoLeagueResults} className="text-xs py-1 px-3 h-8" title="결과 자동 입력">
                <Icons.Wand size={14}/> <span className="hidden xl:inline">자동입력</span>
              </Button>
            )}
            <Button onClick={prepareTournamentSetup} className="text-xs py-1 px-3 h-8 shadow-lg shadow-blue-500/20">
                <Icons.ChevronRight size={14}/> <span className="font-bold">토너먼트 생성</span>
            </Button>
            <div className="w-px h-6 bg-slate-500/30 mx-1"></div>
            <Button 
                variant="danger" 
                onClick={handleResetLeagueResults} 
                className="text-xs py-1 px-3 h-8" 
                title="모든 경기 결과 삭제"
            >
                <Icons.Trash size={14}/> 
                <span className="hidden xl:inline font-bold">결과 초기화</span>
            </Button>
         </div>
      </div>
    )}
  </div>
</header>
          <main className="flex-grow w-full relative overflow-hidden" style={{backgroundColor:'var(--bg-body)'}}>
            {activeTab !== 'tournament' ? (
              <div className="h-full overflow-y-auto p-6">
                
                {/* [등록 탭] (기존 유지) */}
                {activeTab === 'register' && (
                  <div className="grid lg:grid-cols-3 gap-6 max-w-[98%] mx-auto">
                    {/* ... (등록 탭 내부 코드는 기존과 동일하므로 생략) ... */}
                    {/* (기존 코드의 register 부분 그대로 사용하세요) */}
                    <div className="lg:col-span-1 space-y-6">
                      <Card>
                        <h3 className="font-bold mb-4 flex items-center gap-2 text-lg" style={{color:'var(--text-main)'}}>
                          <span style={{color:'var(--accent-strong)'}}><Icons.Settings size={20}/></span>
                          대회 설정
                        </h3>
                        <div className="space-y-4">
                          <div>
                            <label className="block text-sm font-medium mb-1" style={{color:'var(--text-muted)'}}>경기 방식</label>
                            <select className="w-full p-2 rounded-lg focus:ring-2 focus:ring-sky-500"
                              value={config.teamSize}
                              onChange={(e)=>setConfig({...config,teamSize:parseInt(e.target.value)})}>
                              {[1,2,3,4,5,6].map(n=><option key={n} value={n}>{n===1 ? '개인 단식' : `${n}인 단체전`}</option>)}
                            </select>
                          </div>
                          <div>
                            <label className="block text-sm font-medium mb-1" style={{color:'var(--text-muted)'}}>합부수 최소</label>
                            <Input type="number" min="0" value={config.minSumLevel} placeholder="없음"
                              onChange={(e)=>setConfig({...config,minSumLevel:e.target.value})}/>
                          </div>
                        </div>
                      </Card>
                      <Card>
                        <h3 className="font-bold mb-4 text-lg" style={{color:'var(--text-main)'}}>팀 등록</h3>
                        <div className="space-y-3">
                          <Input placeholder="팀 이름 (자동)" value={newTeamName} onChange={(e)=>setNewTeamName(e.target.value)}/>
                            <Input placeholder="소속 (예: 이성숙, ...)" value={newAffiliation} onChange={(e)=>setNewAffiliation(e.target.value)} list="affiliation-options" />
                            <datalist id="affiliation-options">{AFFILIATION_LIST.map(aff => <option key={aff} value={aff} />)}</datalist>
                          {newMembers.map((m,i)=>(
                            <div key={i} className="flex gap-2">
                              <Input placeholder={`팀원${i+1} 이름`} value={m.name} onChange={(e)=>handleMemberChange(i,'name',e.target.value)}/>
                              <Input type="number" className="w-20" placeholder="부수" value={m.level} onChange={(e)=>handleMemberChange(i,'level',e.target.value)}/>
                            </div>
                          ))}
                          <Button onClick={addTeam} className="w-full mt-2"><Icons.Plus/> 등록</Button>
                          {isAdminMode && (
                            <div className="flex gap-2 mt-2">
                              <input type="number" className="w-16 text-center rounded-lg"
                                style={{backgroundColor:'var(--input-bg)', color:'var(--text-main)', border:`1px solid var(--table-border)`}}
                                value={autoGenCount} onChange={(e)=>setAutoGenCount(e.target.value)}/>
                              <Button onClick={generateRandomTeams} variant="magic" className="flex-1"><Icons.Wand/> 자동 생성</Button>
                            </div>
                          )}
                        </div>
                      </Card>
                      <div className="pt-4 border-t" style={{borderColor:'var(--table-border)'}}>
                        <div className="flex items-center gap-2 mb-4">
                          <span className="text-sm font-bold" style={{color:'var(--text-muted)'}}>조 개수:</span>
                          <Input type="number" className="w-20" value={config.groupCount} onChange={(e)=>setConfig({...config,groupCount:parseInt(e.target.value)})}/>
                        </div>
                        <Button variant="secondary" className="w-full" onClick={generateGroups}>리그 대진표 생성 <Icons.ChevronRight/></Button>
                      </div>
                    </div>
                    <div className="lg:col-span-2">
                      <div className="flex justify-between mb-4 items-center">
                        <h3 className="font-bold text-lg" style={{color:'var(--text-main)'}}>팀 목록 ({teams.length})</h3>
                        <div className="flex gap-2 items-center">
				    {/* [수정 시작] 정렬 버튼 그룹: 각 속성별로 개별 버튼 생성 */}
				    <div className="flex items-center p-1 rounded-lg border gap-0.5" 
				         style={{borderColor:'var(--table-border)', background:'var(--input-bg)'}}>
				      {[
				        { id: 'input', label: '등록순', icon: Icons.SortDesc },
				        { id: 'level', label: '합부수', icon: Icons.SortAsc },
				        { id: 'affiliation', label: '소속', icon: Icons.SortAsc },
				        { id: 'group', label: '조별', icon: Icons.SortGroup }
				      ].map((mode) => {
				        const isActive = sortMode === mode.id;
				        return (
				          <button
				            key={mode.id}
				            onClick={() => setSortMode(mode.id)}
				            className={`flex items-center gap-1 px-2 py-1.5 text-xs rounded transition-all ${isActive ? 'font-bold shadow-sm' : 'opacity-60 hover:opacity-100'}`}
				            style={{
				              backgroundColor: isActive ? 'var(--accent)' : 'transparent',
				              color: isActive ? '#ffffff' : 'var(--text-muted)'
				            }}
				            title={`${mode.label}으로 정렬`}
				          >
				            <mode.icon size={12} />
				            <span className="hidden sm:inline">{mode.label}</span>
				          </button>
				        );
				      })}
				    </div>
				    {/* [수정 끝] */}

				    <Button onClick={clearAllTeams} variant="danger" className="text-xs px-3 py-1.5">
				      <Icons.Trash size={12} className="mr-1"/> 초기화
				    </Button>
                        </div>
                      </div>
                      <div className="rounded-xl shadow-lg border overflow-hidden" style={{backgroundColor:'var(--card-bg)', borderColor:'var(--card-border)'}}>
                        <div className="overflow-x-auto">
                           {/* (팀 테이블 내용 생략 - 기존과 동일) */}
                           <table className="w-full text-sm text-left modern-table table-auto">
                            <thead>
                              <tr>
                                <th className="px-4 py-3 font-bold">No.</th>
                                <th className="px-4 font-bold">팀명</th>
                                <th className="px-4 font-bold">소속</th>
                                <th className="px-4 font-bold">구성원</th>
                                <th className="px-4 text-center font-bold">합부수</th>
                                {isLeagueGenerated && <th className="px-4 text-center font-bold">배정된 조</th>}
                                <th className="px-4 text-right font-bold">관리</th>
                              </tr>
                            </thead>
					<tbody>
					  {teams.length === 0 ? (
					    <tr><td colSpan="6" className="text-center py-8" style={{color:'var(--text-muted)'}}>등록된 팀이 없습니다.</td></tr>
					  ) : displayedTeams.map((t, i) => {
					    
					    const isOddGroupRow = sortMode === 'group' && t.groupId !== null && (t.groupId % 2 === 0);

					    return (
					      <tr key={t.id} 
					          className={`team-row ${editingTeamId === t.id ? 'editing' : ''} ${isOddGroupRow ? 'group-odd' : ''}`}
					      >
					        {/* ... (이하 td 내용들은 기존과 동일) ... */}
					        <td className="px-4 py-2 text-center font-medium" style={{color:'var(--text-muted)'}}>{i+1}</td>
					        <td className="px-4 font-medium" style={{color:'var(--text-main)'}}>
					          {editingTeamId === t.id
					            ? <input className="p-1 w-full rounded" style={{background:'var(--input-bg)', border:`1px solid var(--table-border)`, color:'var(--text-main)'}} value={editTeamData.name} onChange={(e)=>handleEditChange('name',e.target.value)}/>
					            : t.name}
					        </td>
					        {/* ... 나머지 td 태그들은 그대로 두세요 ... */}
					        <td className="px-4 text-center">
					            {editingTeamId===t.id ? (
					               <input className="p-1 w-full rounded text-center" style={{background:'var(--input-bg)', border:`1px solid var(--table-border)`, color:'var(--text-main)'}} value={editTeamData.affiliation || ''} onChange={(e)=>handleEditChange('affiliation',e.target.value)}/>
					            ) : (
					               <span className="tag" style={{backgroundColor: t.affiliation ? 'var(--tag-bg)' : 'transparent', border: t.affiliation ? '1px solid var(--tag-border)' : 'none'}}>{t.affiliation || '-'}</span>
					            )}
					        </td>
					        <td className="px-4" style={{color:'var(--text-muted)'}}>
					          {editingTeamId===t.id
					            ? editTeamData.members.map((m,mi)=>(
					              <div key={mi} className="flex gap-1 mb-1">
					                <input className="w-16 p-1 rounded" style={{background:'var(--input-bg)', border:`1px solid var(--table-border)`, color:'var(--text-main)'}} value={m.name} onChange={(e)=>handleEditChange(null,e.target.value,mi,'name')}/>
					                <input className="w-10 p-1 rounded" style={{background:'var(--input-bg)', border:`1px solid var(--table-border)`, color:'var(--text-main)'}} value={m.level} onChange={(e)=>handleEditChange(null,e.target.value,mi,'level')}/>
					              </div>
					            ))
					            : t.members.map(m=>`${m.name}(${m.level})`).join(', ')}
					        </td>
					        <td className="px-4 text-center font-bold" style={{color:'var(--text-main)'}}>{t.totalLevel}</td>
					        {isLeagueGenerated && (
					          <td className="px-4 text-center">
					            <select className="rounded p-1 text-xs" value={t.groupId===null?'':t.groupId} onChange={(e)=>handleGroupChange(t.id,e.target.value)}>
					              <option value="" disabled>미배정</option>
					              {Array.from({length:config.groupCount},(_,k)=><option key={k} value={k}>{k+1}조</option>)}
					            </select>
					          </td>
					        )}
					        <td className="px-4 text-right">
					          {editingTeamId===t.id ? (
					            <div className="flex justify-end gap-1">
					              <button onClick={saveEditing} className="p-1 rounded border" style={{background:'rgba(20,83,45,0.35)', borderColor:'rgba(34,197,94,0.35)', color:'#86efac'}}><Icons.Check/></button>
					              <button onClick={cancelEditing} className="p-1 rounded border" style={{background:'var(--btn-secondary-bg)', borderColor:'var(--btn-secondary-border)', color:'var(--btn-secondary-text)'}}><Icons.X/></button>
					            </div>
					          ) : (
					            <div className="flex justify-end gap-1">
					              <button onClick={()=>startEditing(t)} className="p-1 rounded border" style={{background:'transparent', borderColor:'transparent', color:'var(--text-muted)'}} title="편집"><Icons.Edit/></button>
					              <button onClick={()=>removeTeam(t.id)} className="p-1 rounded border" style={{background:'transparent', borderColor:'transparent', color:'var(--text-muted)'}} title="삭제"><Icons.Trash/></button>
					            </div>
					          )}
					        </td>
					      </tr>
					    );
					  })}
					</tbody>
                          </table>
                        </div>
                      </div>
                    </div>
                  </div>
                )}

                {/* [수정됨] 예선 리그 탭 Main 영역: 툴바 div 제거됨 */}
                {activeTab === 'league' && (
                  <div className="h-full max-w-[98%] mx-auto mt-4"> 
                    {/* 상단 툴바가 Header로 이동했으므로 여기서는 삭제하고 바로 테이블 컨테이너 표시 */}
                    
                    <div className="flex flex-wrap gap-6 pb-20 justify-start items-start flex-wrap-container">
                      {groups.map(g => (
                        <div key={g.id} className={`print-page-wrapper ${printGroupId===g.id?'target-print':''}`}>
                          <ResizableCard
                            id={g.id}
                            width={cardSizes[g.id]?.w||480}
                            height={cardSizes[g.id]?.h||450}
                            onResize={(id,w,h)=>setCardSizes(p=>({...p,[id]:{w,h}}))}
                            className="print-card"
                          >
                            <div className="flex justify-between items-center w-full">
                              <h3 className="font-bold" style={{color:'var(--text-main)'}}>{g.name}</h3>
                              <div className="flex gap-1 no-print">
                                <button onClick={()=>handlePrint(g.id)} className="mini-btn" title="이 조만 인쇄"><Icons.Printer size={14}/></button>
                                <button onClick={()=>calculateRank(g.id)} className="text-[10px] px-2 py-1 rounded font-bold rank-btn">순위 계산</button>
                              </div>
                            </div>

                            <div className="w-full h-full p-0 flex flex-col">
                              <div className="flex-grow custom-scrollbar" style={{ overflow: 'auto' }}>
                                <table className="modern-table table-auto">
						<thead>
						  <tr>
						    {/* 좌측 상단 모서리 */}
						    <th className="team-name-col" style={{width:'100px', whiteSpace:'nowrap'}}>팀명</th>

						    {/* [수정] 상단 팀명 리스트 루프 */}
						    {g.teams.map((t, ti) => (
						      <th key={t.id}
						          className={`${getHeaderHighlight(g.id,t.id)}`}
						          style={{
						            minWidth: '90px',        // 내용 표시를 위해 너비 확대
						            padding: '4px 6px',      // 패딩 조정
						            verticalAlign: 'middle'
						          }}>
						        
						        {/* 좌측 열(member-cell)과 동일한 구조 적용 */}
						        <div className="flex items-center justify-center">
						          <div className="flex items-center gap-1.5">
						            {/* 순번 */}
						            <span className="font-bold text-xs" style={{color:'var(--text-main)'}}>{ti+1} </span>
						            
						            {/* 팀원 수에 따른 표시 로직 (좌측과 동일) */}
						            {t.members.length >= 3 ? (
						              // 3인 이상: 팀명 표시
						              <div className="font-bold text-sm whitespace-nowrap" style={{color:'var(--text-main)'}}>
						                {getLeagueDisplayName(t)}
						              </div>
						            ) : (
						              // 1~2인: 이름(부수) 나열
						              <div className="flex flex-col text-left leading-tight">
						                {t.members.map((m, k) => (
						                  <div key={k} className="whitespace-nowrap text-xs">
						                    <span style={{color:'var(--text-main)', fontWeight:'600'}}>{m.name}</span>
						                    <span className="text-[0.85em] ml-0.5" style={{color:'var(--text-muted)', fontWeight:'normal'}}>({m.level})</span>
						                  </div>
						                ))}
						              </div>
						            )}
						          </div>
						        </div>
						      </th>
						    ))}

						    {/* [수정] 통계 헤더들의 minWidth를 제거하거나 늘리고 nowrap 유지 */}
						    <th className="stat-col" style={{ whiteSpace: 'nowrap', padding: '0 8px' }}>승/패</th>
						    <th className="stat-col" style={{ whiteSpace: 'nowrap', padding: '0 8px' }}>득/실</th>
						    <th className="stat-col" style={{ whiteSpace: 'nowrap', padding: '0 8px' }}>순위</th>
						  </tr>
						</thead>

						<tbody>
						  {g.teams.map((r, ri) => {
						    // 값이 모두 0인지 확인 (표시용)
						    const isAllZero = (r.leagueStats.win === 0 && r.leagueStats.loss === 0 && r.leagueStats.scoreWin === 0 && r.leagueStats.scoreLoss === 0);
						    const isRanked = g.teams.some(t => t.leagueStats.rank > 0);
						    const isQualified = isRanked
						      ? (r.leagueStats.rank > 0 && r.leagueStats.rank <= config.topN)
						      : (ri < config.topN);

						    const qualifyStyle = (isQualified && config.tournamentMode !== 'all')
						      ? { backgroundColor: 'var(--qualified-row-bg)' }
						      : undefined;

						    const qualifyClass = (isQualified && config.tournamentMode !== 'all') ? 'print-highlight' : '';

						    return (
						      <tr key={r.id} className={qualifyClass} style={qualifyStyle}>
						        {/* 1. 팀명/순번 셀 (기존 동일) */}
						        <td className={`member-cell font-semibold border-r ${getHeaderHighlight(g.id,r.id)}`} style={{borderColor:'var(--table-cell-border)'}}>
						          <div className="flex items-center cursor-help" title={r.affiliation ? `소속: ${r.affiliation}` : undefined}>
						            <span className="font-bold mr-2 text-xs" style={{color:'var(--text-main)'}}>{ri+1} </span>
						            {r.members.length >= 3 ? (
						              <div className="font-bold text-sm whitespace-nowrap" style={{color:'var(--text-main)'}}>{getLeagueDisplayName(r)}</div>
						            ) : (
						              <div className="flex flex-col">
						                {r.members.map((m, k)=>(<div key={k} className="whitespace-nowrap text-xs">{m.name} <span className="text-[0.7em]" style={{color:'var(--text-muted)'}}>({m.level})</span></div>))}
						              </div>
						            )}
						          </div>
						        </td>

						        {/* 2. 매트릭스 입력 셀 (기존 동일) */}
						        {g.teams.map(c => {
						          if(r.id===c.id) return <td key={c.id} className="diagonal-cell"></td>;
						          return (
						            <td key={c.id} className={getHighlight(g.id,r.id,c.id)}>
						              <input type="number" min="0" className="matrix-input" value={g.matrix[`${r.id}_vs_${c.id}`] ?? ''} placeholder="-" onFocus={()=>setHoverState({g:g.id,r:r.id,c:c.id})} onBlur={()=>setHoverState(null)} onChange={(e)=>{ if(parseInt(e.target.value)<0) return; updateMatrixScore(g.id,r.id,c.id,e.target.value); }}/>
						            </td>
						          );
						        })}

						        {/* ▼▼▼ [수정됨] 승/패 컬럼 (자동 계산 / 읽기 전용) ▼▼▼ */}
						        <td>
						          <div className="stat-split-cell">
						            <span className="stat-split-input" style={{ color: 'var(--text-main)', fontWeight: 'bold' }}>
						              {isAllZero ? '' : r.leagueStats.win}
						            </span>
						            <span style={{color:'var(--text-muted)', opacity:0.5}}>/</span>
						            <span className="stat-split-input" style={{ color: 'var(--text-muted)' }}>
						              {isAllZero ? '' : r.leagueStats.loss}
						            </span>
						          </div>
						        </td>

						        {/* ▼▼▼ [수정됨] 득/실 컬럼 (자동 계산 / 읽기 전용) ▼▼▼ */}
						        <td>
						          <div className="stat-split-cell">
						            <span className="stat-split-input" style={{ color: 'var(--text-main)', fontWeight: 'bold' }}>
						              {isAllZero ? '' : r.leagueStats.scoreWin}
						            </span>
						            <span style={{color:'var(--text-muted)', opacity:0.5}}>/</span>
						            <span className="stat-split-input" style={{ color: 'var(--text-muted)' }}>
						              {isAllZero ? '' : r.leagueStats.scoreLoss}
						            </span>
						          </div>
						        </td>

						        {/* 5. 순위 컬럼 (수동 수정 가능 유지 - 필요시 이것도 span으로 변경 가능) */}
						        <td>
						          <input 
						              type="number" 
    						              className="manual-input" 
    						              /* [수정 포인트] 점수 입력칸과 동일한 색상(--matrix-input-text) 및 굵기 적용 */
    						              style={{ color: 'var(--matrix-input-text)', fontWeight: 'bold' }}
    						              value={(r.leagueStats.rank ?? 0) === 0 ? '' : r.leagueStats.rank} 
    						              placeholder="-" 
    						              onChange={(e) => updateRankManual(g.id, r.id, e.target.value)}
  						          />
						        </td>
						      </tr>
						    );
						  })}
						</tbody>
                                </table>
                                <div className="print-schedule print-only">
                                  {getFormattedSchedule(g.teams.length)}
                                </div>
                              </div>
                            </div>
                          </ResizableCard>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            ) : (
/* [토너먼트 탭] 최신 ButterflyLayout 적용 */
  <div className="tournament-container-wrapper" 
       onMouseDown={handleMouseDown} 
       onMouseMove={handleMouseMove} 
       onMouseUp={handleMouseUp} 
       onMouseLeave={handleMouseUp}
       
       onTouchStart={handleTouchStart}
       onTouchMove={handleTouchMove}
       onTouchEnd={handleMouseUp}
       
       style={{ cursor: isDragging ? 'grabbing' : 'grab', touchAction: 'none' }} /* touchAction: none 필수 */
  >
    {tournamentData.brackets.length === 0 ? (
      /* 대진표가 없을 때 */
      <div className="flex flex-col items-center justify-center h-full text-slate-500">
         <Icons.Trophy size={48} className="mb-4 opacity-20"/>
         <p>생성된 대진표가 없습니다.</p>
         <button onClick={prepareTournamentSetup} className="mt-4 btn-primary px-4 py-2 rounded">
            대진표 생성하기
         </button>
      </div>
    ) : (
      /* 대진표가 있을 때 (ButterflyLayout 렌더링) */
      <div className="tournament-viewport">
        <div 
          className="tournament-canvas transition-transform duration-75" 
          style={{ transform: `translate(${currentView.pan.x}px, ${currentView.pan.y}px) scale(${currentView.zoom})` }}
        >
          {tournamentData.brackets.map((bracket, idx) => {
             // Split 모드일 때 현재 탭(visibleBracketIdx)과 다르면 숨김
             if (tournamentData.type === 'split' && idx !== visibleBracketIdx) return null;
             
             return (
               <div key={idx} className="flex flex-col items-center pt-10 pb-20">
                 
                 {/* [핵심] 최신 버터플라이 레이아웃 컴포넌트 사용 */}
                 <ButterflyLayout 
                    bracket={bracket} 
                    bIdx={idx} 
                    onWinMatch={handleTournamentWin}
                    onToggleJointWin={handleJointWin}
                 />
               </div>
             );
          })}
        </div>
      </div>
    )}
  </div>
)}
            
            {/* (모달 및 유틸리티 컴포넌트들 - 기존 유지) */}
            {swapModalData && (
              <div className="modal-overlay" onClick={()=>setSwapModalData(null)}>
                  {/* ... (스왑 모달 내용 동일) ... */}
                  <div className="modal-content p-6" onClick={(e)=>e.stopPropagation()}>
                    <div className="flex justify-between items-center mb-4 border-b pb-4" style={{borderColor:'var(--table-border)'}}>
                      <h3 className="text-xl font-bold">🔄 팀 자리 교체</h3>
                      <button onClick={()=>setSwapModalData(null)} className="p-1 rounded-full" style={{color:'var(--text-muted)'}}><Icons.X/></button>
                    </div>
                    {/* ... (이하 동일) ... */}
                    <div className="flex-1 overflow-y-auto max-h-[50vh] space-y-2 pr-2 custom-scrollbar">
                        {getAllTeams().map((t, i) => {
                          const isSelf = t.bIdx === swapModalData.bracketIdx && t.rIdx === swapModalData.roundIdx && t.mIdx === swapModalData.matchIdx && t.side === swapModalData.side;
                          return (
                            <div key={i} onClick={()=>!isSelf && executeSwap(t.bIdx, t.rIdx, t.mIdx, t.side)} className="p-3 border rounded-xl flex justify-between items-center transition-all"
                              style={{ cursor: isSelf ? 'not-allowed' : 'pointer', opacity: isSelf ? 0.55 : 1, borderColor: 'var(--table-border)', background: isSelf ? 'var(--input-focus)' : 'transparent' }}>
                              <div className="flex items-center gap-3">
                                <span className="tag">{t.bTitle}</span>
                                <div><div className="font-bold" style={{color:'var(--text-main)'}}>{t.team.name}</div></div>
                              </div>
                            </div>
                          );
                        })}
                    </div>
                  </div>
              </div>
            )}

            <ThemeManagerModal
              open={themeManagerOpen}
              onClose={()=>setThemeManagerOpen(false)}
              themeKey={themeManagerTab}
              setThemeKey={setThemeManagerTab}
              themeValues={themeOverrides ? themeOverrides[themeManagerTab] : {}}
              onChangeValue={updateThemeValue}
              onSaveToBrowser={saveThemeToBrowser}
              onExportFile={exportThemeFile}
              onImportFile={importThemeFile}
              onResetTheme={resetThemeToDefaults}
            />
            
            <TournamentSetupModal 
              isOpen={showSetupModal}
              onClose={()=>setShowSetupModal(false)}
              config={config}
              groups={groups}
              onConfirm={handleConfirmSetup}
            />
            
            <input
              ref={dataFileInputRef}
              type="file"
              accept="application/json,.json"
              className="hidden"
              onChange={(e)=> {
                const f = e.target.files?.[0];
                if (f) loadDataFromFile(f);
                e.target.value = '';
              }}
            />
          </main>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<PingPongManager />);
  </script>
</body>
</html>
