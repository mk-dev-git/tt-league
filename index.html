<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Table Tennis League Manager</title>

  <script src="https://cdn.tailwindcss.com"></script>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    /* ==========================================================
       THEME TOKENS (Dark default) — 모든 UI 색상은 여기 변수로 통합
       ========================================================== */
    :root {
      /* Layout / Base */
      --bg-body: #020617;
      --text-main: #e2e8f0;
      --text-muted: #94a3b8;

      --card-bg: rgba(15, 23, 42, 0.7);
      --card-border: rgba(255, 255, 255, 0.1);

      --table-header-bg: rgba(30, 41, 59, 0.9);
      --table-border: #334155;
      --table-cell-border: #1e293b;

      --input-bg: transparent;
      --input-focus: #1e293b;

      --highlight-bg: #1e293b;

      --diagonal-bg: #1e293b;
      --diagonal-line: #475569;

      --select-bg: rgba(2, 6, 23, 0.95);
      --select-text: #e2e8f0;

      /* Brand / Header */
      --brand-logo-grad-from: #0ea5e9;  /* sky-500 */
      --brand-logo-grad-to: #4f46e5;    /* indigo-600 */
      --brand-logo-text: #ffffff;

      --brand-title-grad-from: #38bdf8; /* sky-400 */
      --brand-title-grad-to: #818cf8;   /* indigo-400 */

      --divider: #334155;

      /* Tabs (상단 메뉴) */
      --tab-active-border: #38bdf8;
      --tab-active-text: #38bdf8;
      --tab-active-bg: rgba(56, 189, 248, 0.10);

      --tab-inactive-text: #94a3b8;
      --tab-inactive-hover-text: #e2e8f0;

      /* Accent + Buttons */
      --accent: #38bdf8;
      --accent-strong: #0ea5e9;
      --accent-2: #4f46e5;

      --btn-primary-bg: linear-gradient(90deg, #0ea5e9, #4f46e5);
      --btn-primary-shadow: rgba(14, 165, 233, 0.35);

      --btn-secondary-bg: rgba(51, 65, 85, 0.75);
      --btn-secondary-bg-hover: rgba(71, 85, 105, 0.85);
      --btn-secondary-border: rgba(71, 85, 105, 0.90);
      --btn-secondary-text: #e2e8f0;
      --btn-secondary-text-hover: #ffffff;

      --btn-danger-bg: rgba(127, 29, 29, 0.35);
      --btn-danger-bg-hover: rgba(153, 27, 27, 0.45);
      --btn-danger-border: rgba(185, 28, 28, 0.55);
      --btn-danger-text: #fecaca;

      --btn-ghost-bg-hover: rgba(30, 41, 59, 0.65);
      --btn-ghost-text: #94a3b8;
      --btn-ghost-text-hover: #e2e8f0;

      --tag-bg: rgba(51, 65, 85, 0.75);
      --tag-border: rgba(71, 85, 105, 0.90);
      --tag-text: #e2e8f0;

      --toggle-bg: rgba(51, 65, 85, 0.85);
      --toggle-bg-checked: rgba(56, 189, 248, 0.85);

      /* Group table (조별 결과) */
      --matrix-input-text: #38bdf8;
      --matrix-focus-ring: #38bdf8;
      --highlight-active-bg: rgba(56, 189, 248, 0.15);
      --highlight-mirror-bg: rgba(56, 189, 248, 0.05);
      --highlight-header-text: #38bdf8;
      --highlight-header-bg: rgba(56, 189, 248, 0.10);
      --resize-handle-accent: #38bdf8;

      /* Lists / Table row states */
      --table-row-hover-bg: rgba(51, 65, 85, 0.30);
      --table-row-editing-bg: rgba(49, 46, 129, 0.30); /* indigo-900/30 */
      --team-level-text: #818cf8; /* indigo-400 */
      --qualified-row-bg: rgba(49, 46, 129, 0.20);

      /* Rank button */
      --rank-btn-bg: rgba(49, 46, 129, 0.50);
      --rank-btn-bg-hover: rgba(55, 48, 163, 0.85);
      --rank-btn-border: rgba(55, 48, 163, 0.90);
      --rank-btn-text: #a5b4fc;

      /* Modal / Overlay */
      --modal-overlay-bg: rgba(0, 0, 0, 0.55);

      --warning-bg: rgba(120, 53, 15, 0.30);
      --warning-text: #fde68a;
      --warning-border: rgba(120, 53, 15, 0.50);

      --swap-item-hover-bg: rgba(49, 46, 129, 0.40);
      --swap-item-hover-border: #6366f1; /* indigo-500 */
      --swap-item-hover-shadow: rgba(49, 46, 129, 0.20);

      /* Tournament (토너먼트) */
      --tournament-line: #64748b;
      --tournament-line-active: #fbbf24;
      --tournament-winner: #fbbf24;
      --tournament-winner-shadow: rgba(251, 191, 36, 0.4);
      --tournament-winner-glow: rgba(251, 191, 36, 0.2);
      --tournament-winner-bg2: #451a03;
      --tournament-team-hover-bg: rgba(56, 189, 248, 0.10);
      --tournament-team-hover-text: #38bdf8;
      --tournament-card-hover-border: #38bdf8;

      --final-title-text: #fbbf24;
      --final-title-shadow: rgba(245, 158, 11, 0.50);

      --champion-grad-from: #fcd34d; /* amber-300 */
      --champion-grad-mid: #fbbf24;  /* yellow-400 */
      --champion-grad-to: #fcd34d;
      --champion-text: #451a03;      /* amber-950 */
      --champion-subtext: #78350f;
      --champion-ring: rgba(255, 255, 255, 0.50);
      --champion-shadow: rgba(251, 191, 36, 0.60);

      --trophy-placeholder-bg: #1f2937;
      --trophy-placeholder-border: #334155;
      --trophy-placeholder-icon: #475569;

      /* Tournament controls (우측 상단 줌 컨트롤) */
      --control-pill-bg: rgba(30, 41, 59, 0.80);
      --control-pill-border: rgba(51, 65, 85, 0.55);
      --control-icon: #94a3b8;
      --control-icon-hover: #38bdf8;
      --control-hover-bg: rgba(51, 65, 85, 0.55);
      --control-divider: #334155;
      --control-helper-text: #94a3b8;
    }

    /* ==========================================================
       Light theme overrides
       ========================================================== */
    body.light-mode {
      --bg-body: #f1f5f9;
      --text-main: #0f172a;
      --text-muted: #64748b;

      --card-bg: rgba(255, 255, 255, 0.82);
      --card-border: #cbd5e1;

      --table-header-bg: #e2e8f0;
      --table-border: #cbd5e1;
      --table-cell-border: #e2e8f0;

      --input-bg: transparent;
      --input-focus: #f8fafc;

      --highlight-bg: #f1f5f9;

      --diagonal-bg: #f1f5f9;
      --diagonal-line: #cbd5e1;

      --select-bg: #ffffff;
      --select-text: #0f172a;

      --divider: #cbd5e1;

      --tab-active-border: #0ea5e9;
      --tab-active-text: #0ea5e9;
      --tab-active-bg: rgba(14, 165, 233, 0.08);

      --tab-inactive-text: #64748b;
      --tab-inactive-hover-text: #0f172a;

      --btn-secondary-bg: rgba(226, 232, 240, 0.92);
      --btn-secondary-bg-hover: rgba(203, 213, 225, 1);
      --btn-secondary-border: rgba(148, 163, 184, 0.90);
      --btn-secondary-text: #0f172a;
      --btn-secondary-text-hover: #0f172a;

      --btn-danger-bg: rgba(254, 226, 226, 0.95);
      --btn-danger-bg-hover: rgba(252, 165, 165, 0.90);
      --btn-danger-border: rgba(248, 113, 113, 0.85);
      --btn-danger-text: #7f1d1d;

      --btn-ghost-bg-hover: rgba(226, 232, 240, 0.85);
      --btn-ghost-text: #475569;
      --btn-ghost-text-hover: #0f172a;

      --tag-bg: rgba(226, 232, 240, 0.92);
      --tag-border: rgba(148, 163, 184, 0.90);
      --tag-text: #0f172a;

      --toggle-bg: rgba(203, 213, 225, 1);
      --toggle-bg-checked: rgba(56, 189, 248, 0.85);

      --matrix-input-text: #0ea5e9;
      --matrix-focus-ring: #0ea5e9;
      --highlight-active-bg: rgba(56, 189, 248, 0.12);
      --highlight-mirror-bg: rgba(56, 189, 248, 0.04);
      --highlight-header-text: #0ea5e9;
      --highlight-header-bg: rgba(56, 189, 248, 0.08);
      --resize-handle-accent: #0ea5e9;

      --table-row-hover-bg: rgba(203, 213, 225, 0.55);
      --table-row-editing-bg: rgba(224, 231, 255, 0.70);
      --team-level-text: #4f46e5;
      --qualified-row-bg: rgba(224, 231, 255, 0.65);

      --rank-btn-bg: rgba(224, 231, 255, 0.85);
      --rank-btn-bg-hover: rgba(199, 210, 254, 0.95);
      --rank-btn-border: rgba(99, 102, 241, 0.65);
      --rank-btn-text: #3730a3;

      --modal-overlay-bg: rgba(2, 6, 23, 0.45);

      --warning-bg: rgba(254, 243, 199, 0.95);
      --warning-text: #7c2d12;
      --warning-border: rgba(251, 191, 36, 0.55);

      --swap-item-hover-bg: rgba(224, 231, 255, 0.70);
      --swap-item-hover-border: rgba(99, 102, 241, 0.75);
      --swap-item-hover-shadow: rgba(99, 102, 241, 0.12);

      --tournament-line: #64748b;
      --tournament-line-active: #f59e0b;
      --tournament-winner: #f59e0b;
      --tournament-winner-shadow: rgba(217, 119, 6, 0.35);
      --tournament-winner-glow: rgba(245, 158, 11, 0.18);
      --tournament-winner-bg2: #ffedd5;
      --tournament-team-hover-bg: rgba(56, 189, 248, 0.10);
      --tournament-team-hover-text: #0ea5e9;
      --tournament-card-hover-border: #0ea5e9;

      --final-title-text: #f59e0b;
      --final-title-shadow: rgba(217, 119, 6, 0.35);

      --champion-grad-from: #fde68a;
      --champion-grad-mid: #f59e0b;
      --champion-grad-to: #fde68a;
      --champion-text: #7c2d12;
      --champion-subtext: #7c2d12;
      --champion-ring: rgba(255, 255, 255, 0.55);
      --champion-shadow: rgba(245, 158, 11, 0.35);

      --trophy-placeholder-bg: #e2e8f0;
      --trophy-placeholder-border: #cbd5e1;
      --trophy-placeholder-icon: #64748b;

      --control-pill-bg: rgba(255, 255, 255, 0.92);
      --control-pill-border: rgba(203, 213, 225, 0.95);
      --control-icon: #64748b;
      --control-icon-hover: #0ea5e9;
      --control-hover-bg: rgba(226, 232, 240, 0.85);
      --control-divider: #cbd5e1;
      --control-helper-text: #64748b;
    }

    body {
      font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, Roboto, sans-serif;
      background-color: var(--bg-body);
      color: var(--text-main);
      overflow: hidden;
      margin: 0;
      padding: 0;
      transition: background-color 0.3s, color 0.3s;
    }

    /* Custom Scrollbar */
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: var(--bg-body); }
    ::-webkit-scrollbar-thumb { background: var(--table-border); border-radius: 4px; }

    /* Common Components */
    .btn-base { border: 1px solid transparent; }
    .btn-primary { background: var(--btn-primary-bg); color: #ffffff; box-shadow: 0 10px 18px -12px var(--btn-primary-shadow); }
    .btn-primary:hover { filter: brightness(1.05); }

    .btn-secondary { background: var(--btn-secondary-bg); border-color: var(--btn-secondary-border); color: var(--btn-secondary-text); }
    .btn-secondary:hover { background: var(--btn-secondary-bg-hover); color: var(--btn-secondary-text-hover); }

    .btn-danger { background: var(--btn-danger-bg); border-color: var(--btn-danger-border); color: var(--btn-danger-text); }
    .btn-danger:hover { background: var(--btn-danger-bg-hover); }

    .btn-magic { background: linear-gradient(90deg, #7c3aed, #d946ef); color: #ffffff; box-shadow: 0 10px 18px -12px rgba(217, 70, 239, 0.35); }
    .btn-magic:hover { filter: brightness(1.05); }

    .btn-ghost { background: transparent; color: var(--btn-ghost-text); border-color: transparent; }
    .btn-ghost:hover { background: var(--btn-ghost-bg-hover); color: var(--btn-ghost-text-hover); }

    .mini-btn {
      font-size: 10px;
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid var(--btn-secondary-border);
      background: var(--btn-secondary-bg);
      color: var(--btn-secondary-text);
      transition: background-color 0.15s ease, color 0.15s ease, border-color 0.15s ease;
    }
    .mini-btn:hover { background: var(--btn-secondary-bg-hover); color: var(--btn-secondary-text-hover); }

    .tag {
      font-size: 10px;
      font-weight: 700;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--tag-border);
      background: var(--tag-bg);
      color: var(--tag-text);
    }

    /* Toggle visuals */
    .toggle-label { background-color: var(--toggle-bg) !important; }
    .toggle-checkbox:checked + .toggle-label { background-color: var(--toggle-bg-checked) !important; }
    .toggle-label::after { transition: transform 0.18s ease; }
    .toggle-checkbox:checked + .toggle-label::after { transform: translateX(20px); }

    /* Table */
    .modern-table { border-collapse: separate; border-spacing: 0; width: 100%; table-layout: fixed; }
    .modern-table.table-auto { table-layout: auto;}
    .modern-table th { background-color: var(--table-header-bg); color: var(--text-muted); font-weight: 700; padding: 12px 8px; border-bottom: 1px solid var(--table-border); font-size: 0.8rem; text-align: center; }
    .modern-table td { border-bottom: 1px solid var(--table-cell-border); color: var(--text-main); font-size: 0.9rem; text-align: center; height: 48px; }
    .member-cell { text-align: left !important; padding: 4px 16px !important; }

    .diagonal-cell {
      background-color: var(--diagonal-bg);
      background-image: linear-gradient(to bottom left, transparent calc(50% - 1px), var(--diagonal-line) calc(50% - 1px), var(--diagonal-line) calc(50% + 1px), transparent calc(50% + 1px));
    }

    /* Inputs */
    .matrix-input { width: 100%; height: 100%; text-align: center; background: var(--input-bg); outline: none; color: var(--matrix-input-text); font-weight: 700; font-size: 1rem; border: none; }
    .matrix-input:focus { background-color: var(--input-focus); box-shadow: inset 0 0 0 2px var(--matrix-focus-ring); color: var(--text-main); }
    .manual-input { width: 100%; height: 100%; text-align: center; background: transparent; outline: none; color: var(--text-muted); font-weight: 600; }

    /* Select */
    select { background-color: var(--select-bg) !important; color: var(--select-text) !important; border-color: var(--table-border) !important; }
    select:focus { outline: none !important; box-shadow: inset 0 0 0 2px var(--matrix-focus-ring) !important; }
    select option { background-color: var(--select-bg) !important; color: var(--select-text) !important; }

    /* Card */
    .resizable-card {
      background: var(--card-bg);
      backdrop-filter: blur(12px);
      border: 1px solid var(--card-border);
      border-radius: 1rem;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      transition: height 0.2s ease, background-color 0.3s, border-color 0.3s;
    }
    .resize-handle { position: absolute; bottom: 0; right: 0; width: 20px; height: 20px; cursor: nwse-resize; z-index: 20; background: linear-gradient(135deg, transparent 50%, var(--resize-handle-accent) 50%); }

    /* Highlight */
    .highlight-active { background-color: var(--highlight-active-bg) !important; }
    .highlight-mirror { background-color: var(--highlight-mirror-bg) !important; }
    .highlight-header { color: var(--highlight-header-text) !important; font-weight: 900 !important; background-color: var(--highlight-header-bg); }

    /* App-specific utility */
    .brand-logo { background: linear-gradient(135deg, var(--brand-logo-grad-from), var(--brand-logo-grad-to)); color: var(--brand-logo-text); }
    .brand-title { background-image: linear-gradient(to right, var(--brand-title-grad-from), var(--brand-title-grad-to)); }
    .tab-btn { border-bottom-width: 2px; border-style: solid; }
    .tab-btn:hover { color: var(--tab-inactive-hover-text); }
    .divider { background-color: var(--divider); }

    .team-row:hover { background-color: var(--table-row-hover-bg); }
    .team-row.editing { background-color: var(--table-row-editing-bg); }
    .rank-btn { background: var(--rank-btn-bg); color: var(--rank-btn-text); border: 1px solid var(--rank-btn-border); }
    .rank-btn:hover { background: var(--rank-btn-bg-hover); }

    /* ==========================================================
       Tournament Layout (from original, kept)
       ========================================================== */
    .tournament-container-wrapper { width: 100vw; height: calc(100vh - 70px); overflow: hidden; background-color: var(--bg-body); position: relative; }
    .tournament-viewport { width: 100%; height: 100%; cursor: grab; background-image: radial-gradient(var(--table-cell-border) 1px, transparent 1px); background-size: 24px 24px; touch-action: none; }
    .tournament-canvas { transform-origin: center center; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; will-change: transform; }
    .tournament-tree { display: flex; justify-content: center; align-items: stretch; padding: 40px; gap: 0px; }
    .wing-container { display: flex; flex: 1; justify-content: flex-end; }
    .wing-container.right-wing { flex-direction: row-reverse; justify-content: flex-end; }
    .round-column { display: flex; flex-direction: column; justify-content: space-around; flex: 1; min-width: 320px; position: relative; }
    .match-wrapper { display: flex; flex-direction: column; justify-content: center; flex: 1; position: relative; width: 100%; }

    .match-card { margin: 10px 30px; background: var(--table-cell-border); border: 1px solid var(--table-border); border-radius: 12px; padding: 12px; position: relative; z-index: 10; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3); transition: transform 0.2s; }
    .match-card:hover { transform: scale(1.02); border-color: var(--tournament-card-hover-border); }
    .match-card.winner-card { border-color: var(--tournament-winner); box-shadow: 0 0 15px var(--tournament-winner-glow); background: linear-gradient(to bottom right, var(--table-cell-border), var(--tournament-winner-bg2)); }

    .line-segment { position: absolute; background-color: var(--tournament-line); opacity: 0.8; z-index: 0; pointer-events: none; transition: background-color 0.3s; }
    .active-line { background-color: var(--tournament-line-active) !important; opacity: 1 !important; box-shadow: 0 0 6px var(--tournament-line-active); }
    .l-h-line { height: 2px; top: 50%; right: 0; width: 30px; }
    .l-v-top { width: 2px; right: 0; top: 50%; height: 50%; }
    .l-v-bottom { width: 2px; right: 0; top: 0; height: 50%; }
    .l-tail { height: 2px; top: 50%; left: 0; width: 30px; }
    .r-h-line { height: 2px; top: 50%; left: 0; width: 30px; }
    .r-v-top { width: 2px; left: 0; top: 50%; height: 50%; }
    .r-v-bottom { width: 2px; left: 0; top: 0; height: 50%; }
    .r-tail { height: 2px; top: 50%; right: 0; width: 30px; }
    .l-h-line.straight-only { width: 50px !important; right: -20px !important; }
    .r-h-line.straight-only { width: 50px !important; left: -20px !important; }

    .team-name-btn { cursor: pointer; font-size: 1rem; font-weight: 700; padding: 4px 8px; border-radius: 4px; display: block; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; color: var(--text-muted); }
    .team-name-btn:hover { color: var(--tournament-team-hover-text); background: var(--tournament-team-hover-bg); }
    .team-name-btn.winner-text { color: var(--tournament-winner); text-shadow: 0 0 10px var(--tournament-winner-shadow); }
    .score-input { width: 36px; height: 28px; text-align: center; border: 1px solid var(--table-border); background: var(--bg-body); color: var(--text-main); font-weight: bold; border-radius: 4px; font-size: 14px; }

    /* Modal */
    .modal-overlay { position: fixed; inset: 0; background: var(--modal-overlay-bg); z-index: 100; display: flex; justify-content: center; align-items: center; }
    .modal-content { background: var(--highlight-bg); padding: 20px; border-radius: 16px; width: 90%; max-width: 500px; max-height: 80vh; border: 1px solid var(--table-border); color: var(--text-main); }

    /* Print (kept, mostly black/white) */
    .print-only { display: none; }
    .print-only-inline { display: none; }
    .screen-only { display: inline; }

    @media print {
      .screen-only { display: none !important; }
      .print-only-inline { display: inline !important; }

      @page { size: A4 landscape; margin: 1cm; }

      html, body, #root {
        background-color: white !important;
        color: black !important;
        width: 100% !important;
        height: auto !important;
        overflow: visible !important;
        margin: 0 !important;
        padding: 0 !important;
        display: block !important;
        position: static !important;
        --bg-body: #fff;
        --text-main: #000;
      }

      .h-screen { height: auto !important; }
      .overflow-hidden, .overflow-y-auto { overflow: visible !important; }
      .tournament-container-wrapper, .tournament-viewport { height: auto !important; overflow: visible !important; }

      .no-print, header, .resize-handle, .card-header button, .zoom-controls { display: none !important; }
      .print-only { display: block !important; }

      .print-team-name { display: block !important; white-space: pre-line !important; line-height: 1.15 !important; }
      .stat-col { width: 5% !important; }

      .grid, .flex-wrap-container { display: block !important; width: 100% !important; }

      .print-page-wrapper {
        width: 100%;
        display: block;
        margin: 0;
        padding: 0;
        page-break-after: always;
        break-after: page;
        page-break-inside: avoid;
        break-inside: avoid;
      }
      .print-page-wrapper:last-child { page-break-after: auto; break-after: auto; }

      .resizable-card {
        width: 100% !important;
        height: auto !important;
        border: 2px solid #000 !important;
        background: #fff !important;
        backdrop-filter: none !important;
        box-shadow: none !important;
        margin: 0 !important;
        border-radius: 0 !important;
        color: #000 !important;
        overflow: visible !important;
        display: flex !important;
        flex-direction: column !important;
        page-break-inside: avoid;
        break-inside: avoid;
      }
      .resizable-card > div:nth-child(1) { flex: 0 0 auto !important; }
      .resizable-card > div:nth-child(2) { flex: 1 1 auto !important; padding: 6px 8px !important; }

      .card-header h3 { color: black !important; font-size: 16px; text-align: center; width: 100%; }
      .card-header { border-bottom: 2px solid #000 !important; padding: 5px !important; }

      .modern-table { page-break-inside: avoid; break-inside: avoid; }
      .modern-table tr { page-break-inside: avoid; break-inside: avoid; }
      .modern-table th {
        background-color: #eee !important;
        color: #000 !important;
        border: 1px solid #000 !important;
        padding: 6px 6px !important;
        font-size: 11px !important;
      }
      .modern-table td {
        border: 1px solid #000 !important;
        color: #000 !important;
        background-color: #fff !important;
        padding: 4px 6px !important;
        height: 36px !important;
        font-size: 11px !important;
      }
      .modern-table td.member-cell { background-color: #eee !important; }
      .highlight-header { background-color: #eee !important; color: #000 !important; }

      .diagonal-cell {
        background-color: #eee !important;
        background-image: linear-gradient(to bottom left, transparent calc(50% - 1px), #000 calc(50% - 1px), #000 calc(50% + 1px), transparent calc(50% + 1px)) !important;
      }

      input::placeholder { color: transparent !important; }
      input { border: none !important; background: transparent !important; color: #000 !important; font-weight: bold; }

      .print-schedule {
        display: block !important;
        margin-top: 6px !important;
        border-top: 2px solid #000;
        padding: 5px 10px !important;
        font-size: 11px;
        line-height: 1.4;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        background-color: #fff !important;
        color: #000 !important;
        width: 100%;
        page-break-inside: avoid;
        break-inside: avoid;
      }

      body.printing-single .print-page-wrapper { display: none !important; }
      body.printing-single .print-page-wrapper.target-print { display: block !important; }

      .print-highlight td { background-color: #e2e8f0 !important; font-weight: bold; }
      .print-highlight input { font-weight: 800; }
    }

    /* Toast */
    .pp-toast {
      position: fixed;
      left: 50%;
      bottom: 24px;
      transform: translateX(-50%);
      z-index: 10000;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid var(--table-border);
      background: var(--card-bg);
      color: var(--text-main);
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 24px -16px rgba(0,0,0,0.6);
      font-size: 12px;
      opacity: 0;
      transition: opacity 180ms ease, transform 180ms ease;
      pointer-events: none;
    }
    .pp-toast.show { opacity: 1; transform: translateX(-50%) translateY(-4px); }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useLayoutEffect, useMemo, useRef } = React;

    // ----------------------------------------------------------
    // Toast helper (safe default)
    // ----------------------------------------------------------
    const toast = (msg) => {
      try {
        let el = document.getElementById('pp-toast');
        if (!el) {
          el = document.createElement('div');
          el.id = 'pp-toast';
          el.className = 'pp-toast';
          document.body.appendChild(el);
        }
        el.textContent = String(msg ?? '');
        el.classList.add('show');
        clearTimeout(el._t1);
        clearTimeout(el._t2);
        el._t1 = setTimeout(() => el.classList.remove('show'), 1800);
        el._t2 = setTimeout(() => { /* keep node for reuse */ }, 2200);
      } catch (_) {}
    };

    // Icons
    const Icon = ({ path, size = 18, className = "" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size}
        viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"
        strokeLinecap="round" strokeLinejoin="round" className={className}>
        {path}
      </svg>
    );

    const Icons = {
      Plus: (p) => <Icon {...p} path={<><path d="M5 12h14"/><path d="M12 5v14"/></>} />,
      Trash: (p) => <Icon {...p} path={<><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-1 1-1h6c0 0 1 0 1 1v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></>} />,
      Save: (p) => <Icon {...p} path={<><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></>} />,
      Upload: (p) => <Icon {...p} path={<><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></>} />,
      Trophy: (p) => <Icon {...p} path={<><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></>} />,
      Users: (p) => <Icon {...p} path={<><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></>} />,
      List: (p) => <Icon {...p} path={<><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></>} />,
      Settings: (p) => <Icon {...p} path={<><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></>} />,
      ChevronRight: (p) => <Icon {...p} path={<polyline points="9 18 15 12 9 6"/>} />,
      ChevronDown: (p) => <Icon {...p} path={<polyline points="6 9 12 15 18 9"/>} />,
      Wand: (p) => <Icon {...p} path={<><path d="M15 4V2"/><path d="M15 16v-2"/><path d="M8 9h2"/><path d="M20 9h2"/><path d="M17.8 11.8 19 13"/><path d="M15 9h0"/><path d="M17.8 6.2 19 5"/><path d="M3 21l9-9"/><path d="M12.2 6.2 11 5"/></>} />,
      Edit: (p) => <Icon {...p} path={<path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/>} />,
      Check: (p) => <Icon {...p} path={<polyline points="20 6 9 17 4 12"/>} />,
      X: (p) => <Icon {...p} path={<><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></>} />,
      Lock: (p) => <Icon {...p} path={<><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></>} />,
      Unlock: (p) => <Icon {...p} path={<><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 9.9-1"/></>} />,
      SortAsc: (p) => <Icon {...p} path={<><path d="M11 5h10"/><path d="M11 9h7"/><path d="M11 13h4"/><path d="M3 17l3 3 3-3"/><path d="M6 18V4"/></>} />,
      SortDesc: (p) => <Icon {...p} path={<><path d="M11 5h10"/><path d="M11 9h7"/><path d="M11 13h4"/><path d="M3 5l3-3 3 3"/><path d="M6 18V4"/></>} />,
      SortGroup: (p) => <Icon {...p} path={<><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></>} />,
      Printer: (p) => <Icon {...p} path={<><polyline points="6 9 6 2 18 2 18 9"/><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/><rect x="6" y="14" width="12" height="8"/></>} />,
      ZoomIn: (p) => <Icon {...p} path={<><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></>} />,
      ZoomOut: (p) => <Icon {...p} path={<><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/></>} />,
      Refresh: (p) => <Icon {...p} path={<><path d="M23 4v6h-6"/><path d="M1 20v-6h6"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></>} />,
      Swap: (p) => <Icon {...p} path={<><path d="M7 16V4M7 4L3 8M7 4L11 8"/><path d="M17 8V20M17 20L21 16M17 20L13 16"/></>} />,
      ExternalLink: (p) => <Icon {...p} path={<><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></>} />,
      Move: (p) => <Icon {...p} path={<><polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="19 9 22 12 19 15"/><polyline points="9 19 12 22 15 19"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="12" y1="2" x2="12" y2="22"/></>} />,
      Sun: (p) => <Icon {...p} path={<><circle cx="12" cy="12" r="5"/><path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/></>} />,
      Moon: (p) => <Icon {...p} path={<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>} />,
    };

    // UI primitives
    const Card = ({ children, className = "" }) => <div className={`resizable-card p-6 ${className}`}>{children}</div>;

    const Button = ({ onClick, children, variant = "primary", className = "", disabled=false, title="" }) => {
      const baseStyle = "px-4 py-2 rounded-lg font-medium transition-all duration-200 flex items-center justify-center gap-2 cursor-pointer active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed no-print btn-base";
      const variants = { primary: "btn-primary", secondary: "btn-secondary", danger: "btn-danger", magic: "btn-magic", ghost: "btn-ghost" };
      return <button onClick={onClick} disabled={disabled} title={title} className={`${baseStyle} ${variants[variant]} ${className}`}>{children}</button>;
    };

    const Input = (props) => (
      <input {...props}
        className={`w-full px-3 py-2 rounded-lg focus:outline-none transition-all placeholder-slate-600 ${props.className || ''}`}
        style={{ backgroundColor: 'var(--input-bg)', color: 'var(--text-main)', border: `1px solid var(--table-border)` }}
      />
    );

    const Toggle = ({ label, checked, onChange }) => (
      <div className="flex items-center justify-between py-2 no-print">
        <span className="text-sm font-medium" style={{color:'var(--text-muted)'}}>{label}</span>
        <label className="relative inline-flex items-center cursor-pointer">
          <input type="checkbox" className="sr-only peer toggle-checkbox" checked={checked} onChange={onChange} />
          <div className="w-11 h-6 peer-focus:outline-none rounded-full peer toggle-label after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all"></div>
        </label>
      </div>
    );

    const ResizableCard = ({ id, width, height, onResize, className = "", children }) => {
      const handleResize = (e) => {
        e.preventDefault(); e.stopPropagation();
        const startX = e.clientX, startY = e.clientY;
        const startW = width, startH = typeof height === 'number' ? height : e.target.parentElement.offsetHeight;
        const onMouseMove = (me) => onResize(id, Math.max(350, startW + me.clientX - startX), Math.max(250, startH + me.clientY - startY));
        const onMouseUp = () => { document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); };
        document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp);
      };
      return (
        <div className={`resizable-card ${className}`} style={{ width, height: height === 'auto' ? 'auto' : height }}>
          <div className="flex-none px-4 py-3 card-header flex justify-between items-center">{children[0]}</div>
          <div className="flex-grow relative flex flex-col">{children[1]}</div>
          <div className="resize-handle no-print" onMouseDown={handleResize}></div>
        </div>
      );
    };

    // ----------------------------------------------------------
    // Schedule presets
    // ----------------------------------------------------------
    const FIXED_MATCH_ORDER = {
      2: [[1,2]],
      3: [[1,3], [2,3], [1,2]],
      4: [[1,4], [2,3], [1,3], [2,4], [1,2], [3,4]],
      5: [[1,5], [2,4], [1,3], [2,5], [3,4], [1,2], [3,5], [1,4], [2,3], [4,5]],
      6: [[1,6], [2,5], [3,4], [1,5], [4,6], [2,3], [1,4], [3,5], [2,6], [1,3], [2,4], [5,6], [1,2], [3,6], [4,5]],
      7: [[1,7], [2,6], [3,5], [1,4], [2,7], [3,6], [4,5], [1,2], [3,7], [4,6], [1,5], [2,3], [4,7], [5,6], [1,3], [2,4], [5,7], [1,6], [3,4], [2,5], [6,7]],
      8: [[1,8], [2,7], [3,6], [4,5], [1,7], [6,8], [2,5], [3,4], [1,6], [5,7], [4,8], [2,3], [1,5], [4,6], [3,7], [2,8], [1,4], [3,5], [2,6], [7,8], [1,3], [2,4], [5,8], [6,7], [1,2], [3,8], [4,7], [5,6]],
      9: [[1,9], [2,8], [3,7], [4,6], [1,5], [2,9], [3,8], [4,7], [5,6], [1,2], [3,9], [4,8], [5,7], [1,6], [2,3], [4,9], [5,8], [6,7], [1,3], [2,4], [5,9], [6,8], [1,7], [3,4], [2,5], [6,9], [7,8], [1,4], [3,5], [2,6], [7,9], [1,8], [4,5], [3,6], [2,7], [8,9]],
      10: [[1,10], [2,9], [3,8], [4,7], [5,6], [1,9], [8,10], [2,7], [3,6], [4,5], [1,8], [7,9], [6,10], [2,5], [3,4], [1,7], [6,8], [5,9], [4,10], [2,3], [1,6], [5,7], [4,8], [3,9], [2,10], [1,5], [4,6], [3,7], [2,8], [9,10], [1,4], [3,5], [2,6], [7,10], [8,9], [1,3], [2,4], [5,10], [6,9], [7,8], [1,2], [3,10], [4,9], [5,8], [6,7]],
      11: [[1,11], [2,10], [3,9], [4,8], [5,7], [1,6], [2,11], [3,10], [4,9], [5,8], [6,7], [1,2], [3,11], [4,10], [5,9], [6,8], [1,7], [2,3], [4,11], [5,10], [6,9], [7,8], [1,3], [2,4], [5,11], [6,10], [7,9], [1,8], [3,4], [2,5], [6,11], [7,10], [8,9], [1,4], [3,5], [2,6], [7,11], [8,10], [1,9], [4,5], [3,6], [2,7], [8,11], [9,10], [1,5], [4,6], [3,7], [2,8], [9,11], [1,10], [5,6], [4,7], [3,8], [2,9], [10,11]],
      12: [[1,12], [2,11], [3,10], [4,9], [5,8], [6,7], [1,11], [10,12], [2,9], [3,8], [4,7], [5,6], [1,10], [9,11], [8,12], [2,7], [3,6], [4,5], [1,9], [8,10], [7,11], [6,12], [2,5], [3,4], [1,8], [7,9], [6,10], [5,11], [4,12], [2,3], [1,7], [6,8], [5,9], [4,10], [3,11], [2,12], [1,6], [5,7], [4,8], [3,9], [2,10], [11,12], [1,5], [4,6], [3,7], [2,8], [9,12], [10,11], [1,4], [3,5], [2,6], [7,12], [8,11], [9,10], [1,3], [2,4], [5,12], [6,11], [7,10], [8,9], [1,2], [3,12], [4,11], [5,10], [6,9], [7,8]]
    };

    const NAMES = ['김철수', '이영희', '박민수', '김민준', '김서연', '김도윤', '김하은', '이준호', '이지아', '박지훈', '박수빈', '최예준', '최지우', '정현우', '정채원', '강태현', '강지민', '조승우', '조하린', '윤재현', '윤서아', '장우진', '장다은', '임시우', '임유나', '한성민', '한예린', '오지후', '오서현', '서도현', '서윤지', '신민재', '신가은', '권준서', '권나연', '황도경', '황소연', '안재훈', '안하율', '송현준', '송은채', '류지환', '류채린', '홍진우', '홍아윤', '고은우', '고지윤', '문태윤', '문서진', '양준혁', '양예원', '손민수', '손다현', '배성준', '배서영', '백지호', '백하린', '남궁민석', '남궁서희', '노현석', '노지은', '나유준', '나채은', '전준영', '전소민', '하준우', '하은서', '성민호', '성예지', '손우성', '손지안', '유태준', '유하늘', '라준혁', '라세윤', '심건우', '심채영', '변준희', '변서윤', '우지훈', '우하진', '주민규', '주예슬', '채민석', '채서린', '표진호', '표다인', '탁성현', '탁예나', '허준혁', '허지수', '진도현', '진예린', '공민재', '공서연', '신은호', '신다솔', '강민서', '강유진', '박현서', '박라희', '이채원', '최하윤'];
    const getRandomItem = (arr) => arr[Math.floor(Math.random() * arr.length)];

    // ----------------------------------------------------------
    // MatchBox (same as original)
    // ----------------------------------------------------------
const MatchBox = React.memo(({ match, idx, bracketIdx, roundIdx, isRight = false, isFinal = false, noVertical = false, isJointWinner = false, onScore, onWin, onSwap }) => {
  // 공동 우승일 경우 두 팀 모두 승리한 것으로 간주하여 스타일 적용
  const isWinnerA = isJointWinner ? !!match.teamA : (match.winner && match.teamA && match.winner.id === match.teamA.id);
  const isWinnerB = isJointWinner ? !!match.teamB : (match.winner && match.teamB && match.winner.id === match.teamB.id);

  const hasNext = !!match.nextMatchId;
  const isEven = idx % 2 === 0;
  // 공동 우승이거나 승자가 있으면 라인 활성화
  const winnerClass = (match.winner || isJointWinner) ? 'active-line' : '';

  return (
    <div className="match-wrapper">
      {hasNext && (
        <>
          <div className={`line-segment ${isRight ? 'r-h-line' : 'l-h-line'} ${noVertical ? 'straight-only' : ''} ${winnerClass}`} />
          {!noVertical && (
            <div className={`line-segment ${isRight ? (isEven ? 'r-v-top' : 'r-v-bottom') : (isEven ? 'l-v-top' : 'l-v-bottom')} ${winnerClass}`} />
          )}
        </>
      )}
      {roundIdx > 0 && !isFinal && (
        <div className={`line-segment ${isRight ? 'r-tail' : 'l-tail'}`} />
      )}
      {/* 공동 우승일 경우 카드 테두리 강조 */}
      <div className={`match-card ${match.winner || isJointWinner ? 'winner-card' : ''}`}>
        <div className="absolute -top-2 left-1/2 -translate-x-1/2 text-[10px] font-bold px-2 py-0.5 rounded-full border"
          style={{ background: 'rgba(2,6,23,0.90)', borderColor: 'var(--table-border)', color: 'var(--text-muted)' }}>
          M{idx+1}
        </div>

        <div className={`flex justify-between items-center mb-2 pb-2 border-b ${isRight?'flex-row-reverse':''}`}
          style={{ borderColor: 'rgba(100,116,139,0.35)' }}>
          <div className={`flex flex-col flex-1 overflow-hidden ${isRight?'items-end text-right':''}`}>
            <div className="flex items-center gap-1 mb-0.5">
              {roundIdx===0 && (
                <button className="no-print p-0.5 rounded transition-colors cursor-pointer"
                  style={{ color: 'var(--text-muted)' }}
                  onClick={(e)=>{e.preventDefault(); e.stopPropagation(); onSwap(bracketIdx, roundIdx, idx, 'teamA')}}
                  onMouseDown={(e)=>e.stopPropagation()}
                  title="교체">
                  <Icons.Swap size={10}/>
                </button>
              )}
              {roundIdx===0 && match.teamA && match.teamA.sourceLabel && <span className="text-[10px] font-bold tracking-tight" style={{color:'var(--text-muted)'}}>{match.teamA.sourceLabel}</span>}
            </div>
            <span className={`team-name-btn ${isWinnerA ? 'winner-text' : ''} ${!match.teamA ? 'opacity-60' : ''}`}
              title="클릭하여 승리 처리"
              onClick={(e)=>{e.stopPropagation(); match.teamA && !match.teamA.isBye && onWin(bracketIdx, roundIdx, idx, match.teamA)}}
              onMouseDown={(e)=>e.stopPropagation()}>
              {match.teamA ? match.teamA.name : 'TBD'}
            </span>
          </div>
          <input type="number" className={`score-input ${isRight?'mr-2':'ml-2'} ${isWinnerA?'border-amber-500 text-amber-400':''}`}
            value={match.scoreA}
            onMouseDown={(e)=>e.stopPropagation()}
            onChange={(e)=>onScore(bracketIdx, roundIdx, idx, 'scoreA', e.target.value)}/>
        </div>

        <div className={`flex justify-between items-center ${isRight?'flex-row-reverse':''}`}>
          <div className={`flex flex-col flex-1 overflow-hidden ${isRight?'items-end text-right':''}`}>
            <div className="flex items-center gap-1 mb-0.5">
              {roundIdx===0 && (
                <button className="no-print p-0.5 rounded transition-colors cursor-pointer"
                  style={{ color: 'var(--text-muted)' }}
                  onClick={(e)=>{e.preventDefault(); e.stopPropagation(); onSwap(bracketIdx, roundIdx, idx, 'teamB')}}
                  onMouseDown={(e)=>e.stopPropagation()}
                  title="교체">
                  <Icons.Swap size={10}/>
                </button>
              )}
              {roundIdx===0 && match.teamB && match.teamB.sourceLabel && <span className="text-[10px] font-bold tracking-tight" style={{color:'var(--text-muted)'}}>{match.teamB.sourceLabel}</span>}
            </div>
            <span className={`team-name-btn ${isWinnerB ? 'winner-text' : ''} ${!match.teamB ? 'opacity-60' : ''}`}
              title="클릭하여 승리 처리"
              onClick={(e)=>{e.stopPropagation(); match.teamB && !match.teamB.isBye && onWin(bracketIdx, roundIdx, idx, match.teamB)}}
              onMouseDown={(e)=>e.stopPropagation()}>
              {match.teamB ? match.teamB.name : 'TBD'}
            </span>
          </div>
          <input type="number" className={`score-input ${isRight?'mr-2':'ml-2'} ${isWinnerB?'border-amber-500 text-amber-400':''}`}
            value={match.scoreB}
            onMouseDown={(e)=>e.stopPropagation()}
            onChange={(e)=>onScore(bracketIdx, roundIdx, idx, 'scoreB', e.target.value)}/>
        </div>
      </div>
    </div>
  );
});

    // ----------------------------------------------------------
    // THEME MANAGER — Full control (모든 변수/문자열 내 색상 토큰 지원)
    // ----------------------------------------------------------
    const THEME_STORAGE_KEY = 'league_theme_overrides_v2';
    const THEME_FILE_NAME = 'league_theme_overrides.json';

    const THEME_KEYS = [
      // Base
      "bg-body","text-main","text-muted","card-bg","card-border",
      "table-header-bg","table-border","table-cell-border",
      "input-bg","input-focus","highlight-bg",
      "diagonal-bg","diagonal-line",
      "select-bg","select-text",

      // Brand / header / tabs
      "brand-logo-grad-from","brand-logo-grad-to","brand-logo-text",
      "brand-title-grad-from","brand-title-grad-to",
      "divider",
      "tab-active-border","tab-active-text","tab-active-bg","tab-inactive-text","tab-inactive-hover-text",

      // Accent + buttons
      "accent","accent-strong","accent-2",
      "btn-primary-bg","btn-primary-shadow",
      "btn-secondary-bg","btn-secondary-bg-hover","btn-secondary-border","btn-secondary-text","btn-secondary-text-hover",
      "btn-danger-bg","btn-danger-bg-hover","btn-danger-border","btn-danger-text",
      "btn-ghost-bg-hover","btn-ghost-text","btn-ghost-text-hover",
      "tag-bg","tag-border","tag-text",
      "toggle-bg","toggle-bg-checked",

      // Group table
      "matrix-input-text","matrix-focus-ring","highlight-active-bg","highlight-mirror-bg","highlight-header-text","highlight-header-bg","resize-handle-accent",

      // Lists / rank / states
      "table-row-hover-bg","table-row-editing-bg","team-level-text","qualified-row-bg",
      "rank-btn-bg","rank-btn-bg-hover","rank-btn-border","rank-btn-text",

      // Modal
      "modal-overlay-bg","warning-bg","warning-text","warning-border","swap-item-hover-bg","swap-item-hover-border","swap-item-hover-shadow",

      // Tournament
      "tournament-line","tournament-line-active","tournament-card-hover-border",
      "tournament-team-hover-text","tournament-team-hover-bg",
      "tournament-winner","tournament-winner-shadow","tournament-winner-glow","tournament-winner-bg2",
      "final-title-text","final-title-shadow",
      "champion-grad-from","champion-grad-mid","champion-grad-to","champion-text","champion-subtext","champion-ring","champion-shadow",
      "trophy-placeholder-bg","trophy-placeholder-border","trophy-placeholder-icon",

      // Tournament controls
      "control-pill-bg","control-pill-border","control-icon","control-icon-hover","control-hover-bg","control-divider","control-helper-text",
    ];

    const THEME_CATEGORIES = [
      { id: "brand", label: "브랜드/상단", keys: ["brand-logo-grad-from","brand-logo-grad-to","brand-logo-text","brand-title-grad-from","brand-title-grad-to","divider"] },
      { id: "tabs", label: "상단 탭", keys: ["tab-active-border","tab-active-text","tab-active-bg","tab-inactive-text","tab-inactive-hover-text"] },
      { id: "base", label: "기본/레이아웃", keys: ["bg-body","text-main","text-muted","card-bg","card-border","highlight-bg","input-bg","input-focus","select-bg","select-text"] },
      { id: "tables", label: "표/리스트", keys: ["table-header-bg","table-border","table-cell-border","table-row-hover-bg","table-row-editing-bg","team-level-text","qualified-row-bg"] },
      { id: "buttons", label: "버튼/컨트롤", keys: ["accent","accent-strong","accent-2","btn-primary-bg","btn-primary-shadow","btn-secondary-bg","btn-secondary-bg-hover","btn-secondary-border","btn-secondary-text","btn-secondary-text-hover","btn-danger-bg","btn-danger-bg-hover","btn-danger-border","btn-danger-text","btn-ghost-bg-hover","btn-ghost-text","btn-ghost-text-hover","tag-bg","tag-border","tag-text","toggle-bg","toggle-bg-checked","rank-btn-bg","rank-btn-bg-hover","rank-btn-border","rank-btn-text"] },
      { id: "groups", label: "조별 결과(매트릭스)", keys: ["diagonal-bg","diagonal-line","matrix-input-text","matrix-focus-ring","highlight-active-bg","highlight-mirror-bg","highlight-header-text","highlight-header-bg","resize-handle-accent"] },
      { id: "modal", label: "모달/오버레이", keys: ["modal-overlay-bg","warning-bg","warning-text","warning-border","swap-item-hover-bg","swap-item-hover-border","swap-item-hover-shadow"] },
      { id: "tournament", label: "토너먼트", keys: ["tournament-line","tournament-line-active","tournament-card-hover-border","tournament-team-hover-text","tournament-team-hover-bg","tournament-winner","tournament-winner-shadow","tournament-winner-glow","tournament-winner-bg2","final-title-text","final-title-shadow","champion-grad-from","champion-grad-mid","champion-grad-to","champion-text","champion-subtext","champion-ring","champion-shadow","trophy-placeholder-bg","trophy-placeholder-border","trophy-placeholder-icon"] },
      { id: "tcontrols", label: "토너먼트 툴바", keys: ["control-pill-bg","control-pill-border","control-icon","control-icon-hover","control-hover-bg","control-divider","control-helper-text"] },
    ];

    const THEME_META = {
      // Base
      "bg-body": { label: "페이지 배경", desc: "앱 전체 배경(메인 캔버스/여백 포함)" },
      "text-main": { label: "기본 텍스트", desc: "본문/제목 등 주요 텍스트 색" },
      "text-muted": { label: "보조 텍스트", desc: "설명/보조 정보/비활성 텍스트 색" },
      "card-bg": { label: "카드 배경", desc: "카드(패널) 배경(반투명 가능)" },
      "card-border": { label: "카드 테두리", desc: "카드 외곽 테두리 색" },
      "highlight-bg": { label: "강조 배경", desc: "선택/모달/강조 영역 기본 배경" },
      "input-bg": { label: "입력 배경", desc: "Input 기본 배경" },
      "input-focus": { label: "입력 포커스 배경", desc: "Input 포커스 시 배경" },
      "select-bg": { label: "드롭다운 배경", desc: "Select(옵션 포함) 배경" },
      "select-text": { label: "드롭다운 텍스트", desc: "Select(옵션 포함) 글자색" },

      // Tables
      "table-header-bg": { label: "테이블 헤더 배경", desc: "표 헤더(TH) 배경" },
      "table-border": { label: "테이블 테두리/구분선", desc: "표 외곽/컴포넌트 기본 보더" },
      "table-cell-border": { label: "테이블 셀 구분선", desc: "표 행/열 내부 구분선" },
      "table-row-hover-bg": { label: "리스트 Hover 배경", desc: "팀 목록 등 행 Hover 배경" },
      "table-row-editing-bg": { label: "리스트 편집중 배경", desc: "팀 편집 중(선택 행) 배경" },
      "team-level-text": { label: "합부수 강조 텍스트", desc: "팀 합부수(강조 숫자) 텍스트 색" },
      "qualified-row-bg": { label: "본선 대상 행 배경", desc: "상위부/본선 진출 표시 행 배경" },

      // Brand / Tabs
      "brand-logo-grad-from": { label: "상단 로고 그라데이션(시작)", desc: "좌측 P 로고 배경 그라데이션 시작색" },
      "brand-logo-grad-to": { label: "상단 로고 그라데이션(끝)", desc: "좌측 P 로고 배경 그라데이션 끝색" },
      "brand-logo-text": { label: "상단 로고 텍스트", desc: "좌측 P 로고 글자색" },
      "brand-title-grad-from": { label: "상단 제목 그라데이션(시작)", desc: "Table Tennis League Manager 텍스트 그라데이션 시작" },
      "brand-title-grad-to": { label: "상단 제목 그라데이션(끝)", desc: "Table Tennis League Manager 텍스트 그라데이션 끝" },
      "divider": { label: "구분선(디바이더)", desc: "헤더/툴바 등 세로 구분선" },

      "tab-active-border": { label: "탭 활성 테두리", desc: "상단 탭 선택 시 하단 보더" },
      "tab-active-text": { label: "탭 활성 텍스트", desc: "상단 탭 선택 시 글자색" },
      "tab-active-bg": { label: "탭 활성 배경", desc: "상단 탭 선택 시 배경" },
      "tab-inactive-text": { label: "탭 비활성 텍스트", desc: "상단 탭 기본(비선택) 글자색" },
      "tab-inactive-hover-text": { label: "탭 Hover 텍스트", desc: "상단 탭 Hover 시 글자색" },

      // Accent + Buttons
      "accent": { label: "포인트(강조) 색", desc: "핵심 강조 색(텍스트/테두리/호버)" },
      "accent-strong": { label: "포인트(진한) 색", desc: "아이콘/헤딩 등에 쓰는 진한 포인트" },
      "accent-2": { label: "보조 포인트", desc: "그라데이션/보조 강조(인디고 계열)" },

      "btn-primary-bg": { label: "주요 버튼 배경", desc: "Primary 버튼 배경(그라데이션 문자열)" },
      "btn-primary-shadow": { label: "주요 버튼 그림자", desc: "Primary 버튼 그림자 색" },

      "btn-secondary-bg": { label: "보조 버튼 배경", desc: "Secondary 버튼 기본 배경" },
      "btn-secondary-bg-hover": { label: "보조 버튼 Hover 배경", desc: "Secondary 버튼 Hover 배경" },
      "btn-secondary-border": { label: "보조 버튼 테두리", desc: "Secondary 버튼 보더" },
      "btn-secondary-text": { label: "보조 버튼 텍스트", desc: "Secondary 버튼 글자색" },
      "btn-secondary-text-hover": { label: "보조 버튼 Hover 텍스트", desc: "Secondary 버튼 Hover 글자색" },

      "btn-danger-bg": { label: "위험 버튼 배경", desc: "Danger 버튼 배경" },
      "btn-danger-bg-hover": { label: "위험 버튼 Hover 배경", desc: "Danger 버튼 Hover 배경" },
      "btn-danger-border": { label: "위험 버튼 테두리", desc: "Danger 버튼 보더" },
      "btn-danger-text": { label: "위험 버튼 텍스트", desc: "Danger 버튼 글자색" },

      "btn-ghost-bg-hover": { label: "고스트 Hover 배경", desc: "Ghost 버튼 Hover 배경" },
      "btn-ghost-text": { label: "고스트 텍스트", desc: "Ghost 버튼 글자색" },
      "btn-ghost-text-hover": { label: "고스트 Hover 텍스트", desc: "Ghost 버튼 Hover 글자색" },

      "tag-bg": { label: "태그/배지 배경", desc: "스왑 모달 등에서 쓰는 배지 배경" },
      "tag-border": { label: "태그/배지 테두리", desc: "배지 보더" },
      "tag-text": { label: "태그/배지 텍스트", desc: "배지 글자색" },

      "toggle-bg": { label: "토글 OFF 배경", desc: "토글 스위치 OFF 배경" },
      "toggle-bg-checked": { label: "토글 ON 배경", desc: "토글 스위치 ON 배경" },

      "rank-btn-bg": { label: "순위 계산 버튼 배경", desc: "각 조의 '순위 계산' 버튼 배경" },
      "rank-btn-bg-hover": { label: "순위 계산 버튼 Hover 배경", desc: "각 조의 '순위 계산' 버튼 Hover 배경" },
      "rank-btn-border": { label: "순위 계산 버튼 테두리", desc: "각 조의 '순위 계산' 버튼 보더" },
      "rank-btn-text": { label: "순위 계산 버튼 텍스트", desc: "각 조의 '순위 계산' 버튼 글자색" },

      // Group matrix
      "diagonal-bg": { label: "대각선 셀 배경", desc: "자기 자신 셀(대각선) 배경" },
      "diagonal-line": { label: "대각선 선 색", desc: "대각선 슬래시(\\) 선 색" },

      "matrix-input-text": { label: "매트릭스 입력 텍스트", desc: "조별 결과 입력(점수) 글자색" },
      "matrix-focus-ring": { label: "매트릭스 포커스 링", desc: "입력 포커스 테두리(링)" },

      "highlight-active-bg": { label: "Hover 강조 배경(강)", desc: "현재 셀(직교) 강조 배경" },
      "highlight-mirror-bg": { label: "Hover 강조 배경(약)", desc: "미러 셀(대칭) 강조 배경" },
      "highlight-header-text": { label: "Hover 헤더 텍스트", desc: "강조된 헤더 텍스트 색" },
      "highlight-header-bg": { label: "Hover 헤더 배경", desc: "강조된 헤더 배경" },
      "resize-handle-accent": { label: "카드 리사이즈 핸들", desc: "우하단 리사이즈 핸들 색" },

      // Modal / overlay
      "modal-overlay-bg": { label: "모달 오버레이", desc: "모달 뒤 배경(딤) 색" },
      "warning-bg": { label: "경고 박스 배경", desc: "스왑 모달 상단 경고 박스 배경" },
      "warning-text": { label: "경고 박스 텍스트", desc: "스왑 모달 상단 경고 박스 글자색" },
      "warning-border": { label: "경고 박스 테두리", desc: "스왑 모달 상단 경고 박스 테두리" },

      "swap-item-hover-bg": { label: "스왑 항목 Hover 배경", desc: "스왑 대상 목록 Hover 배경" },
      "swap-item-hover-border": { label: "스왑 항목 Hover 테두리", desc: "스왑 대상 목록 Hover 테두리" },
      "swap-item-hover-shadow": { label: "스왑 항목 Hover 그림자", desc: "스왑 대상 목록 Hover 그림자" },

      // Tournament
      "tournament-line": { label: "대진 연결선(기본)", desc: "토너먼트 라인 기본 색" },
      "tournament-line-active": { label: "대진 연결선(활성)", desc: "승자 경로 라인 색" },
      "tournament-card-hover-border": { label: "매치 카드 Hover 테두리", desc: "매치 카드 Hover 보더" },
      "tournament-team-hover-text": { label: "팀명 Hover 텍스트", desc: "팀명 Hover 글자색" },
      "tournament-team-hover-bg": { label: "팀명 Hover 배경", desc: "팀명 Hover 배경" },
      "tournament-winner": { label: "승자 강조 색", desc: "승자 텍스트/테두리 색" },
      "tournament-winner-shadow": { label: "승자 텍스트 그림자", desc: "승자 텍스트 글로우(그림자)" },
      "tournament-winner-glow": { label: "승자 카드 글로우", desc: "승자 카드 외곽 글로우" },
      "tournament-winner-bg2": { label: "승자 카드 보조 배경", desc: "승자 카드 그라데이션 두번째 색" },

      "final-title-text": { label: "FINAL 제목 텍스트", desc: "FINAL MATCH 타이틀 텍스트 색" },
      "final-title-shadow": { label: "FINAL 제목 그림자", desc: "FINAL MATCH 타이틀 그림자" },

      "champion-grad-from": { label: "우승 배지 그라데이션(1)", desc: "Champion 배지 그라데이션 첫 색" },
      "champion-grad-mid": { label: "우승 배지 그라데이션(2)", desc: "Champion 배지 그라데이션 중간 색" },
      "champion-grad-to": { label: "우승 배지 그라데이션(3)", desc: "Champion 배지 그라데이션 마지막 색" },
      "champion-text": { label: "우승 배지 메인 텍스트", desc: "🏆 우승자 이름 텍스트" },
      "champion-subtext": { label: "우승 배지 서브 텍스트", desc: "Champion 라벨(작은 글씨)" },
      "champion-ring": { label: "우승 배지 링", desc: "배지 외곽 링(반투명 흰색)" },
      "champion-shadow": { label: "우승 배지 그림자", desc: "배지 전체 글로우/그림자" },

      "trophy-placeholder-bg": { label: "우승 미정 아이콘 배경", desc: "우승자 미정 시 원형 배경" },
      "trophy-placeholder-border": { label: "우승 미정 아이콘 테두리", desc: "우승자 미정 시 원형 테두리" },
      "trophy-placeholder-icon": { label: "우승 미정 아이콘 색", desc: "우승자 미정 트로피 아이콘 색" },

      // Tournament toolbar
      "control-pill-bg": { label: "토너먼트 툴바 배경", desc: "우측 상단 줌/초기화/새창 버튼 패널 배경" },
      "control-pill-border": { label: "토너먼트 툴바 테두리", desc: "우측 상단 툴바 패널 보더" },
      "control-icon": { label: "툴바 아이콘(기본)", desc: "우측 상단 버튼 아이콘 기본 색" },
      "control-icon-hover": { label: "툴바 아이콘(Hover)", desc: "우측 상단 버튼 Hover 아이콘 색" },
      "control-hover-bg": { label: "툴바 버튼 Hover 배경", desc: "우측 상단 버튼 Hover 배경" },
      "control-divider": { label: "툴바 구분선", desc: "우측 상단 툴바 내부 구분선" },
      "control-helper-text": { label: "툴바 안내 텍스트", desc: "Drag 등의 도움말 텍스트" },
    };

    const getThemeLabel = (k) => (THEME_META[k]?.label || k);
    const getThemeDesc = (k) => (THEME_META[k]?.desc || "");

    const clamp = (n, min, max) => Math.min(max, Math.max(min, n));

    const rgbToHex = (r, g, b) => {
      const toHex = (x) => x.toString(16).padStart(2, '0');
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    };

    const hexToRgb = (hex) => {
      const h = (hex || '').trim().replace('#','');
      if (h.length === 3) {
        const r = parseInt(h[0]+h[0], 16);
        const g = parseInt(h[1]+h[1], 16);
        const b = parseInt(h[2]+h[2], 16);
        return { r, g, b, a: 1 };
      }
      if (h.length === 6) {
        const r = parseInt(h.slice(0,2), 16);
        const g = parseInt(h.slice(2,4), 16);
        const b = parseInt(h.slice(4,6), 16);
        return { r, g, b, a: 1 };
      }
      return null;
    };

    const parseRgbLike = (s) => {
      const str = (s || '').trim();
      if (!str) return null;
      if (str.toLowerCase() === 'transparent') return { r: 0, g: 0, b: 0, a: 0 };
      const m = str.match(/rgba?\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)(?:\s*,\s*([0-9]*\.?[0-9]+))?\s*\)/i);
      if (!m) return null;
      const r = clamp(parseInt(m[1], 10), 0, 255);
      const g = clamp(parseInt(m[2], 10), 0, 255);
      const b = clamp(parseInt(m[3], 10), 0, 255);
      const a = m[4] == null ? 1 : clamp(parseFloat(m[4]), 0, 1);
      return { r, g, b, a };
    };

    const formatRgba = (rgba) => {
      const r = clamp(Math.round(rgba.r), 0, 255);
      const g = clamp(Math.round(rgba.g), 0, 255);
      const b = clamp(Math.round(rgba.b), 0, 255);
      const a = clamp(rgba.a ?? 1, 0, 1);
      return `rgba(${r}, ${g}, ${b}, ${a.toFixed(3).replace(/0+$/,'').replace(/\.$/,'')})`;
    };

    const COLOR_TOKEN_RE = /rgba?\(\s*[0-9]+\s*,\s*[0-9]+\s*,\s*[0-9]+(?:\s*,\s*[0-9]*\.?[0-9]+)?\s*\)|#(?:[0-9a-f]{3}|[0-9a-f]{6})\b|\btransparent\b/ig;

    const extractColorTokens = (value) => {
      const v = (value || '');
      COLOR_TOKEN_RE.lastIndex = 0; // ✅ 필수: global regex 상태 초기화
      const out = [];
      let m;
      while ((m = COLOR_TOKEN_RE.exec(v)) !== null) {
        out.push({ start: m.index, end: m.index + m[0].length, token: m[0] });
      }
      return out;
    };

    const tokenToRgba = (token) => {
      const t = (token || '').trim();
      if (!t) return null;
      if (t.toLowerCase() === 'transparent') return { r: 0, g: 0, b: 0, a: 0 };
      if (t.startsWith('#')) return hexToRgb(t);
      return parseRgbLike(t);
    };

    function MultiColorValueEditor({ value, onChange }) {
      const tokens = useMemo(() => extractColorTokens(value), [value]);
      const hasTokens = tokens.length > 0;

      const updateToken = (idx, nextTokenStr) => {
        const t = tokens[idx];
        if (!t) return;
        const updated = value.slice(0, t.start) + nextTokenStr + value.slice(t.end);
        onChange(updated);
      };

      return (
        <div className="flex flex-col gap-2 w-full">
          {hasTokens ? (
            <div className="flex flex-col gap-2">
              {tokens.map((t, idx) => {
                const rgba = tokenToRgba(t.token);
                const hex = rgba ? rgbToHex(rgba.r, rgba.g, rgba.b) : '#000000';
                const alpha = rgba ? clamp(rgba.a ?? 1, 0, 1) : 1;
                const swatch = rgba ? `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${alpha})` : 'transparent';

                const setColor = (nextHex) => {
                  const next = hexToRgb(nextHex);
                  if (!next) return;
                  // Preserve alpha if current token was rgba/transparent or alpha != 1
                  const preferAlpha = /^rgba\(/i.test(t.token) || t.token.toLowerCase()==='transparent' || alpha < 1;
                  const nextStr = preferAlpha ? formatRgba({ ...next, a: alpha }) : rgbToHex(next.r, next.g, next.b);
                  updateToken(idx, nextStr);
                };

                const setAlpha = (nextAlpha01) => {
                  const nextA = clamp(nextAlpha01, 0, 1);
                  if (!rgba) return;
                  updateToken(idx, formatRgba({ ...rgba, a: nextA }));
                };

                return (
                  <div key={idx} className="flex items-center gap-2">
                    <div className="text-[10px] font-bold w-7 text-center rounded border"
                      style={{ borderColor:'var(--table-border)', color:'var(--text-muted)', background:'var(--input-bg)' }}>
                      {idx+1}
                    </div>

                    <div className="w-5 h-5 rounded border" style={{ background: swatch, borderColor: 'var(--table-border)' }} />

                    <input type="color" value={hex} onChange={(e)=>setColor(e.target.value)}
                      className="h-8 w-10 p-0 bg-transparent border rounded"
                      style={{borderColor:'var(--table-border)'}} />

                    <div className="flex items-center gap-2 min-w-[160px]">
                      <span className="text-[11px]" style={{color:'var(--text-muted)'}}>A</span>
                      <input type="range" min="0" max="100" value={Math.round(alpha*100)}
                        onChange={(e)=>setAlpha(parseInt(e.target.value,10)/100)}
                        className="w-28" />
                      <span className="text-[11px] tabular-nums" style={{color:'var(--text-muted)'}}>{Math.round(alpha*100)}%</span>
                    </div>

                    <span className="ml-auto text-[10px] font-mono opacity-70"
                      style={{color:'var(--text-muted)'}} title="편집 중인 토큰">
                      {t.token}
                    </span>
                  </div>
                );
              })}
            </div>
          ) : (
            <div className="text-[11px]" style={{color:'var(--text-muted)'}}>
              이 값은 색상 토큰(#HEX, rgb/rgba, transparent)을 포함하지 않거나 복합 문자열입니다. 아래 텍스트로 직접 편집하세요.
            </div>
          )}

          <input
            className="w-full text-xs px-2 py-1 rounded border"
            style={{ background:'var(--input-bg)', borderColor:'var(--table-border)', color:'var(--text-main)' }}
            value={value || ''}
            onChange={(e)=>onChange(e.target.value)}
            spellCheck={false}
          />
        </div>
      );
    }

    function ThemeManagerModal({
      open,
      onClose,
      themeKey,
      setThemeKey,
      themeValues,
      onChangeValue,
      onSaveToBrowser,
      onExportFile,
      onImportFile,
      onResetTheme
    }) {
      const fileRef = useRef(null);
      // 카테고리 접기/펼치기 상태
      const [openCats, setOpenCats] = useState(() => Object.fromEntries(THEME_CATEGORIES.map(c => [c.id, true])));
      const [query, setQuery] = useState("");

      // --------------------------------------------------------
      // [추가] 윈도우 이동/크기조절 상태 관리
      // --------------------------------------------------------
      // 초기 위치: 화면 중앙쯤, 크기: 800x600
      const [winState, setWinState] = useState({
        x: typeof window !== 'undefined' ? window.innerWidth / 2 - 400 : 100,
        y: 100,
        w: 800,
        h: 600
      });

      const dragRef = useRef({ mode: null, startX: 0, startY: 0, initX: 0, initY: 0, initW: 0, initH: 0 });

      // 드래그/리사이즈 이벤트 핸들러
      useEffect(() => {
        const onMouseMove = (e) => {
          if (!dragRef.current.mode) return;
          e.preventDefault();
          const { mode, startX, startY, initX, initY, initW, initH } = dragRef.current;
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;

          if (mode === 'move') {
            setWinState(prev => ({ ...prev, x: initX + dx, y: initY + dy }));
          } else if (mode === 'resize') {
            setWinState(prev => ({
              ...prev,
              w: Math.max(400, initW + dx), // 최소 너비 400
              h: Math.max(300, initH + dy)  // 최소 높이 300
            }));
          }
        };

        const onMouseUp = () => {
          if (dragRef.current.mode) {
            dragRef.current.mode = null;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
          }
        };

        if (open) {
          window.addEventListener('mousemove', onMouseMove);
          window.addEventListener('mouseup', onMouseUp);
        }
        return () => {
          window.removeEventListener('mousemove', onMouseMove);
          window.removeEventListener('mouseup', onMouseUp);
        };
      }, [open]);

      const startMove = (e) => {
        // 헤더 버튼 클릭 시 드래그 방지
        if (e.target.closest('button') || e.target.closest('input')) return;
        dragRef.current = {
          mode: 'move',
          startX: e.clientX, startY: e.clientY,
          initX: winState.x, initY: winState.y,
          initW: winState.w, initH: winState.h
        };
        document.body.style.userSelect = 'none';
      };

      const startResize = (e) => {
        e.stopPropagation();
        dragRef.current = {
          mode: 'resize',
          startX: e.clientX, startY: e.clientY,
          initX: winState.x, initY: winState.y,
          initW: winState.w, initH: winState.h
        };
        document.body.style.userSelect = 'none';
        document.body.style.cursor = 'nwse-resize';
      };

      useEffect(() => {
        if (open) setQuery("");
      }, [open]);

      if (!open) return null;

      const q = (query || '').trim().toLowerCase();
      const keyMatches = (k) => {
        if (!q) return true;
        return (
          k.toLowerCase().includes(q) ||
          getThemeLabel(k).toLowerCase().includes(q) ||
          getThemeDesc(k).toLowerCase().includes(q)
        );
      };

      return (
        // 배경 오버레이 (클릭 시 닫힘) -> 배경 클릭이 필요 없다면 pointer-events-none 처리 가능
        <div className="fixed inset-0 z-[9999]">
          <div className="absolute inset-0" style={{background:'var(--modal-overlay-bg)'}} onClick={onClose}></div>

          {/* [변경] 위치/크기를 state로 제어하는 윈도우 컨테이너 
             - 기존: 중앙 정렬된 정적 div
             - 변경: fixed position + style로 x, y, w, h 제어
          */}
          <div 
            className="absolute flex flex-col rounded-2xl border shadow-2xl overflow-hidden"
            style={{
              left: winState.x,
              top: winState.y,
              width: winState.w,
              height: winState.h,
              background: 'var(--bg-body)',
              borderColor: 'var(--card-border)',
              transition: dragRef.current.mode ? 'none' : 'box-shadow 0.2s' // 드래그 중엔 부드럽게
            }}
          >
            {/* [변경] 헤더: onMouseDown 이벤트 추가 (드래그 시작점)
               - cursor: move 추가
            */}
            <div 
              className="flex items-center justify-between px-4 py-3 border-b cursor-move flex-none select-none"
              style={{borderColor:'var(--table-border)', background: 'var(--table-header-bg)'}}
              onMouseDown={startMove}
            >
              <div className="flex items-center gap-2 pointer-events-none">
                <span className="inline-flex items-center justify-center w-8 h-8 rounded-xl border"
                  style={{borderColor:'var(--table-border)', background:'var(--card-bg)'}}>
                  <Icons.Settings size={16} />
                </span>
                <div>
                  <div className="font-bold tracking-tight" style={{color:'var(--text-main)'}}>테마 관리</div>
                </div>
              </div>

              <div className="flex items-center gap-2">
                 {/* 닫기 버튼 */}
                <button className="px-3 py-1.5 rounded-lg border text-xs font-bold hover:bg-red-500/10 hover:text-red-500 hover:border-red-500/50 transition-colors"
                  style={{borderColor:'var(--table-border)', color:'var(--text-muted)'}}
                  onClick={onClose}>
                  <Icons.X size={14}/>
                </button>
              </div>
            </div>

            {/* 툴바 영역 (크기 고정) */}
            <div className="px-4 py-3 flex-none border-b" style={{borderColor:'var(--divider)'}}>
                <div className="flex flex-wrap items-center gap-2">
                  <button onClick={()=>setThemeKey('dark')}
                    className={`px-3 py-2 rounded-xl border text-sm font-semibold transition-all ${themeKey==='dark' ? 'opacity-100 ring-2 ring-offset-1 ring-offset-transparent' : 'opacity-70 hover:opacity-100'}`}
                    style={{
                      borderColor: themeKey==='dark' ? 'var(--accent)' : 'var(--table-border)',
                      color: 'var(--text-main)',
                      background: themeKey==='dark' ? 'var(--highlight-bg)' : 'transparent',
                      '--tw-ring-color': 'var(--accent)'
                    }}
                  >다크</button>

                  <button onClick={()=>setThemeKey('light')}
                    className={`px-3 py-2 rounded-xl border text-sm font-semibold transition-all ${themeKey==='light' ? 'opacity-100 ring-2 ring-offset-1 ring-offset-transparent' : 'opacity-70 hover:opacity-100'}`}
                    style={{
                      borderColor: themeKey==='light' ? 'var(--accent)' : 'var(--table-border)',
                      color: 'var(--text-main)',
                      background: themeKey==='light' ? 'var(--highlight-bg)' : 'transparent',
                      '--tw-ring-color': 'var(--accent)'
                    }}
                  >라이트</button>

                  <div className="ml-auto flex flex-wrap items-center gap-2">
                    <input
                      value={query}
                      onChange={(e)=>setQuery(e.target.value)}
                      placeholder="검색..."
                      className="px-3 py-2 rounded-xl border text-sm w-32 focus:w-48 transition-all"
                      style={{ background:'var(--input-bg)', borderColor:'var(--table-border)', color:'var(--text-main)' }}
                    />
                    
                    {/* 버튼들을 아이콘으로 간소화하여 공간 절약 */}
                    <button onClick={onResetTheme} className="p-2 rounded-xl border" title="초기화" style={{borderColor:'var(--table-border)', color:'var(--text-main)'}}><Icons.Refresh size={16}/></button>
                    <button onClick={onSaveToBrowser} className="p-2 rounded-xl border" title="브라우저 저장" style={{borderColor:'var(--table-border)', color:'var(--text-main)'}}><Icons.Save size={16}/></button>
                    <button onClick={onExportFile} className="p-2 rounded-xl border" title="내보내기" style={{borderColor:'var(--table-border)', color:'var(--text-main)'}}><Icons.Upload size={16} className="rotate-180"/></button>
                    <button onClick={()=>fileRef.current?.click()} className="p-2 rounded-xl border" title="불러오기" style={{borderColor:'var(--table-border)', color:'var(--text-main)'}}><Icons.Upload size={16}/></button>
                    
                    <input ref={fileRef} type="file" accept=".json" className="hidden"
                      onChange={(e)=> { const f = e.target.files?.[0]; if (f) onImportFile(f); e.target.value = ''; }}
                    />
                  </div>
                </div>
            </div>

            {/* 메인 컨텐츠 (스크롤 가능) */}
            <div className="flex-1 overflow-hidden flex flex-col relative">
                <div className="flex-1 overflow-y-auto p-4 custom-scrollbar">
                  <div className="rounded-2xl border overflow-hidden" style={{borderColor:'var(--table-border)'}}>
                    <div className="grid grid-cols-12 px-3 py-2 text-xs font-bold sticky top-0 z-10"
                      style={{background:'var(--table-header-bg)', color:'var(--text-muted)', borderBottom: '1px solid var(--table-border)'}}>
                      <div className="col-span-4">항목</div>
                      <div className="col-span-8">값</div>
                    </div>

                    <div className="">
                      {THEME_CATEGORIES.map((cat) => {
                        const catKeys = (cat.keys || []).filter(k => THEME_KEYS.includes(k)).filter(keyMatches);
                        if (!catKeys.length) return null;
                        const isOpen = !!openCats[cat.id];

                        return (
                          <div key={cat.id}>
                            <button
                              type="button"
                              className="w-full flex items-center justify-between px-3 py-2 border-t text-sm font-bold"
                              style={{borderColor:'var(--table-cell-border)', background:'var(--highlight-bg)', color:'var(--text-main)'}}
                              onClick={() => setOpenCats(p => ({...p, [cat.id]: !p[cat.id]}))}
                            >
                              <div className="flex items-center gap-2">
                                {isOpen ? <Icons.ChevronDown size={16}/> : <Icons.ChevronRight size={16}/>}
                                <span>{cat.label}</span>
                                <span className="text-xs font-normal" style={{color:'var(--text-muted)'}}>({catKeys.length})</span>
                              </div>
                            </button>

                            {isOpen && catKeys.map((k) => (
                              <div key={k} className="grid grid-cols-12 gap-2 px-3 py-2 border-t items-start"
                                style={{borderColor:'var(--table-cell-border)'}}>
                                <div className="col-span-4 pt-1">
                                  <div className="text-xs font-semibold break-keep" style={{color:'var(--text-main)'}}>{getThemeLabel(k)}</div>
                                  <div className="font-mono text-[9px] mt-0.5 opacity-60 truncate" style={{color:'var(--text-muted)'}} title={`--${k}`}>--{k}</div>
                                </div>
                                <div className="col-span-8">
                                  <MultiColorValueEditor value={themeValues?.[k] ?? ''} onChange={(v)=>onChangeValue(k, v)} />
                                </div>
                              </div>
                            ))}
                          </div>
                        );
                      })}
                    </div>
                  </div>
                  
                  <div className="text-xs mt-4 mb-2 leading-relaxed opacity-70" style={{color:'var(--text-muted)'}}>
                    * 윈도우 우측 하단을 드래그하여 크기를 조절할 수 있습니다.
                  </div>
                </div>
            </div>

            {/* [추가] 리사이즈 핸들 */}
            <div 
              className="absolute bottom-0 right-0 w-5 h-5 cursor-nwse-resize z-20"
              style={{
                background: 'linear-gradient(135deg, transparent 50%, var(--resize-handle-accent, #38bdf8) 50%)',
                opacity: 0.8
              }}
              onMouseDown={startResize}
            />
          </div>
        </div>
      );
    }

    // ----------------------------------------------------------
    // Main App
    // ----------------------------------------------------------
    function PingPongManager() {
      const DATA_STORAGE_KEY = 'pingpong_data_autosave_v1';
      // 저장된 데이터가 있으면 불러오고, 없으면 기본값(fallback)을 사용하는 헬퍼 함수
	const getSavedState = (key, fallback) => {
	  try {
	    const saved = localStorage.getItem(DATA_STORAGE_KEY);
	    if (!saved) return fallback;
	    const parsed = JSON.parse(saved);
	    // 저장된 객체 안에 해당 key가 있으면 반환, 없으면 기본값 반환
	    return parsed[key] !== undefined ? parsed[key] : fallback;
	  } catch (e) {
	    console.error("Data load failed", e);
	    return fallback;
	  }
	};
	
      const [activeTab, setActiveTab] = useState('register');
      const [isDarkMode, setIsDarkMode] = useState(true);
      const [themeMenuOpen, setThemeMenuOpen] = useState(false);
      const [themeManagerOpen, setThemeManagerOpen] = useState(false);
      const [themeManagerTab, setThemeManagerTab] = useState('dark');
      const themeMenuRef = useRef(null);

      const [themeDefaults, setThemeDefaults] = useState(null);
      const [themeOverrides, setThemeOverrides] = useState(null);

      // Apply overrides to live UI
      useEffect(() => {
        if (!themeOverrides) return;
        let el = document.getElementById('theme-overrides-style');
        if (!el) {
          el = document.createElement('style');
          el.id = 'theme-overrides-style';
          document.head.appendChild(el);
        }
        const cssFor = (selector, vars) => {
          const entries = THEME_KEYS.map(k => `--${k}:${(vars?.[k] ?? '').trim()};`).join('');
          return `${selector}{${entries}}`;
        };
        el.textContent = cssFor(':root', themeOverrides.dark) + cssFor('body.light-mode', themeOverrides.light);
      }, [themeOverrides]);

      //const [teams, setTeams] = useState([]);
      const [teams, setTeams] = useState(() => getSavedState('teams', []));
      
      //const [groups, setGroups] = useState([]);
      const [groups, setGroups] = useState(() => getSavedState('groups', []));
      
      //const [tournamentData, setTournamentData] = useState({ type: 'single', brackets: [] });
      const [tournamentData, setTournamentData] = useState(() => getSavedState('tournamentData', { type: 'single', brackets: [] }));
      
      //const [isLeagueGenerated, setIsLeagueGenerated] = useState(false);
      const [isLeagueGenerated, setIsLeagueGenerated] = useState(() => getSavedState('isLeagueGenerated', false));
      
      //const [cardSizes, setCardSizes] = useState({});
      const [cardSizes, setCardSizes] = useState(() => getSavedState('cardSizes', {}));
      
      const [zoom, setZoom] = useState(0.85);
      const [pan, setPan] = useState({ x: 0, y: 0 });
      const [isDragging, setIsDragging] = useState(false);
      const dragStart = useRef({ x: 0, y: 0 });
      const [isAdminMode, setIsAdminMode] = useState(false);
      const [autoGenCount, setAutoGenCount] = useState(1);
      const [sortMode, setSortMode] = useState('input');
      const [editingTeamId, setEditingTeamId] = useState(null);
      const [editTeamData, setEditTeamData] = useState(null);
      const [hoverState, setHoverState] = useState(null);
      const [printGroupId, setPrintGroupId] = useState(null);
      const [swapModalData, setSwapModalData] = useState(null);

      /*
      const [config, setConfig] = useState({
        teamSize: 1, minSumLevel: '', groupCount: 4,
        tournamentMode: 'all', topN: 2, rankMethod: '1',
      });
      */
      const [config, setConfig] = useState(() => getSavedState('config', {
        teamSize: 1, minSumLevel: '', groupCount: 4,
        tournamentMode: 'all', topN: 2, rankMethod: '1',
      }));
      
      const [newTeamName, setNewTeamName] = useState('');
      const [newMembers, setNewMembers] = useState([{ name: '', level: '' }]);

      useEffect(() => {
        setNewMembers(Array(config.teamSize).fill({ name: '', level: '' }));
      }, [config.teamSize]);

      useEffect(() => {
        if (isDarkMode) document.body.classList.remove('light-mode');
        else document.body.classList.add('light-mode');
      }, [isDarkMode]);

      // Close theme menu on outside click
      useEffect(() => {
        const onDown = (e) => {
          if (!themeMenuOpen) return;
          const el = themeMenuRef.current;
          if (el && !el.contains(e.target)) setThemeMenuOpen(false);
        };
        window.addEventListener('mousedown', onDown);
        return () => window.removeEventListener('mousedown', onDown);
      }, [themeMenuOpen]);

      // Theme manager helpers
      useEffect(() => { setThemeManagerTab(isDarkMode ? 'dark' : 'light'); }, [themeManagerOpen]);
      useEffect(() => { if (themeManagerOpen) setIsDarkMode(themeManagerTab === 'dark'); }, [themeManagerOpen, themeManagerTab]);

	useEffect(() => {
	  // 저장할 데이터 객체 생성
	  const dataToSave = {
	    teams,
	    groups,
	    tournamentData,
	    isLeagueGenerated,
	    cardSizes,
	    config
	  };
	  
	  // 로컬 스토리지에 JSON 문자열로 변환하여 저장
	  localStorage.setItem(DATA_STORAGE_KEY, JSON.stringify(dataToSave));
	  
	  // 디버깅용 로그 (개발 완료 후 삭제 가능)
	  // console.log('Data auto-saved to local storage');
	  
	}, [teams, groups, tournamentData, isLeagueGenerated, cardSizes, config]);

      const updateThemeValue = (varKey, nextValue) => {
        setThemeOverrides(prev => {
          if (!prev) return prev;
          return { ...prev, [themeManagerTab]: { ...prev[themeManagerTab], [varKey]: nextValue } };
        });
      };

      const saveThemeToBrowser = () => {
        try {
          const payload = { version: 2, themes: themeOverrides || {} };
          localStorage.setItem(THEME_STORAGE_KEY, JSON.stringify(payload));
          toast('테마가 브라우저에 저장되었습니다.');
        } catch (e) { 
          // [수정] 용량 초과 에러 구체적 명시
          if (e.name === 'QuotaExceededError') {
            toast('저장 용량이 부족합니다. 불필요한 데이터를 정리해주세요.');
          } else {
            toast('저장에 실패했습니다. (알 수 없는 오류)');
          }
        }
      };

      const exportThemeFile = () => {
        try {
          const payload = { version: 2, themes: themeOverrides || {} };
          const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = THEME_FILE_NAME;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
          toast('테마 파일을 내보냈습니다.');
        } catch (e) { toast('내보내기에 실패했습니다.'); }
      };

      const importThemeFile = (file) => {
        try {
          const reader = new FileReader();
          reader.onload = () => {
            try {
              const parsed = JSON.parse(reader.result);
              if (!parsed || typeof parsed !== 'object' || !parsed.themes) {
                toast('올바른 테마 파일이 아닙니다.');
                return;
              }
              setThemeOverrides(prev => {
                if (!prev) return prev;
                const next = {
                  dark: { ...prev.dark, ...(parsed.themes.dark || {}) },
                  light: { ...prev.light, ...(parsed.themes.light || {}) }
                };
                return next;
              });
              toast('테마 파일을 불러왔습니다.');
            } catch (e) { toast('파일 해석에 실패했습니다.'); }
          };
          reader.readAsText(file, 'utf-8');
        } catch (e) { toast('파일 불러오기에 실패했습니다.'); }
      };

      const resetThemeToDefaults = () => {
        if (!themeDefaults || !themeOverrides) return;
        setThemeOverrides(prev => {
          if (!prev) return prev;
          return { ...prev, [themeManagerTab]: { ...themeDefaults[themeManagerTab] } };
        });
        toast('기본값으로 초기화했습니다.');
      };

      // Load theme defaults + saved overrides (file > localStorage) and apply
      useLayoutEffect(() => {
        const wasLight = document.body.classList.contains('light-mode');

        document.body.classList.remove('light-mode');
        const rootStyle = getComputedStyle(document.documentElement);
        const dark = {};
        THEME_KEYS.forEach(k => { dark[k] = rootStyle.getPropertyValue(`--${k}`).trim(); });

        document.body.classList.add('light-mode');
        const bodyStyle = getComputedStyle(document.body);
        const light = {};
        THEME_KEYS.forEach(k => {
          const v = bodyStyle.getPropertyValue(`--${k}`).trim();
          light[k] = v || dark[k] || '';
        });

        if (wasLight) document.body.classList.add('light-mode');
        else document.body.classList.remove('light-mode');

        const defaults = { dark, light };
        setThemeDefaults(defaults);

        const merge = (base, patch) => {
          const out = { dark: { ...base.dark }, light: { ...base.light } };
          if (patch?.themes?.dark) out.dark = { ...out.dark, ...patch.themes.dark };
          if (patch?.themes?.light) out.light = { ...out.light, ...patch.themes.light };
          // Ensure all keys exist
          THEME_KEYS.forEach(k => {
            if (out.dark[k] == null || out.dark[k] === '') out.dark[k] = base.dark[k] || '';
            if (out.light[k] == null || out.light[k] === '') out.light[k] = base.light[k] || '';
          });
          return out;
        };

        const fromLocalStorage = () => {
          try {
            const raw = localStorage.getItem(THEME_STORAGE_KEY);
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            if (!parsed || typeof parsed !== 'object') return null;
            return parsed;
          } catch (_) { return null; }
        };

        (async () => {
          let ov = { dark: { ...defaults.dark }, light: { ...defaults.light } };

          try {
            const url = new URL(THEME_FILE_NAME, window.location.href).toString();
            const res = await fetch(url, { cache: 'no-store' });
            if (res.ok) {
              const parsed = await res.json();
              ov = merge(ov, parsed);
              setThemeOverrides(ov);
              return;
            }
          } catch (_) {}

          const saved = fromLocalStorage();
          if (saved) ov = merge(ov, saved);
          setThemeOverrides(ov);
        })();
      }, []);
      
	// [추가] 팀명 자동 생성 규칙 통합
	const buildAutoTeamName = (members, teamSize) => {
	  const size = Number(teamSize) || (members?.length ?? 0);

	  // 3인 이상 단체전 + 팀명 미지정일 때: "첫번째(실제로는 첫 유효 이름) + 팀"
	  if (size >= 3) {
	    const firstName = (members || [])
	      .map(m => (m?.name || '').trim())
	      .find(n => n.length > 0);

	    if (firstName) return `${firstName}팀`;
	  }

	  // 그 외(1~2인 경기) 또는 이름이 비어있어 첫이름을 못 찾은 경우: 기존 방식 유지
	  return (members || [])
	    .map(m => `${(m?.name || '').trim()}(${m?.level || 0}부)`)
	    .join(', ');
	};
	
	// [추가] 팀원 입력값 정규화: name trim, level 공백이면 0으로 보정
	const normalizeMembers = (members) => {
	  return (members || []).map((m) => {
	    const name = String(m?.name ?? '').trim();

	    const rawLevel = String(m?.level ?? '').trim();
	    const parsed = rawLevel === '' ? 0 : parseInt(rawLevel, 10);
	    const level = Number.isFinite(parsed) ? parsed : 0;

	    return { ...m, name, level };
	  });
	};
	
	// [추가] 예선 리그 표시에 쓰는 팀명 규칙
	const getLeagueDisplayName = (team) => {
	  const size = team?.members?.length ?? 0;
	  const fixedName = String(team?.name ?? '').trim();

	  // ✅ 3인 이상: 팀 목록에서 정해진 팀명 우선 사용
	  if (size >= 3) return fixedName || buildAutoTeamName(team?.members, size);

	  // 1~2인은 기존 방식 유지(현재 team.name 자체가 이미 기존 규칙을 따르고 있음)
	  return fixedName || buildAutoTeamName(team?.members, size);
	};
      // ----------------------------------------------------------
      // Teams / League logic (mostly original)
      // ----------------------------------------------------------
      const handleMemberChange = (idx, field, val) => {
        const u = [...newMembers];
        u[idx] = { ...u[idx], [field]: val };
        setNewMembers(u);
      };

      const addTeam = () => {
	  // 1) 멤버 정규화 (level 공백 -> 0)
	  const normalizedMembers = normalizeMembers(newMembers);

	  // 2) 이름 검증: 하나라도 비면 등록 불가
	  const hasEmptyName = normalizedMembers.some(m => !m.name);
	  if (hasEmptyName) {
	    toast('팀원 이름을 모두 입력해야 등록할 수 있습니다.');
	    return;
	  }

	  // 3) 합부수 계산 (정규화된 level 기반)
	  const totalLevel = normalizedMembers.reduce((s, m) => s + (parseInt(m.level || 0, 10) || 0), 0);

	  // 4) 최소 합부수 조건 체크
	  const minSum = parseInt(config.minSumLevel, 10) || 0;
	  if (totalLevel < minSum) {
	    toast(`팀 합산 부수 ${minSum} 이상 필요`);
	    return;
	  }

	  // 5) 팀명 결정 (기존 규칙 유지)
	  let teamName = newTeamName.trim();
	  if (!teamName) teamName = buildAutoTeamName(normalizedMembers, config.teamSize);

	  setTeams([
	    ...teams,
	    {
	      id: Date.now(),
	      name: teamName,
	      members: normalizedMembers, // ✅ 보정된 값 저장
	      totalLevel,
	      totalAge: 0,
	      stats: { wins: 0, losses: 0 },
	      groupId: null
	    }
	  ]);

	  setNewTeamName('');

	  // (권장) fill 대신 Array.from으로 객체 참조 공유 방지
	  setNewMembers(Array.from({ length: config.teamSize }, () => ({ name: '', level: '' })));
      };

      const generateRandomTeams = () => {
        const count = parseInt(autoGenCount) || 1;
        const teamSize = parseInt(config.teamSize) || 1;
        const minSum = parseInt(config.minSumLevel) || 0;

        const MIN_LEVEL = 1;
        const MAX_LEVEL = 9;
        
        const MAX_POSSIBLE_SCORE = teamSize * MAX_LEVEL;
        let targetSum = parseInt(config.minSumLevel) || 0;
        if (targetSum > MAX_POSSIBLE_SCORE) {
          alert(`설정된 최소 합부수(${targetSum})가 생성 가능한 최대치(${MAX_POSSIBLE_SCORE})보다 높습니다. 최대치로 조정합니다.`);
          targetSum = MAX_POSSIBLE_SCORE;
        }

        const makeLevels = () => {
          if (!minSum || minSum <= 0) {
            return Array.from({ length: teamSize }, () => (MIN_LEVEL + Math.floor(Math.random() * (MAX_LEVEL - MIN_LEVEL + 1))));
          }

          const capacity = teamSize * MAX_LEVEL;
          //const target = Math.min(minSum, capacity);
          const target = targetSum;

          const levels = Array(teamSize).fill(MIN_LEVEL);
          let remaining = target - (teamSize * MIN_LEVEL);

          let guard = 0;
          while (remaining > 0 && guard < 5000) {
            guard++;
            const idx = Math.floor(Math.random() * teamSize);
            if (levels[idx] < MAX_LEVEL) {
              levels[idx] += 1;
              remaining -= 1;
            }
          }
          return levels;
        };

        const newTeams = [];
        for (let i = 0; i < count; i++) {
          const levels = makeLevels();
          const members = Array.from({ length: teamSize }, (_, idx) => ({
            name: getRandomItem(NAMES),
            level: levels[idx],
          }));
          const totalLevel = levels.reduce((s, v) => s + v, 0);
          // [수정] 자동 생성도 "팀명 미지정" 상태로 보고 동일 규칙 적용
          const name = buildAutoTeamName(members, teamSize);
          newTeams.push({
            id: Date.now() + Math.random() + i,
            name,
            members,
            totalLevel,
            totalAge: 0,
            stats: { wins: 0, losses: 0 },
            groupId: null
          });
        }

        if (minSum && (teamSize * MAX_LEVEL) < minSum) {
          alert(`합산 부수 목표(${minSum})가 팀 인원수 기준 최대치(${teamSize * MAX_LEVEL})를 초과하여, 최대치로 자동 조정했습니다.`);
        }

        setTeams([...teams, ...newTeams]);
      };

      const removeTeam = (id) => { if(confirm('삭제?')) setTeams(teams.filter(t => t.id !== id)); };
      const clearAllTeams = () => { if(teams.length && confirm("전체 삭제?")) { setTeams([]); setIsLeagueGenerated(false); setGroups([]); } };

      const startEditing = (team) => { setEditingTeamId(team.id); setEditTeamData(JSON.parse(JSON.stringify(team))); };
      const cancelEditing = () => { setEditingTeamId(null); setEditTeamData(null); };
      const saveEditing = () => {
	  const normalizedMembers = normalizeMembers(editTeamData.members);

	  if (normalizedMembers.some(m => !m.name)) {
	    toast('팀원 이름을 모두 입력해야 저장할 수 있습니다.');
	    return;
	  }

	  const totalLevel = normalizedMembers.reduce((s,m)=>s+(parseInt(m.level||0,10)||0),0);

	  const trimmedName = (editTeamData.name || '').trim();
	  const finalName = trimmedName || buildAutoTeamName(normalizedMembers, normalizedMembers.length);

	  const updatedTeam = { ...editTeamData, name: finalName, members: normalizedMembers, totalLevel };

	  const updatedTeams = teams.map(t => t.id === updatedTeam.id ? updatedTeam : t);
	  setTeams(updatedTeams); setEditingTeamId(null);

	  if (isLeagueGenerated) rebuildGroupsFromTeams(updatedTeams);
      };

      const handleEditChange = (field, val, mIdx = -1, mField = '') => {
        if (mIdx === -1) setEditTeamData({ ...editTeamData, [field]: val });
        else {
          const u = [...editTeamData.members];
          u[mIdx] = { ...u[mIdx], [mField]: val };
          setEditTeamData({ ...editTeamData, members: u });
        }
      };

      const handleGroupChange = (tId, gId) => {
        const updatedTeams = teams.map(t => t.id === tId ? { ...t, groupId: parseInt(gId) } : t);
        setTeams(updatedTeams);
        if(isLeagueGenerated) rebuildGroupsFromTeams(updatedTeams);
      };

      const generateGroups = () => {
        if (teams.length < config.groupCount) return alert("팀 부족");

        const avgTeams = teams.length / config.groupCount;
        if (avgTeams < 2) return alert("한 조당 최소 2팀 이상이 되도록 조 개수를 줄여주세요.");
        if (avgTeams > 12) return alert("한 조당 최대 12팀 이하가 되도록 조 개수를 늘려주세요.");

        const sortedTeams = [...teams].sort((a, b) => a.totalLevel - b.totalLevel);
        const updatedTeams = sortedTeams.map((t, i) => {
          const round = Math.floor(i / config.groupCount);
          return { ...t, groupId: (round % 2 === 0) ? (i % config.groupCount) : (config.groupCount - 1 - (i % config.groupCount)) };
        });

        setTeams(updatedTeams);
        rebuildGroupsFromTeams(updatedTeams);
        setIsLeagueGenerated(true);

        const initSizes = {};
        for(let i=0; i<config.groupCount; i++) initSizes[i] = { w: 480, h: 'auto' };
        setCardSizes(initSizes);
        setActiveTab('league');
      };

      const rebuildGroupsFromTeams = (currentTeams) => {
        const matrixMap = {};
        groups.forEach(g => matrixMap[g.id] = g.matrix);

        let newGroups = Array.from({ length: config.groupCount }, (_, i) => ({
          id: i,
          name: `조 ${i + 1}`,
          teams: [],
          matrix: matrixMap[i] || {}
        }));

        currentTeams.forEach(t => {
          if (t.groupId !== null && newGroups[t.groupId]) {
            const exist = groups.find(g => g.id === t.groupId)?.teams.find(old => old.id === t.id);
            newGroups[t.groupId].teams.push({
              ...t,
              leagueStats: exist ? exist.leagueStats : { win: 0, loss: 0, scoreWin: 0, scoreLoss: 0, rank: 0 }
            });
          }
        });
        setGroups(newGroups);
      };

      const getFormattedSchedule = (teamCount) => {
        const schedule = FIXED_MATCH_ORDER[teamCount];
        if (!schedule) return "대진 순서 : 일정 없음";
        const matchesPerBlock = Math.floor(teamCount / 2);
        let formatted = [];
        let currentBlock = [];
        schedule.forEach((match, idx) => {
          currentBlock.push(`${match[0]}:${match[1]}`);
          if (currentBlock.length === matchesPerBlock) {
            formatted.push(currentBlock.join(" "));
            currentBlock = [];
          }
        });
        if (currentBlock.length > 0) formatted.push(currentBlock.join(" "));
        return "대진 순서 : " + formatted.join(" | ");
      };

      const formatPrintTeamName = (name, fallback) => {
        const s = (name || '').trim();
        if (!s) return String(fallback);
        return s.replace(/,\s*/g, '\n');
      };

      const updateMatrixScore = (gId, tA, tB, val) => {
        const updated = groups.map(g => g.id !== gId ? g : { ...g, matrix: { ...g.matrix, [`${tA}_vs_${tB}`]: val } });
        setGroups(recalculateStats(updated, gId));
      };

      const updateStatManual = (gId, tId, field, val) => {
        setGroups(groups.map(g => g.id !== gId ? g : { ...g, teams: g.teams.map(t => t.id !== tId ? t : { ...t, leagueStats: { ...t.leagueStats, [field]: parseInt(val)||0 } }) }));
      };

      const updateRankManual = (gId, tId, val) => {
        setGroups(groups.map(g => g.id!==gId ? g : { ...g, teams: g.teams.map(t => t.id!==tId ? t : { ...t, leagueStats: { ...t.leagueStats, rank: parseInt(val)||0 } }) }));
      };

      const recalculateStats = (gData, gId) => {
        return gData.map(g => {
          if (g.id !== gId) return g;
          const newTeams = g.teams.map(t => {
            let win = 0, loss = 0, sw = 0, sl = 0;
            g.teams.forEach(opp => {
              if (t.id === opp.id) return;
              const my = g.matrix[`${t.id}_vs_${opp.id}`], op = g.matrix[`${opp.id}_vs_${t.id}`];
              const hasScore = (v) => v !== undefined && v !== null && v !== '';
              if (hasScore(my) && hasScore(op)) {
                const m = parseInt(my, 10);
                const o = parseInt(op, 10);
                if (!Number.isNaN(m) && !Number.isNaN(o)) {
                  sw += m; sl += o;
                  if (m > o) win++;
                  else if (m < o) loss++;
                }
              }
            });
            return { ...t, leagueStats: { ...t.leagueStats, win, loss, scoreWin: sw, scoreLoss: sl } };
          });
          return { ...g, teams: newTeams };
        });
      };

      // Sorting helper
      const getSortedTeams = (teams, matrix, rankMethod) => {
        return [...teams].sort((a, b) => {
          const winDiff = (b.leagueStats.win - a.leagueStats.win);
          const scoreDiff = ( (b.leagueStats.scoreWin - b.leagueStats.scoreLoss) - (a.leagueStats.scoreWin - a.leagueStats.scoreLoss) );

          const headToHead = () => {
            const a_vs_b = matrix[`${a.id}_vs_${b.id}`];
            const b_vs_a = matrix[`${b.id}_vs_${a.id}`];
            if (a_vs_b !== undefined && b_vs_a !== undefined && a_vs_b !== '' && b_vs_a !== '') {
              const avb = parseInt(a_vs_b, 10);
              const bva = parseInt(b_vs_a, 10);
              if (!isNaN(avb) && !isNaN(bva)) {
                if (avb > bva) return -1;
                if (bva > avb) return 1;
              }
            }
            return 0;
          };

          switch(rankMethod) {
            case '1':
              if (winDiff !== 0) return winDiff;
              if (headToHead() !== 0) return headToHead();
              return scoreDiff;
            case '2':
              if (winDiff !== 0) return winDiff;
              if (scoreDiff !== 0) return scoreDiff;
              return headToHead();
            case '3':
              if (scoreDiff !== 0) return scoreDiff;
              if (headToHead() !== 0) return headToHead();
              return winDiff;
            case '4':
              if (scoreDiff !== 0) return scoreDiff;
              if (winDiff !== 0) return winDiff;
              return headToHead();
            default:
              return winDiff;
          }
        });
      };

      const recalcAllGroupRanks = (rankMethod) => {
        setGroups(prev =>
          prev.map(g => {
            const sorted = getSortedTeams(g.teams, g.matrix, rankMethod);
            const rankMap = {};
            sorted.forEach((t, i) => { rankMap[t.id] = i + 1; });

            return {
              ...g,
              teams: g.teams.map(t => ({
                ...t,
                leagueStats: { ...t.leagueStats, rank: rankMap[t.id] || 0 }
              }))
            };
          })
        );
      };

      const calculateRank = (gId) => {
        setGroups(groups.map(g => {
          if (g.id !== gId) return g;
          const sorted = getSortedTeams(g.teams, g.matrix, config.rankMethod);
          const rankMap = {}; sorted.forEach((t, i) => rankMap[t.id] = i + 1);
          return { ...g, teams: g.teams.map(t => ({ ...t, leagueStats: { ...t.leagueStats, rank: rankMap[t.id] } })) };
        }));
      };

      const generateAutoLeagueResults = () => {
        if (!confirm("⚠️ 경고: 모든 예선 조의 경기 결과를 자동으로 생성하시겠습니까?\n\n기존에 입력된 점수는 모두 덮어씌워지며, 합산 3점(3:0, 2:1...) 규칙으로 자동 입력되고 순위가 결정됩니다.")) return;
        const newGroups = groups.map(g => {
          const newMatrix = { ...g.matrix };
          let currentTeams = [...g.teams];
          for (let i = 0; i < currentTeams.length; i++) {
            for (let j = i + 1; j < currentTeams.length; j++) {
              const tA = currentTeams[i].id;
              const tB = currentTeams[j].id;
              const scoreA = Math.floor(Math.random() * 4);
              const scoreB = 3 - scoreA;
              newMatrix[`${tA}_vs_${tB}`] = scoreA;
              newMatrix[`${tB}_vs_${tA}`] = scoreB;
            }
          }

          let statsCalculatedTeams = currentTeams.map(t => {
            let win = 0, loss = 0, sw = 0, sl = 0;
            currentTeams.forEach(opp => {
              if (t.id === opp.id) return;
              const my = newMatrix[`${t.id}_vs_${opp.id}`];
              const op = newMatrix[`${opp.id}_vs_${t.id}`];
              if (my !== undefined && op !== undefined) {
                const m = parseInt(my), o = parseInt(op);
                sw += m; sl += o;
                if (m > o) win++; else if (m < o) loss++;
              }
            });
            return { ...t, leagueStats: { ...t.leagueStats, win, loss, scoreWin: sw, scoreLoss: sl } };
          });

          const sortedForRank = getSortedTeams(statsCalculatedTeams, newMatrix, config.rankMethod);
          const rankMap = {};
          sortedForRank.forEach((t, i) => rankMap[t.id] = i + 1);

          const finalTeams = statsCalculatedTeams.map(t => ({
            ...t,
            leagueStats: { ...t.leagueStats, rank: rankMap[t.id] }
          }));

          return { ...g, matrix: newMatrix, teams: finalTeams };
        });
        setGroups(newGroups);
        alert("✅ 모든 경기 결과가 입력되고 순위가 결정되었습니다.");
      };
      
      // Tournament bracket builder (부전승 우선순위 준수 + 충돌 회피)
      const createBracket = (teamList) => {
        const n = teamList.length; if(n<2) return [];
        
        const power = Math.ceil(Math.log2(n)); 
        const totalSlots = Math.pow(2, power);

        // 시드 배정 순서 (Snake Order)
        const getSeedOrder = (slots) => {
          let seeds = [1];
          while (seeds.length < slots) {
            const next = []; const len = seeds.length*2+1;
            seeds.forEach(s => { next.push(s); next.push(len-s); }); seeds = next;
          }
          return seeds;
        };

        const seedOrder = getSeedOrder(totalSlots);
        let bracketSlots = new Array(totalSlots).fill(null);
        
        // 팀 배치: teamList는 이미 [1위 그룹 -> 2위 그룹...] 순서로 정렬됨
        // 따라서 앞쪽 인덱스(상위 시드)일수록 부전승(BYE)과 매칭될 확률이 높음 (Seed 1 vs Seed Last)
        teamList.forEach((t, i) => { bracketSlots[seedOrder.indexOf(i+1)] = t; });
        
        // 빈 자리는 BYE 처리 (최하위 시드 역할)
        bracketSlots = bracketSlots.map(s => s || { id: `bye-${Math.random()}`, name: 'BYE', isBye: true });

        // Helper
        const isConflict = (t1, t2) => {
          if (!t1 || !t2 || t1.isBye || t2.isBye) return false;
          return t1.groupId === t2.groupId;
        };
        const getR1OpponentIdx = (idx) => (idx % 2 === 0) ? idx + 1 : idx - 1;

        // =========================================================================
        // [Pass 1] Round 1 충돌 방지
        // 조건: 상위 시드는 고정, 하위 시드만 교체하되 **BYE는 절대 건드리지 않음**
        // =========================================================================
        for (let i = 0; i < totalSlots; i += 2) {
          const highSeed = bracketSlots[i];
          const lowSeed = bracketSlots[i+1];
          
          // 충돌 발생! (둘 다 BYE가 아니므로 lowSeed는 Real Team임)
          if (isConflict(highSeed, lowSeed)) {
            let swapped = false;

            // 다른 매치들의 하위 시드를 탐색
            for (let j = 0; j < totalSlots; j += 2) {
              if (i === j) continue;

              const targetLow = bracketSlots[j+1];
              const targetHigh = bracketSlots[j];
              
              // [최우선 규칙 보호]
              // 교체 대상(targetLow)이 BYE라면 절대 가져오지 않음.
              // 이유: targetLow가 BYE라는 것은 targetHigh가 상위 시드라 BYE를 받았다는 뜻임.
              // 이걸 가져오면 targetHigh는 BYE를 뺏기고, 내 highSeed(더 낮은 순위일 수 있음)가 BYE를 받게 됨.
              if (targetLow.isBye) continue;

              // 교체 안전 검사
              if (!isConflict(highSeed, targetLow) && !isConflict(targetHigh, lowSeed)) {
                // Swap
                bracketSlots[i+1] = targetLow;
                bracketSlots[j+1] = lowSeed;
                swapped = true;
                break;
              }
            }
          }
        }

        // =========================================================================
        // [Pass 2] Round 2 충돌 방지 (같은 조 1,2위 격돌 방지)
        // 조건: 매치 통째로 교체. (매치 내부의 Seed vs BYE 관계는 유지되므로 안전)
        // =========================================================================
        for (let q = 0; q < totalSlots; q += 4) {
          // Quad: Match A [q, q+1] vs Match B [q+2, q+3]
          const matchA_High = bracketSlots[q];
          const matchB_High = bracketSlots[q+2];

          if (isConflict(matchA_High, matchB_High)) {
            // 다른 Quad의 매치와 통교체 시도
            for (let k = 0; k < totalSlots; k += 4) {
              if (q === k) continue;

              // 후보 Quad의 첫 번째 매치 [k, k+1]의 상위 시드 확인
              const targetHigh = bracketSlots[k];
              
              // 교체 시 Match A와 충돌하지 않는지 확인
              if (!isConflict(matchA_High, targetHigh)) {
                 // 매치 B ([q+2, q+3]) <-> 후보 매치 ([k, k+1]) 통교체
                 const tempH = bracketSlots[q+2];
                 const tempL = bracketSlots[q+3];
                 
                 bracketSlots[q+2] = bracketSlots[k];
                 bracketSlots[q+3] = bracketSlots[k+1];
                 
                 bracketSlots[k] = tempH;
                 bracketSlots[k+1] = tempL;
                 break; 
              }
            }
          }
        }

        // 매치 객체 생성 (기존 유지)
        let round1 = [];
        for(let i=0; i<totalSlots/2; i++) {
          const tA = bracketSlots[i*2], tB = bracketSlots[i*2+1];
          let w = null; 
          if(tA.isBye && tB.isBye) w=tA; 
          else if(tA.isBye) w=tB; 
          else if(tB.isBye) w=tA;
          
          round1.push({ 
            id: `r0-${i}`, 
            nextMatchId: `r1-${Math.floor(i/2)}`, 
            teamA: tA, teamB: tB, 
            winner: w, scoreA:'', scoreB:'' 
          });
        }
        const rounds = [round1];

        while(rounds[rounds.length-1].length > 1) {
          const prev = rounds[rounds.length-1], next = [];
          for(let i=0; i<prev.length/2; i++) {
            const mId = `r${rounds.length}-${i}`;
            prev[i*2].nextMatchId = mId; prev[i*2+1].nextMatchId = mId;
            const tA = prev[i*2].winner;
            const tB = prev[i*2+1].winner;
            let w = null;
            if(tA && tA.isBye && tB && !tB.isBye) w=tB;
            if(tB && tB.isBye && tA && !tA.isBye) w=tA;
            if(tA && tA.isBye && tB && tB.isBye) w=tA;
            next.push({ id: mId, nextMatchId: (rounds.length+1 < power)?`r${rounds.length+1}-${Math.floor(i/2)}`:null, teamA: tA, teamB: tB, winner: w, scoreA:'', scoreB:'' });
          }
          rounds.push(next);
        }
        return rounds;
      };

      // Tournament Generator (순위별 그룹화 및 셔플 추가)
      const generateTournament = () => {
        setTournamentData({ type: 'single', brackets: [] });
        let brackets = [];

        // 특정 순위(rIdx) 팀들을 수집하되, 같은 순위 내에서는 섞어줌 (공정성)
        const gatherTeams = (rIdx) => {
          let c = [];
          groups.forEach(g => {
            const s = [...g.teams].sort((a,b)=>(a.leagueStats.rank||99)-(b.leagueStats.rank||99));
            if(s[rIdx]) {
              c.push({...s[rIdx], sourceLabel: `${g.id + 1}조 ${rIdx + 1}위`});
            }
          });
          // 같은 순위끼리는 랜덤 셔플 (예: 1조 1위가 무조건 1번 시드를 가져가지 않도록)
          return c.sort(() => Math.random() - 0.5);
        };

        if (config.tournamentMode === 'split') {
          let u=[], l=[];
          // 상위부: 1위 그룹, 2위 그룹... 순서대로 쌓음 (절대 순서는 유지)
          for(let r=0; r<config.topN; r++) u.push(...gatherTeams(r));
          // 하위부
          for(let r=config.topN; r<Math.max(...groups.map(g=>g.teams.length)); r++) l.push(...gatherTeams(r));
          
          if(u.length>1) brackets.push({ title: '(상위부)', rounds: createBracket(u) });
          if(l.length>1) brackets.push({ title: '(하위부)', rounds: createBracket(l) });
          setTournamentData({ type: 'split', brackets });
        } else {
          let t = [];
          const limit = config.tournamentMode==='all' ? Math.max(...groups.map(g=>g.teams.length)) : config.topN;
          
          // 1위 그룹 전체 -> 2위 그룹 전체 -> ... 순으로 배열 생성
          // createBracket은 이 순서를 기반으로 시드를 배정하므로
          // 1위 그룹이 가장 높은 시드(부전승 우선권)를 갖게 됨
          for(let r=0; r<limit; r++) t.push(...gatherTeams(r));
          
          if(t.length>1) brackets.push({ title: '토너먼트', rounds: createBracket(t) });
          setTournamentData({ type: 'single', brackets });
        }

        setActiveTab('tournament');
        setZoom(0.85);
        setPan({x:0, y:0});
      };
      
      const openSwapModal = (bracketIdx, roundIdx, matchIdx, side) => setSwapModalData({ bracketIdx, roundIdx, matchIdx, side });

      const executeSwap = (tBIdx, tRIdx, tMIdx, tSide) => {
        const { bracketIdx: sB, roundIdx: sR, matchIdx: sM, side: sSide } = swapModalData;
        const newB = JSON.parse(JSON.stringify(tournamentData.brackets));
        const sMatch = newB[sB].rounds[sR][sM];
        const tMatch = newB[tBIdx].rounds[tRIdx][tMIdx];
        const sTeam = sSide==='teamA'?sMatch.teamA:sMatch.teamB;
        const tTeam = tSide==='teamA'?tMatch.teamA:tMatch.teamB;
        if(sSide==='teamA') sMatch.teamA=tTeam; else sMatch.teamB=tTeam;
        if(tSide==='teamA') tMatch.teamA=sTeam; else tMatch.teamB=sTeam;
        [sMatch, tMatch].forEach(m => {
          m.scoreA=''; m.scoreB=''; m.winner=null;
          if(m.teamA && m.teamA.isBye && m.teamB && !m.teamB.isBye) m.winner = m.teamB;
          else if(m.teamA && !m.teamA.isBye && m.teamB && m.teamB.isBye) m.winner = m.teamA;
        });
        setTournamentData({...tournamentData, brackets: newB});
        setSwapModalData(null);
      };

      const getAllTeams = () => {
        let list = [];
        tournamentData.brackets.forEach((b, bIdx) => {
          if(b.rounds[0]) b.rounds[0].forEach((m, mIdx) => {
            if(m.teamA) list.push({ team: m.teamA, bIdx, rIdx:0, mIdx, side: 'teamA', bTitle: b.title });
            if(m.teamB) list.push({ team: m.teamB, bIdx, rIdx:0, mIdx, side: 'teamB', bTitle: b.title });
          });
        });
        return list;
      };

      const handleScore = (bIdx, rIdx, mIdx, f, v) => {
        const newB = [...tournamentData.brackets];
        const m = newB[bIdx].rounds[rIdx][mIdx];
        m[f] = v;

        const sA = parseInt(m.scoreA), sB = parseInt(m.scoreB);
        m.winner = (!isNaN(sA) && !isNaN(sB)) ? (sA>sB?m.teamA:(sB>sA?m.teamB:null)) : null;

        if(m.nextMatchId) {
          const nextR = newB[bIdx].rounds[rIdx+1];
          const nextM = nextR.find(nm=>nm.id===m.nextMatchId);
          if(nextM) {
            if(mIdx % 2 === 0) nextM.teamA = m.winner;
            else nextM.teamB = m.winner;
            nextM.winner = null; nextM.scoreA = ''; nextM.scoreB = '';
          }
        }
        setTournamentData({...tournamentData, brackets: newB});
      };

      const handleManualWin = (bIdx, rIdx, mIdx, w) => {
        const newB = [...tournamentData.brackets];
        const m = newB[bIdx].rounds[rIdx][mIdx];
        m.winner = w;
        if(m.nextMatchId) {
          const nextR = newB[bIdx].rounds[rIdx+1];
          const nextM = nextR.find(nm=>nm.id===m.nextMatchId);
          if(nextM) {
            if(mIdx % 2 === 0) nextM.teamA = w;
            else nextM.teamB = w;
            nextM.winner = null; nextM.scoreA = ''; nextM.scoreB = '';
          }
        }
        setTournamentData({...tournamentData, brackets: newB});
      };
      
const toggleJointWinner = (bIdx) => {
  const newB = [...tournamentData.brackets];
  // 해당 대진표(bracket)에 isJointWinner 속성 토글 (없으면 true로 생성)
  newB[bIdx].isJointWinner = !newB[bIdx].isJointWinner;
  setTournamentData({ ...tournamentData, brackets: newB });
};

      const openNewWindow = () => {
        const win = window.open('', '_blank');
        const content = document.getElementById('tournament-print-area').innerHTML;
        const styles = document.getElementsByTagName('style')[0].innerHTML;
        const tailwind = '<script src="https://cdn.tailwindcss.com"><\/script>';
        const isLight = document.body.classList.contains('light-mode');
        win.document.write(
          `<html><head><title>Tournament View</title>${tailwind}<style>${styles}
            body { padding: 40px; background-color: var(--bg-body); overflow: visible; color: var(--text-main); }
            .no-print { display: none !important; }
            .tournament-canvas { transform: none !important; }
            .tournament-viewport { overflow: visible !important; height: auto !important; background: none; }
          </style></head><body class="${isLight ? 'light-mode' : ''}">${content}</body></html>`
        );
        win.document.close();
      };

      // Save/Load data (file-based)
      const dataFileInputRef = useRef(null);

      const saveDataAsFile = () => {
        try {
          const defaultName = `pingpong_manager_${new Date().toISOString().slice(0,10)}.json`;
          let fileName = prompt('저장할 파일 이름을 입력하세요.', defaultName);
          if (!fileName) return;
          if (!fileName.toLowerCase().endsWith('.json')) fileName += '.json';

          const payload = {
            version: 1,
            app: 'Table Tennis League Manager',
            exportedAt: new Date().toISOString(),
            data: {
              teams,
              groups,
              tournamentData,
              config,
              isLeagueGenerated,
              cardSizes,
              isDarkMode,
              themeOverrides
            }
          };

          const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);

          const a = document.createElement('a');
          a.href = url;
          a.download = fileName;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);

          toast('파일로 저장했습니다.');
        } catch (e) { toast('저장에 실패했습니다.'); }
      };

      const loadDataFromFile = (file) => {
        try {
          const reader = new FileReader();
          reader.onload = () => {
            try {
              const parsed = JSON.parse(reader.result);
              const d = parsed?.data ?? parsed;
              if (!d || typeof d !== 'object') { toast('올바른 데이터 파일이 아닙니다.'); return; }

              if (Array.isArray(d.teams)) setTeams(d.teams);
              if (Array.isArray(d.groups)) setGroups(d.groups);
              if (d.tournamentData) setTournamentData(d.tournamentData);
              if (d.config) setConfig(d.config);
              if (typeof d.isLeagueGenerated === 'boolean') setIsLeagueGenerated(d.isLeagueGenerated);
              if (d.cardSizes) setCardSizes(d.cardSizes);

              if (typeof d.isDarkMode === 'boolean') setIsDarkMode(d.isDarkMode);
              if (d.themeOverrides) setThemeOverrides(d.themeOverrides);

              toast('파일에서 데이터를 불러왔습니다.');
            } catch (e) { toast('파일 해석에 실패했습니다.'); }
          };
          reader.readAsText(file, 'utf-8');
        } catch (e) { toast('불러오기에 실패했습니다.'); }
      };

      // Tournament pan/zoom
      const handleMouseDown = (e) => { if(activeTab!=='tournament') return; setIsDragging(true); dragStart.current = { x: e.clientX - pan.x, y: e.clientY - pan.y }; };
      const handleMouseMove = (e) => { if (!isDragging) return; e.preventDefault(); setPan({ x: e.clientX - dragStart.current.x, y: e.clientY - dragStart.current.y }); };
      const handleMouseUp = () => setIsDragging(false);

      const displayedTeams = useMemo(() => {
        const s = [...teams];
        if(sortMode==='level') return s.sort((a,b)=>a.totalLevel-b.totalLevel);
        if(sortMode==='group') return s.sort((a,b)=>(a.groupId===null?99:a.groupId)-(b.groupId===null?99:b.groupId));
        return s.sort((a,b)=>a.id-b.id);
      }, [teams, sortMode]);

      const cycleSort = () => setSortMode(prev => prev==='input'?'level':prev==='level'?'group':'input');
      const getSortLabel = () => sortMode==='input'?'등록순':sortMode==='level'?'합부수순':'조별순';

      const getHighlight = (gId, rId, cId) => (!hoverState || hoverState.g !== gId) ? '' : (hoverState.r === rId && hoverState.c === cId) ? 'highlight-active' : (hoverState.r === cId && hoverState.c === rId) ? 'highlight-mirror' : '';

      const getHeaderHighlight = (gId, tId) => {
        if (!hoverState || hoverState.g !== gId) return '';
        if (hoverState.c === tId) return 'highlight-header';
        if (hoverState.r === tId || hoverState.c === tId) return 'highlight-header';
        return '';
      };

      const renderTab = (id, l, I) => {
        const active = activeTab===id;
        return (
          <button
            onClick={()=>setActiveTab(id)}
            className="tab-btn flex items-center gap-2 px-6 py-3 font-medium text-sm transition-all no-print"
            style={{
              borderColor: active ? 'var(--tab-active-border)' : 'transparent',
              color: active ? 'var(--tab-active-text)' : 'var(--tab-inactive-text)',
              backgroundColor: active ? 'var(--tab-active-bg)' : 'transparent'
            }}
          >
            <I size={18}/> {l}
          </button>
        );
      };

      const handlePrint = (groupId) => {
        if (groupId !== null && groupId !== undefined) {
          setPrintGroupId(groupId); document.body.classList.add('printing-single');
          setTimeout(() => { window.print(); document.body.classList.remove('printing-single'); setPrintGroupId(null); }, 100);
        } else { window.print(); }
      };

      return (
        <div className="flex flex-col h-screen overflow-hidden">
          <header className="backdrop-blur-md border-b flex-none z-30 shadow-lg no-print"
            style={{ backgroundColor:'var(--table-header-bg)', borderColor:'var(--table-border)' }}>
            <div className="w-full max-w-[98%] mx-auto px-4 h-16 flex items-center justify-between">
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 rounded-xl font-bold flex items-center justify-center shadow-lg transform rotate-3 brand-logo"></div>
                <h1 className="text-xl font-bold tracking-tight bg-clip-text text-transparent drop-shadow-sm brand-title">
                  탁구 리그전 관리
                  <span className="text-xs font-medium tracking-normal ml-1 border rounded px-1"
                    style={{ borderColor:'var(--table-border)', color:'var(--text-muted)' }}>
                    v1.0
                  </span>
                </h1>
              </div>

              <div className="flex gap-2 items-center">
                <div className="relative" ref={themeMenuRef}>
                  <div className="flex items-center">
                    <Button variant="secondary" onClick={()=>setIsDarkMode(!isDarkMode)} title="테마 전환">
                      {isDarkMode ? <Icons.Sun size={16}/> : <Icons.Moon size={16}/>}
                    </Button>

                    <button
                      className="ml-1 px-2 h-10 rounded-xl border"
                      style={{ background:'var(--btn-secondary-bg)', borderColor:'var(--btn-secondary-border)', color:'var(--btn-secondary-text)' }}
                      onClick={()=>setThemeMenuOpen(v=>!v)}
                      title="테마 옵션"
                      type="button"
                    >
                      <Icons.ChevronDown size={16}/>
                    </button>
                  </div>

                  {themeMenuOpen && (
                    <div className="absolute right-0 mt-2 w-52 rounded-2xl border shadow-xl overflow-hidden"
                      style={{background:'var(--card-bg)', borderColor:'var(--card-border)'}}>
                      <button
                        className="w-full text-left px-4 py-3 text-sm border-b hover:opacity-90"
                        style={{borderColor:'var(--table-border)', color:'var(--text-main)'}}
                        onClick={()=>{ setIsDarkMode(!isDarkMode); setThemeMenuOpen(false); }}
                      >
                        {isDarkMode ? '라이트 모드로 전환' : '다크 모드로 전환'}
                      </button>
                      <button
                        className="w-full text-left px-4 py-3 text-sm hover:opacity-90"
                        style={{color:'var(--text-main)'}}
                        onClick={()=>{ setThemeManagerOpen(true); setThemeMenuOpen(false); }}
                      >
                        테마 관리
                      </button>
                    </div>
                  )}
                </div>

                <div className="w-px h-8 mx-2 self-center divider"></div>

                <Button variant="secondary" onClick={()=>dataFileInputRef.current?.click()} title="파일 불러오기"><Icons.Upload size={16}/></Button>
                <Button variant="primary" onClick={saveDataAsFile} title="파일로 저장"><Icons.Save size={16}/></Button>

                <button
                  onClick={()=>setIsAdminMode(!isAdminMode)}
                  className="p-2 rounded border"
                  style={{
                    borderColor: 'var(--table-border)',
                    backgroundColor: isAdminMode ? 'var(--highlight-bg)' : 'var(--table-cell-border)',
                    color: isAdminMode ? 'var(--accent)' : 'var(--text-muted)'
                  }}
                  title="관리자 모드"
                >
                  {isAdminMode ? <Icons.Unlock size={20}/> : <Icons.Lock size={20}/>}
                </button>
              </div>
            </div>

            <div className="w-full max-w-[98%] mx-auto px-4 flex">
              {renderTab('register','참가신청',Icons.Users)}
              {renderTab('league','예선 리그',Icons.List)}
              {renderTab('tournament','본선 토너먼트',Icons.Trophy)}
            </div>
          </header>

          <main className="flex-grow w-full relative overflow-hidden" style={{backgroundColor:'var(--bg-body)'}}>
            {activeTab !== 'tournament' ? (
              <div className="h-full overflow-y-auto p-6">
                {activeTab === 'register' && (
                  <div className="grid lg:grid-cols-3 gap-6 max-w-[98%] mx-auto">
                    <div className="lg:col-span-1 space-y-6">
                      <Card>
                        <h3 className="font-bold mb-4 flex items-center gap-2 text-lg" style={{color:'var(--text-main)'}}>
                          <span style={{color:'var(--accent-strong)'}}><Icons.Settings size={20}/></span>
                          대회 설정
                        </h3>

                        <div className="space-y-4">
                          <div>
                            <label className="block text-sm font-medium mb-1" style={{color:'var(--text-muted)'}}>경기 방식</label>
                            <select className="w-full p-2 rounded-lg focus:ring-2 focus:ring-sky-500"
                              value={config.teamSize}
                              onChange={(e)=>setConfig({...config,teamSize:parseInt(e.target.value)})}>
                              {[1,2,3,4,5,6].map(n=><option key={n} value={n}>{n===1 ? '개인 단식' : `${n}인 단체전`}</option>)}
                            </select>
                          </div>

                          <div>
                            <label className="block text-sm font-medium mb-1" style={{color:'var(--text-muted)'}}>합부수 최소</label>
                            <Input type="number" min="0" value={config.minSumLevel} placeholder="없음"
                              onChange={(e)=>setConfig({...config,minSumLevel:e.target.value})}/>
                          </div>
                        </div>
                      </Card>

                      <Card>
                        <h3 className="font-bold mb-4 text-lg" style={{color:'var(--text-main)'}}>팀 등록</h3>

                        <div className="space-y-3">
                          <Input placeholder="팀 이름 (자동)" value={newTeamName} onChange={(e)=>setNewTeamName(e.target.value)}/>
                          {newMembers.map((m,i)=>(
                            <div key={i} className="flex gap-2">
                              <Input placeholder={`팀원${i+1} 이름`} value={m.name} onChange={(e)=>handleMemberChange(i,'name',e.target.value)}/>
                              <Input type="number" className="w-20" placeholder="부수" value={m.level} onChange={(e)=>handleMemberChange(i,'level',e.target.value)}/>
                            </div>
                          ))}
                          <Button onClick={addTeam} className="w-full mt-2"><Icons.Plus/> 등록</Button>

                          {isAdminMode && (
                            <div className="flex gap-2 mt-2">
                              <input type="number" className="w-16 text-center rounded-lg"
                                style={{backgroundColor:'var(--input-bg)', color:'var(--text-main)', border:`1px solid var(--table-border)`}}
                                value={autoGenCount} onChange={(e)=>setAutoGenCount(e.target.value)}/>
                              <Button onClick={generateRandomTeams} variant="magic" className="flex-1"><Icons.Wand/> 자동 생성</Button>
                            </div>
                          )}
                        </div>
                      </Card>

                      <div className="pt-4 border-t" style={{borderColor:'var(--table-border)'}}>
                        <div className="flex items-center gap-2 mb-4">
                          <span className="text-sm font-bold" style={{color:'var(--text-muted)'}}>조 개수:</span>
                          <Input type="number" className="w-20" value={config.groupCount} onChange={(e)=>setConfig({...config,groupCount:parseInt(e.target.value)})}/>
                        </div>
                        <Button variant="secondary" className="w-full" onClick={generateGroups}>리그 대진표 생성 <Icons.ChevronRight/></Button>
                      </div>
                    </div>

                    <div className="lg:col-span-2">
                      <div className="flex justify-between mb-4 items-center">
                        <h3 className="font-bold text-lg" style={{color:'var(--text-main)'}}>팀 목록 ({teams.length})</h3>
                        <div className="flex gap-2">
                          <Button onClick={cycleSort} variant="secondary" className="text-xs">
                            {sortMode==='group'?<Icons.SortGroup size={14}/>:(sortMode==='input'?<Icons.SortDesc size={14}/>:<Icons.SortAsc size={14}/>)} {getSortLabel()}
                          </Button>
                          <Button onClick={clearAllTeams} variant="danger" className="text-xs">초기화</Button>
                        </div>
                      </div>

                      <div className="rounded-xl shadow-lg border overflow-hidden" style={{backgroundColor:'var(--card-bg)', borderColor:'var(--card-border)'}}>
                        <div className="overflow-x-auto">
                          <table className="w-full text-sm text-left modern-table table-auto">
                            <thead>
                              <tr>
                                <th className="px-4 py-3 font-bold">No.</th>
                                <th className="px-4 font-bold">팀명</th>
                                <th className="px-4 font-bold">구성원</th>
                                <th className="px-4 text-center font-bold">합부수</th>
                                {isLeagueGenerated && <th className="px-4 text-center font-bold" style={{color:'var(--accent)', background:'rgba(56,189,248,0.08)'}}>배정된 조</th>}
                                <th className="px-4 text-right font-bold">관리</th>
                              </tr>
                            </thead>
                            <tbody>
                              {teams.length===0 ? (
                                <tr><td colSpan="6" className="text-center py-8" style={{color:'var(--text-muted)'}}>등록된 팀이 없습니다.</td></tr>
                              ) : displayedTeams.map((t,i)=>(
                                <tr key={t.id} className={`team-row ${editingTeamId===t.id?'editing':''}`}>
                                  <td className="px-4 py-2 text-center font-medium" style={{color:'var(--text-muted)'}}>{i+1}</td>

                                  <td className="px-4 font-medium" style={{color:'var(--text-main)'}}>
                                    {editingTeamId===t.id
                                      ? <input className="p-1 w-full rounded" style={{background:'var(--input-bg)', border:`1px solid var(--table-border)`, color:'var(--text-main)'}} value={editTeamData.name} onChange={(e)=>handleEditChange('name',e.target.value)}/>
                                      : t.name}
                                  </td>

                                  <td className="px-4" style={{color:'var(--text-muted)'}}>
                                    {editingTeamId===t.id
                                      ? editTeamData.members.map((m,mi)=>(
                                        <div key={mi} className="flex gap-1 mb-1">
                                          <input className="w-16 p-1 rounded" style={{background:'var(--input-bg)', border:`1px solid var(--table-border)`, color:'var(--text-main)'}} value={m.name} onChange={(e)=>handleEditChange(null,e.target.value,mi,'name')}/>
                                          <input className="w-10 p-1 rounded" style={{background:'var(--input-bg)', border:`1px solid var(--table-border)`, color:'var(--text-main)'}} value={m.level} onChange={(e)=>handleEditChange(null,e.target.value,mi,'level')}/>
                                        </div>
                                      ))
                                      : t.members.map(m=>`${m.name}(${m.level})`).join(', ')}
                                  </td>

                                  <td className="px-4 text-center font-bold" style={{color:'var(--team-level-text)'}}>{t.totalLevel}</td>

                                  {isLeagueGenerated && (
                                    <td className="px-4 text-center">
                                      <select className="rounded p-1 text-xs"
                                        value={t.groupId===null?'':t.groupId}
                                        onChange={(e)=>handleGroupChange(t.id,e.target.value)}>
                                        <option value="" disabled>미배정</option>
                                        {Array.from({length:config.groupCount},(_,k)=><option key={k} value={k}>조 {k+1}</option>)}
                                      </select>
                                    </td>
                                  )}

                                  <td className="px-4 text-right">
                                    {editingTeamId===t.id ? (
                                      <div className="flex justify-end gap-1">
                                        <button onClick={saveEditing} className="p-1 rounded border"
                                          style={{background:'rgba(20,83,45,0.35)', borderColor:'rgba(34,197,94,0.35)', color:'#86efac'}}>
                                          <Icons.Check/>
                                        </button>
                                        <button onClick={cancelEditing} className="p-1 rounded border"
                                          style={{background:'var(--btn-secondary-bg)', borderColor:'var(--btn-secondary-border)', color:'var(--btn-secondary-text)'}}>
                                          <Icons.X/>
                                        </button>
                                      </div>
                                    ) : (
                                      <div className="flex justify-end gap-1">
                                        <button onClick={()=>startEditing(t)} className="p-1 rounded border"
                                          style={{background:'transparent', borderColor:'transparent', color:'var(--text-muted)'}}
                                          title="편집">
                                          <Icons.Edit/>
                                        </button>
                                        <button onClick={()=>removeTeam(t.id)} className="p-1 rounded border"
                                          style={{background:'transparent', borderColor:'transparent', color:'var(--text-muted)'}}
                                          title="삭제">
                                          <Icons.Trash/>
                                        </button>
                                      </div>
                                    )}
                                  </td>
                                </tr>
                              ))}
                            </tbody>
                          </table>
                        </div>
                      </div>
                    </div>
                  </div>
                )}

                {activeTab === 'league' && (
                  <div className="h-full max-w-[98%] mx-auto">
                    <div className="flex flex-wrap justify-between items-center backdrop-blur-sm p-4 rounded-xl border mb-6 shadow-lg no-print"
                      style={{backgroundColor:'var(--table-header-bg)', borderColor:'var(--table-border)'}}>
                      <div className="flex gap-4 items-center flex-wrap">
                        <div className="flex items-center gap-2">
                          <span className="font-bold" style={{color:'var(--accent)'}}>본선:</span>
                          <select className="rounded-lg px-2 py-1 text-sm"
                            value={config.tournamentMode}
                            onChange={(e)=>setConfig({...config,tournamentMode:e.target.value})}>
                            <option value="all">전체</option>
                            <option value="topN">상위부</option>
                            <option value="split">상하위</option>
                          </select>

                          {(config.tournamentMode!=='all') && (
                            <div className="flex items-center text-sm gap-2">
                              <span className="font-bold" style={{color:'var(--text-muted)'}}>상위팀수=</span>
                              <input type="number" min="1" max="12"
                                className="w-12 text-center rounded-lg p-1"
                                style={{backgroundColor:'var(--input-bg)', color:'var(--text-main)', border:`1px solid var(--table-border)`}}
                                value={config.topN}
                                onChange={(e)=>setConfig({...config,topN:Math.min(12, Math.max(1, parseInt(e.target.value)))})}/>
                            </div>
                          )}
                        </div>

                        <div className="w-px h-6 mx-2 divider"></div>

                        <div className="flex items-center gap-2">
                          <span className="font-bold" style={{color:'var(--text-muted)'}}>순위 기준:</span>
                          <select className="rounded-lg px-2 py-1 text-sm"
                            value={config.rankMethod}
                            onChange={(e)=>{const rm = e.target.value; setConfig(prev => ({...prev, rankMethod: rm})); recalcAllGroupRanks(rm);}}>
                            <option value="1">승패 → 승자승 → 득실</option>
                            <option value="2">승패 → 득실 → 승자승</option>
                            <option value="3">득실 → 승자승 → 승패</option>
                            <option value="4">득실 → 승패 → 승자승</option>
                          </select>
                        </div>
                      </div>

                      <div className="flex gap-2 items-center">
                        {isAdminMode && (
                          <Button variant="magic" onClick={generateAutoLeagueResults} className="text-sm py-1 mr-2"
                            title="모든 경기 결과를 3:0, 2:1 등으로 자동 입력하고 순위를 산정합니다.">
                            <Icons.Wand size={16}/> 결과 자동 입력
                          </Button>
                        )}
                        <Button variant="secondary" onClick={()=>handlePrint(null)} className="text-sm py-1"><Icons.Printer size={16}/> 전체 인쇄</Button>
                        <Button onClick={generateTournament} className="text-sm py-1"><Icons.ChevronRight size={16}/> 토너먼트 생성</Button>
                      </div>
                    </div>

                    <div className="flex flex-wrap gap-6 pb-20 justify-start items-start flex-wrap-container">
                      {groups.map(g => (
                        <div key={g.id} className={`print-page-wrapper ${printGroupId===g.id?'target-print':''}`}>
                          <ResizableCard
                            id={g.id}
                            width={cardSizes[g.id]?.w||480}
                            height={cardSizes[g.id]?.h||450}
                            onResize={(id,w,h)=>setCardSizes(p=>({...p,[id]:{w,h}}))}
                            className="print-card"
                          >
                            <div className="flex justify-between items-center w-full">
                              <h3 className="font-bold" style={{color:'var(--text-main)'}}>{g.name}</h3>
                              <div className="flex gap-1 no-print">
                                <button onClick={()=>handlePrint(g.id)} className="mini-btn" title="이 조만 인쇄"><Icons.Printer size={14}/></button>
                                <button onClick={()=>calculateRank(g.id)} className="text-[10px] px-2 py-1 rounded font-bold rank-btn">순위 계산</button>
                              </div>
                            </div>

                            <div className="w-full h-full p-0 flex flex-col">
                              <div className="flex-grow">
                                <table className="modern-table fit-table">
                                  <thead>
                                    <tr>
                                      <th className="team-name-col" style={{width:'20%'}}>팀명</th>
                                      {g.teams.map((t, ti)=>(
                                        <th key={t.id} className={`${getHeaderHighlight(g.id,t.id)} text-[12px] font-bold`}>
                                          <span className="screen-only">{ti+1}</span>
                                          <span className="print-only-inline print-team-name">{formatPrintTeamName(getLeagueDisplayName(t), ti+1)}</span>
                                        </th>
                                      ))}
                                      <th className="stat-col" style={{width:'8%'}}>승</th>
                                      <th className="stat-col" style={{width:'8%'}}>패</th>
                                      <th className="stat-col" style={{width:'8%'}}>득</th>
                                      <th className="stat-col" style={{width:'8%'}}>실</th>
                                      <th className="stat-col" style={{width:'8%'}}>R</th>
                                    </tr>
                                  </thead>

                                  <tbody>
                                    {g.teams.map((r, ri) => {
                                      const isAllZero = (r.leagueStats.win === 0 && r.leagueStats.loss === 0 && r.leagueStats.scoreWin === 0 && r.leagueStats.scoreLoss === 0);
                                      const isRanked = g.teams.some(t => t.leagueStats.rank > 0);
                                      const isQualified = isRanked
                                        ? (r.leagueStats.rank > 0 && r.leagueStats.rank <= config.topN)
                                        : (ri < config.topN);

                                      const qualifyStyle = (isQualified && config.tournamentMode !== 'all')
                                        ? { backgroundColor: 'var(--qualified-row-bg)' }
                                        : undefined;

                                      const qualifyClass = (isQualified && config.tournamentMode !== 'all') ? 'print-highlight' : '';

                                      return (
                                        <tr key={r.id} className={qualifyClass} style={qualifyStyle}>
							<td className={`member-cell font-semibold border-r ${getHeaderHighlight(g.id,r.id)}`}
							          style={{borderColor:'var(--table-cell-border)'}}>
							  <div className="flex items-center">
							    <span className="font-bold mr-2 text-xs" style={{color:'var(--accent)'}}>{ri+1}.</span>
							    
							    {/* 3인 이상이면 '팀명' 표시, 아니면 '구성원 목록' 표시 */}
							    {r.members.length >= 3 ? (
							      <div className="font-bold text-sm whitespace-nowrap" style={{color:'var(--text-main)'}}>
							        {getLeagueDisplayName(r)}
							      </div>
							    ) : (
							      <div className="flex flex-col">
							        {r.members.map((m, k)=>(
							          <div key={k} className="whitespace-nowrap text-xs">
							            {m.name} <span className="text-[0.7em]" style={{color:'var(--text-muted)'}}>({m.level})</span>
							          </div>
							        ))}
							      </div>
							    )}
							  </div>
							</td>

                                          {g.teams.map(c => {
                                            if(r.id===c.id) return <td key={c.id} className="diagonal-cell"></td>;
                                            return (
                                              <td key={c.id} className={getHighlight(g.id,r.id,c.id)}>
                                                <input
                                                  type="number" min="0" className="matrix-input"
                                                  value={g.matrix[`${r.id}_vs_${c.id}`] ?? ''}
                                                  placeholder="-"
                                                  onFocus={()=>setHoverState({g:g.id,r:r.id,c:c.id})}
                                                  onBlur={()=>setHoverState(null)}
                                                  onChange={(e)=>{ if(parseInt(e.target.value)<0) return; updateMatrixScore(g.id,r.id,c.id,e.target.value); }}
                                                />
                                              </td>
                                            );
                                          })}
                                          <td>
                                            <input
                                              type="number"
                                              className="manual-input"
                                              value={isAllZero ? '' : (r.leagueStats.win ?? 0)}
                                              placeholder="-"
                                              onChange={(e) => updateStatManual(g.id, r.id, 'win', e.target.value)}
                                            />
                                          </td>
                                          <td>
                                            <input
                                              type="number"
                                              className="manual-input"
                                              value={isAllZero ? '' : (r.leagueStats.loss ?? 0)}
                                              placeholder="-"
                                              onChange={(e) => updateStatManual(g.id, r.id, 'loss', e.target.value)}
                                            />
                                          </td>
                                          <td>
                                            <input
                                              type="number"
                                              className="manual-input"
                                              value={isAllZero ? '' : (r.leagueStats.scoreWin ?? 0)}
                                              placeholder="-"
                                              onChange={(e) => updateStatManual(g.id, r.id, 'scoreWin', e.target.value)}
                                            />
                                          </td>
                                          <td>
                                            <input
                                              type="number"
                                              className="manual-input"
                                              value={isAllZero ? '' : (r.leagueStats.scoreLoss ?? 0)}
                                              placeholder="-"
                                              onChange={(e) => updateStatManual(g.id, r.id, 'scoreLoss', e.target.value)}
                                            />
                                          </td>
                                          <td>
                                            <input
                                              type="number"
                                              className="manual-input"
                                              value={(r.leagueStats.rank ?? 0) === 0 ? '' : r.leagueStats.rank}
                                              placeholder="-"
                                              onChange={(e) => updateRankManual(g.id, r.id, e.target.value)}
                                            />
                                          </td>
                                        </tr>
                                      );
                                    })}
                                  </tbody>
                                </table>

                                <div className="print-schedule print-only">
                                  {getFormattedSchedule(g.teams.length)}
                                </div>
                              </div>
                            </div>
                          </ResizableCard>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            ) : (
              <div className="tournament-container-wrapper" onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp}>
                <div className="zoom-controls fixed top-24 right-6 z-50 flex items-center gap-3 no-print p-2 rounded-full shadow-lg border"
                  style={{backgroundColor:'var(--control-pill-bg)', borderColor:'var(--control-pill-border)'}}>
                  <div className="flex items-center gap-2 px-2 border-r" style={{borderColor:'var(--control-divider)'}}>
                    <button onClick={()=>setZoom(z=>Math.max(0.3, z-0.1))}
                      style={{color:'var(--control-icon)'}}
                      onMouseEnter={(e)=>e.currentTarget.style.color='var(--control-icon-hover)'}
                      onMouseLeave={(e)=>e.currentTarget.style.color='var(--control-icon)'}
                      title="축소">
                      <Icons.ZoomOut size={16}/>
                    </button>

                    <input type="range" min="0.3" max="2.0" step="0.05" value={zoom}
                      onChange={(e)=>setZoom(parseFloat(e.target.value))}
                      className="w-24 h-1 rounded-lg appearance-none cursor-pointer"
                      style={{ accentColor: 'var(--accent)' }}
                    />

                    <button onClick={()=>setZoom(z=>Math.min(2.0, z+0.1))}
                      style={{color:'var(--control-icon)'}}
                      onMouseEnter={(e)=>e.currentTarget.style.color='var(--control-icon-hover)'}
                      onMouseLeave={(e)=>e.currentTarget.style.color='var(--control-icon)'}
                      title="확대">
                      <Icons.ZoomIn size={16}/>
                    </button>
                  </div>

                  <button onClick={()=>setPan({x:0, y:0})}
                    className="p-1.5 rounded-full"
                    style={{color:'var(--control-icon)'}}
                    onMouseEnter={(e)=>{e.currentTarget.style.color='var(--control-icon-hover)'; e.currentTarget.style.background='var(--control-hover-bg)';}}
                    onMouseLeave={(e)=>{e.currentTarget.style.color='var(--control-icon)'; e.currentTarget.style.background='transparent';}}
                    title="위치 초기화">
                    <Icons.Refresh size={18}/>
                  </button>

                  <button onClick={openNewWindow}
                    className="p-1.5 rounded-full"
                    style={{color:'var(--control-icon)'}}
                    onMouseEnter={(e)=>{e.currentTarget.style.color='var(--control-icon-hover)'; e.currentTarget.style.background='var(--control-hover-bg)';}}
                    onMouseLeave={(e)=>{e.currentTarget.style.color='var(--control-icon)'; e.currentTarget.style.background='transparent';}}
                    title="새 창에서 보기">
                    <Icons.ExternalLink size={18}/>
                  </button>

                  <div className="px-2 text-xs border-l flex items-center gap-1 select-none"
                    style={{color:'var(--control-helper-text)', borderColor:'var(--control-divider)'}}>
                    <Icons.Move size={12}/> Drag
                  </div>
                </div>

                {!tournamentData.brackets.length ? (
                  <div className="flex items-center justify-center h-full z-10 select-none" style={{color:'var(--text-muted)'}}>대진표 없음</div>
                ) : (
                  <div className="tournament-viewport">
                    <div id="tournament-print-area" className="tournament-canvas" style={{ transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})` }}>
                      <div className={`w-full flex flex-col items-center gap-48`}>
				{tournamentData.brackets.map((bracket, bIdx) => {
				  //const finalRoundIdx = bracket.rounds.length - 1;
				  //const finalMatch = bracket.rounds[finalRoundIdx][0];
				  
				  // 위 코드를 아래와 같이 안전하게 변경
				  const finalRoundIdx = bracket.rounds?.length ? bracket.rounds.length - 1 : -1;
				  const finalMatch = (finalRoundIdx >= 0 && bracket.rounds[finalRoundIdx]) ? bracket.rounds[finalRoundIdx][0] : null;
				  if (!finalMatch) return null; // 데이터가 없으면 렌더링 안 함
				  
				  // 3-4위전(준결승 패자) 찾기
				  const semiFinalRound = bracket.rounds.length > 1 ? bracket.rounds[bracket.rounds.length - 2] : null;
				  const thirdPlaces = [];
				  if (semiFinalRound) {
				    semiFinalRound.forEach(m => {
				      if (m.winner) {
				        // 승자가 A면 패자는 B, 승자가 B면 패자는 A
				        if (m.winner.id === m.teamA?.id && m.teamB) thirdPlaces.push(m.teamB);
				        else if (m.winner.id === m.teamB?.id && m.teamA) thirdPlaces.push(m.teamA);
				      }
				    });
				  }

				  // 우승/준우승 결정 로직
				  let winners = [];
				  let runnerUp = null;

				  if (bracket.isJointWinner) {
				    // 공동 우승: 결승전의 두 팀 모두 우승자
				    if (finalMatch.teamA) winners.push(finalMatch.teamA);
				    if (finalMatch.teamB) winners.push(finalMatch.teamB);
				    runnerUp = null; // 공동 우승 시 준우승 없음
				  } else if (finalMatch.winner) {
				    // 일반 우승
				    winners.push(finalMatch.winner);
				    // 준우승: 결승전 패자
				    if (finalMatch.winner.id === finalMatch.teamA?.id) runnerUp = finalMatch.teamB;
				    else runnerUp = finalMatch.teamA;
				  }

				  return (
				    <div key={bIdx} className="flex flex-col items-center print-break">
				      {/* (제목 영역은 기존 코드 유지) */}
				      <div className="mb-10 text-center select-none">
				        <div className="text-xl font-black italic px-10 py-3 inline-block rounded-full shadow-lg tracking-wider border"
				          style={{
				            borderColor: 'rgba(255,255,255,0.10)',
				            background: bIdx===0 ? 'linear-gradient(to right, var(--accent-2), #7c3aed)' : 'linear-gradient(to right, rgba(71,85,105,0.9), rgba(100,116,139,0.9))',
				            color: bIdx===0 ? '#ffffff' : 'var(--text-main)'
				          }}>
				          {bracket.title}
				        </div>
				      </div>

				      <div className="tournament-tree">
				        {/* Left Wing (기존 코드 유지) */}
				        <div className="wing-container left-wing">
				          {bracket.rounds.slice(0, bracket.rounds.length - 1).map((round, rIdx) => {
				             const leftMatches = round.slice(0, round.length / 2);
				             const isLastWingRound = rIdx === bracket.rounds.length - 2;
				             return (
				               <div key={`L-${rIdx}`} className="round-column">
				                 <div className="text-center mb-4 font-bold uppercase text-[10px] tracking-widest select-none" style={{color:'rgba(56,189,248,0.70)'}}>ROUND {rIdx + 1}</div>
				                 {leftMatches.map((match, mIdx) => (
				                   <MatchBox key={match.id} match={match} idx={mIdx} bracketIdx={bIdx} roundIdx={rIdx} isRight={false} noVertical={isLastWingRound} onScore={handleScore} onWin={handleManualWin} onSwap={openSwapModal} />
				                 ))}
				               </div>
				             );
				          })}
				        </div>

{/* Center: Final Match & Badge (수정된 부분: 카드 절대 중앙 고정) */}
        <div className="round-column flex justify-center items-center relative z-20" style={{minWidth: '340px'}}>
          
          {/* 1. 제목: absolute로 흐름에서 제거하여 상단에 고정 (카드를 밀어내지 않음) */}
          <div className="absolute top-0 mt-20 text-center font-black uppercase text-sm tracking-[0.3em] select-none"
            style={{color:'var(--final-title-text)', textShadow:`0 0 10px var(--final-title-shadow)`}}>
            FINAL MATCH
          </div>

          {/* 2. 결승전 카드: 이 요소만 Flex 흐름에 남겨두어 정확히 화면 정중앙에 위치시킴 */}
          <div className="scale-125 z-20 w-full flex justify-center relative group">
             {/* MatchBox에 공동우승 여부(isJointWinner) 전달 */}
             <MatchBox 
               match={finalMatch} 
               idx={0} 
               bracketIdx={bIdx} 
               roundIdx={finalRoundIdx} 
               isRight={false} 
               isFinal={true} 
               isJointWinner={bracket.isJointWinner}
               onScore={handleScore} 
               onWin={handleManualWin} 
               onSwap={()=>{}} 
             />
             
             {/* 공동 우승 버튼 */}
             <div className="absolute -top-12 left-1/2 -translate-x-1/2 opacity-0 group-hover:opacity-100 transition-opacity flex flex-col items-center no-print">
                <button 
                  onClick={() => toggleJointWinner(bIdx)}
                  className={`text-[10px] px-2 py-1 rounded border mb-0.5 whitespace-nowrap shadow-sm ${bracket.isJointWinner ? 'bg-amber-500 text-white border-amber-600' : 'bg-slate-700 text-slate-300 border-slate-600'}`}
                >
                   {bracket.isJointWinner ? '공동우승 ON' : '공동우승 OFF'}
                </button>
                <span className="text-[9px] text-slate-500 bg-slate-900/90 px-1.5 py-0.5 rounded backdrop-blur text-xs">클릭하여 전환</span>
             </div>
          </div>

          {/* 3. 통합 결과 배지: absolute top-1/2로 중앙 기준점을 잡고, padding-top으로 카드를 가리지 않게 아래로 내림 */}
          <div className="absolute top-1/2 pt-36 w-full text-center select-none flex flex-col items-center gap-4 pointer-events-none">
            {/* pointer-events-none을 주어 배지 영역이 커져도 카드 클릭 방해 안 함 (내부 버튼은 pointer-events-auto 필요할 수 있음) */}
            <div className="pointer-events-auto flex flex-col items-center gap-4">
            {winners.length > 0 ? (
              <div className="flex flex-col items-center gap-4 animate-in fade-in zoom-in duration-500">
                {/* 1. 우승 (Champion) */}
                <div className="inline-block px-10 py-5 rounded-2xl font-black ring-2 shadow-2xl relative overflow-hidden"
                  style={{
                    background: `linear-gradient(to right, var(--champion-grad-from), var(--champion-grad-mid), var(--champion-grad-to))`,
                    color: 'var(--champion-text)',
                    boxShadow: `0 0 40px var(--champion-shadow)`,
                    ringColor: 'var(--champion-ring)'
                  }}>
                  <div className="absolute inset-0 bg-white opacity-20" style={{mixBlendMode: 'overlay'}}></div>
                  <div className="text-[11px] uppercase tracking-widest mb-1 font-bold" style={{color:'var(--champion-subtext)'}}>
                    {bracket.isJointWinner ? '공동 우승' : '우승'}
                  </div>
                  <div className="text-xl drop-shadow-sm">
                    <ul style={{ listStyle: 'none', padding: 0, margin: 0 }}>
                      {winners.map((w, index) => (
                        <li key={index}>
                          {w.name}
                        </li>
                      ))}
                    </ul>
                  </div>
                </div>

                {/* 2. 준우승 (Runner-up) - 공동우승 아닐때만 표시 */}
                {runnerUp && (
                  <div className="inline-block px-10 py-5 rounded-2xl rounded-lg border text-sm bg-opacity-20"
                    style={{
                      background: 'var(--table-border)',
                      borderColor: 'var(--table-border)',
                      color: 'var(--text-main)'
                    }}>
                    <div className="text-[11px] uppercase tracking-widest mb-1 font-bold opacity-70">준우승</div>
                    <div className="text-xl drop-shadow-sm">{runnerUp.name}</div>
                  </div>
                )}

                {/* 3. 공동 3위 (3rd Place) */}
                {thirdPlaces.length > 0 && (
                  <div className="flex gap-3 mt-2">
                    {thirdPlaces.map((tp, tpi) => (
                      <div key={tpi} className="px-4 py-2 rounded-lg border text-sm bg-opacity-20"
                        style={{
                          background: 'var(--table-border)',
                          borderColor: 'var(--table-border)',
                          color: 'var(--text-muted)'
                        }}>
                        <span className="text-[9px] block opacity-60">공동3위</span>
                        <span className="font-semibold">{tp.name}</span>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            ) : (
              <div className="w-24 h-24 rounded-full flex items-center justify-center mx-auto shadow-inner border-4"
                style={{background:'var(--trophy-placeholder-bg)', borderColor:'var(--trophy-placeholder-border)', color:'var(--trophy-placeholder-icon)'}}>
                <Icons.Trophy size={32}/>
              </div>
            )}
            </div>
          </div>
        </div>
				        {/* Right Wing (기존 코드 유지) */}
				        <div className="wing-container right-wing">
				          {bracket.rounds.slice(0, bracket.rounds.length - 1).map((round, rIdx) => {
				             const rightMatches = round.slice(round.length / 2);
				             const idxOffset = round.length / 2;
				             const isLastWingRound = rIdx === bracket.rounds.length - 2;
				             return (
				               <div key={`R-${rIdx}`} className="round-column">
				                 <div className="text-center mb-4 font-bold uppercase text-[10px] tracking-widest select-none" style={{color:'rgba(56,189,248,0.70)'}}>ROUND {rIdx + 1}</div>
				                 {rightMatches.map((match, mIdx) => (
				                   <MatchBox key={match.id} match={match} idx={idxOffset + mIdx} bracketIdx={bIdx} roundIdx={rIdx} isRight={true} noVertical={isLastWingRound} onScore={handleScore} onWin={handleManualWin} onSwap={openSwapModal} />
				                 ))}
				               </div>
				             );
				          })}
				        </div>
				      </div>
				    </div>
				  );
				})}
                      </div>
                    </div>
                  </div>
                )}
              </div>
            )}

            {swapModalData && (
              <div className="modal-overlay" onClick={()=>setSwapModalData(null)}>
                <div className="modal-content p-6" onClick={(e)=>e.stopPropagation()}>
                  <div className="flex justify-between items-center mb-4 border-b pb-4" style={{borderColor:'var(--table-border)'}}>
                    <h3 className="text-xl font-bold">🔄 팀 자리 교체</h3>
                    <button onClick={()=>setSwapModalData(null)}
                      className="p-1 rounded-full"
                      style={{color:'var(--text-muted)'}}
                      title="닫기">
                      <Icons.X/>
                    </button>
                  </div>

                  <div className="p-3 rounded-lg text-sm mb-4 border"
                    style={{background:'var(--warning-bg)', color:'var(--warning-text)', borderColor:'var(--warning-border)'}}>
                    <strong>주의:</strong> 자리를 교체하면 해당 경기의 점수와 승패 기록은 초기화됩니다.
                  </div>

                  <div className="flex-1 overflow-y-auto max-h-[50vh] space-y-2 pr-2 custom-scrollbar">
                    {getAllTeams().map((t, i) => {
                      const isSelf = t.bIdx === swapModalData.bracketIdx && t.rIdx === swapModalData.roundIdx && t.mIdx === swapModalData.matchIdx && t.side === swapModalData.side;

                      return (
                        <div key={i}
                          onClick={()=>!isSelf && executeSwap(t.bIdx, t.rIdx, t.mIdx, t.side)}
                          className="p-3 border rounded-xl flex justify-between items-center transition-all"
                          style={{
                            cursor: isSelf ? 'not-allowed' : 'pointer',
                            opacity: isSelf ? 0.55 : 1,
                            borderColor: 'var(--table-border)',
                            background: isSelf ? 'var(--input-focus)' : 'transparent'
                          }}
                          onMouseEnter={(e)=> {
                            if (isSelf) return;
                            e.currentTarget.style.background = 'var(--swap-item-hover-bg)';
                            e.currentTarget.style.borderColor = 'var(--swap-item-hover-border)';
                            e.currentTarget.style.boxShadow = `0 10px 18px -14px var(--swap-item-hover-shadow)`;
                          }}
                          onMouseLeave={(e)=> {
                            e.currentTarget.style.background = isSelf ? 'var(--input-focus)' : 'transparent';
                            e.currentTarget.style.borderColor = 'var(--table-border)';
                            e.currentTarget.style.boxShadow = 'none';
                          }}
                        >
                          <div className="flex items-center gap-3">
                            <span className="tag">{t.bTitle}</span>
                            <div>
                              <div className="font-bold" style={{color:'var(--text-main)'}}>{t.team.name}</div>
                              {t.team.sourceLabel && <div className="text-xs" style={{color:'var(--text-muted)'}}>{t.team.sourceLabel}</div>}
                            </div>
                          </div>

                          {isSelf && <span className="text-xs font-bold px-2" style={{color:'var(--text-muted)'}}>선택됨</span>}
                        </div>
                      );
                    })}
                  </div>
                </div>
              </div>
            )}

            <ThemeManagerModal
              open={themeManagerOpen}
              onClose={()=>setThemeManagerOpen(false)}
              themeKey={themeManagerTab}
              setThemeKey={setThemeManagerTab}
              themeValues={themeOverrides ? themeOverrides[themeManagerTab] : {}}
              onChangeValue={updateThemeValue}
              onSaveToBrowser={saveThemeToBrowser}
              onExportFile={exportThemeFile}
              onImportFile={importThemeFile}
              onResetTheme={resetThemeToDefaults}
            />

            <input
              ref={dataFileInputRef}
              type="file"
              accept="application/json,.json"
              className="hidden"
              onChange={(e)=> {
                const f = e.target.files?.[0];
                if (f) loadDataFromFile(f);
                e.target.value = '';
              }}
            />
          </main>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<PingPongManager />);
  </script>
</body>
</html>
